<!-- TOC -->

- [第10章 泛型算法](#第10章-泛型算法)
  - [10.1 概述](#101-概述)
  - [10.2 初识泛型算法](#102-初识泛型算法)
    - [10.2.1 只读算法 `find`, `accumulate`](#1021-只读算法-find-accumulate)
      - [算法和元素类型 `accumulate`](#算法和元素类型-accumulate)
      - [操作两个序列的算法 `equal`](#操作两个序列的算法-equal)
    - [10.2.2 写容器元素的算法](#1022-写容器元素的算法)
      - [算法不检查写操作](#算法不检查写操作)
      - [介绍 `back_inserter`](#介绍-back_inserter)
      - [拷贝算法](#拷贝算法)
    - [总结一下](#总结一下)
    - [10.2.3 重排容器元素的算法](#1023-重排容器元素的算法)
      - [消除重复单词](#消除重复单词)
      - [使用`unique`](#使用unique)
      - [使用容器操作删除元素](#使用容器操作删除元素)
  - [10.3 定制操作](#103-定制操作)
    - [10.3.1 向算法传递函数](#1031-向算法传递函数)
      - [谓词 (predicate)](#谓词-predicate)
      - [排序算法](#排序算法)
    - [10.3.2 lambda表达式](#1032-lambda表达式)
      - [介绍 `lambda`](#介绍-lambda)
      - [向 `lambda` 传递参数](#向-lambda-传递参数)
      - [使用捕获列表](#使用捕获列表)
      - [调用 `find_if`](#调用-find_if)
      - [`for_each` 算法](#for_each-算法)
      - [完整的 `biggies`](#完整的-biggies)
    - [10.3.3 lambda捕获和返回](#1033-lambda捕获和返回)
      - [值捕获](#值捕获)
      - [引用捕获](#引用捕获)
      - [隐式捕获](#隐式捕获)
      - [可变 `lambda`](#可变-lambda)
      - [指定 `lambda` 返回类型](#指定-lambda-返回类型)
    - [10.3.4 参数绑定](#1034-参数绑定)
      - [标准库 `bind` 函数](#标准库-bind-函数)
      - [绑定 `check_size` 的 `sz` 参数](#绑定-check_size-的-sz-参数)
  - [10.4 再探迭代器](#104-再探迭代器)
    - [10.4.1 插入迭代器](#1041-插入迭代器)
    - [10.4.2 iostream迭代器](#1042-iostream迭代器)
      - [`istream_iterator` 操作](#istream_iterator-操作)
      - [使用算法操作流迭代器](#使用算法操作流迭代器)
      - [`istream_iterator` 允许使用懒惰求值](#istream_iterator-允许使用懒惰求值)
      - [`ostream_iterator`操](#ostream_iterator操)
      - [使用流迭代器处理类类型](#使用流迭代器处理类类型)
  - [10.4.3 反向迭代器](#1043-反向迭代器)
      - [反向迭代器需要递减运算符](#反向迭代器需要递减运算符)
      - [反向迭代器和其他迭代器间的关系](#反向迭代器和其他迭代器间的关系)
  - [10.5 泛型算法结构](#105-泛型算法结构)
    - [10.5.1 5类迭代器](#1051-5类迭代器)
      - [迭代器类别](#迭代器类别)
    - [10.5.2 算法形参模式](#1052-算法形参模式)
    - [算法形参模式](#算法形参模式)
      - [接受单个目标迭代器的算法](#接受单个目标迭代器的算法)
      - [接受第二个输入序列的算法](#接受第二个输入序列的算法)
    - [10.5.3 算法命名规范](#1053-算法命名规范)
      - [一些算法使用重载形式传递一个谓词](#一些算法使用重载形式传递一个谓词)
      - [`_if` 版本的算法](#_if-版本的算法)
      - [区分拷贝元素的版本和不拷贝的版本](#区分拷贝元素的版本和不拷贝的版本)
  - [10.6 特定容器算法](#106-特定容器算法)
      - [`splice` 成员](#splice-成员)
      - [链表特有的操作会改变容器](#链表特有的操作会改变容器)

<!-- /TOC -->

# 第10章 泛型算法

标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法(generic algorithm)。

称它们为“算法”，是因为它们实现了一些经典算法的公共接口，如排序和搜索：

称它们是“泛型的”，是因为它们可以用于不同类型的元素和多种容器类型（不仅包括标准库类型，如`vector`或`list`，还包括内置的数组类型），以及我们将看到的，还能用于其他类型的序列。

## 10.1 概述

大多数算法都定义在头文件 `algorithm` 中。标准库还在头文件 `numeric` 中定义一组数值泛型算法。

例：假定我们有一个`int`的`vector`，希望知道`vector`中是否包含一个特定值。
调用标准库算法`find`：

一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。

```cpp
int val = 42;   // 我们将查找的值
auto result = find(vec.cbegin(), vec.cend(), val);
// 报告结果
cout << "The value " << val
     << (result == vec.cend() ? " is not present" : "is present") << endl;
```

由于`find`操作的是迭代器，因此我们可以用同样的`find`函数在任何容器中查找值。

```cpp
// 可以用 find 在一个 string 的 list 中查找一个给定值：
string val = "a value"; // 我们要查找的值
// 此调用在 list 中查找 string 元素
auto result = find(lst.cbegin(), lst.cend(), val);
```

```cpp
// 我们可以用 find 在数组中查找值：
int a[] = {27, 210, 12, 47, 109, 83};
int val = 83;
int* result = find(begin(ia), end(ia), val);
```

还可以在序列的子范围中查找，只需将指向子范围首元素和尾元素之后位置的迭代器（指针）传递给`find`。
例如，下面你的语句在 `ia[1]`、`ia[2]` 和 `ia[3]` 中查找给定元素。

```cpp
// 在从 ia[1] 开始，直至（但不包含）ia[4] 的范围内查找元素怒
auto result = find(ia + 1, ia + 4, val);
```

**练习10.1：头文件 algorithm 中定义了一个名为 count 的函数，它类似 find，接受一对迭代器和一个值作为参数。count 返回给定值在序列中出现的次数。**

STL 中的`count`算法：

```cpp
count(vi.begin(), vi.end(), val)
```

具体实现：

```cpp
int c = 0;
for (auto iter = vi.begin(); iter != vi.end(); iter++)
    if (*iter == val)
        c++;
```

```cpp
/* 练习10.1：头文件 algorithm 中定义了一个名为 count 的函数，它类似 find，接受一对迭代器和一个值作为参数。count 返回给定值在序列中出现的次数。
编写程序，读取 int 序列存入 vector 中，打印有多少个元素的值等于给定值。*/

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file!" << endl;
        exit(1);
    }

    vector<int> vi;
    int val;
    while (in >> val)
        vi.push_back(val);

    cout << "Please enter the integer you want to search: ";
    cin >> val;

    cout << "The sequnce contains " << count(vi.begin(), vi.end(), val) << "个" << val;

    return 0;
}


// 读者可以尝试自己编写计数整数出现次数的代码：

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file!" << endl;
        exit(1);
    }

    vector<int> vi;
    int val;
    while (in >> val)
        vi.push_back(val);

    cout << "请输入要搜索的整数：";
    cin >> val;

    int c = 0;
    for (auto iter = vi.begin(); iter != vi.end(); iter++)
        if (*iter == val)
            c++;
    cout << "序列中包含" << c << "个" << val;

    return 0;
}
```

**练习10.2：重做上一题，但读取 `string` 序列存入list中。**

解答：理解“泛型”的优点。
可以看到，与上一题对比，程序的变化只在不同类型变量的声明上，而算法的使用部分几乎没有任何差异。

```cpp
/*练习 10.2：重做上一题，但读取 string 序列存入 list 中。
【解答】可以看到，与上一题对比．程序的变化只在不同类型变量的声明上，而算法的 使用部分几乎没有任何差异。*/

#include <iostream>
#include <fstream>
#include <string>
#include <list>
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file!" << endl;
        exit(1);
    }

    list<string> ls;
    string word;
    while (in >> word)
        ls.push_back(word);
    
    cout << "Please enter the strings you wanna search: ";
    cin >> word;

    cout << "The sequence contains " << count(ls.begin(), ls.end(), word)
         << "个" << word;
    
    return 0;
}
```

**关键概念：算法永远不会执行容器的操作。**

## 10.2 初识泛型算法

### 10.2.1 只读算法 `find`, `accumulate`

`find`, `count`, `accumulate`(定义在`numeric`中)

`accumulate`函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。
假定`vec`是一个整数序列，则：

```cpp
// 对 vec 中的元素求和，和的初值是 0
int sum = accumulate(vec.cbegin(), vec.cend(), 0);
```

这条语句将`sum`设置为`vec`中元素的和，和的初值被设置为`0`。

**Note**：`accumulate` 的第三个参数的类型决定了函数中使用哪个加法运算以及返回值的类型。

#### 算法和元素类型 `accumulate`

`accumulate`将第三个参数作为求和起点，这蕴含着个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。

下面是另一个例子，由于`string`定义了`+`运算符，所以我们可以通过调用`accumulate`来将`vector`中所有`string`元素连接起来：

```cpp
string sum = accumulate(v.cbegin(), v.cend(), string(""));
```

此调用将`v`中每个元素连接到一个`string`上．该`string`初始时为空串。
注意，我们通过第三个参数显式地创建了一个`string`。

将空串当做一个字符串字面值传递给第三个参数是不可以的，会导致一个编译错误。

```cpp
// 错误：const char* 上没有定义 + 运算符
string sum = accumulate(v.cbegin(), v.cend(), "");
```

原因在于，如果我们传递了一个字符串字面值．用于保存和的对象的类型将是`const char*`。如前所述，此类型决定了使用哪个`+`运算符。由于`const char*`并没有`+`运算符， 此调用将产生编译错误。

**Best Practices**：对于只读取而不改变元素的算法，通常最好使用`cbegin()`和`cend()`。
但是，如果你计划使用算法返回的迭代器来改变元素的值，就需要使用`begin()`和`end()`的结果作为参数。

#### 操作两个序列的算法 `equal`

另一个只读算法是`equal`，用于确定两个序列是否保存相同的值它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回`true`，否则返回`false`。
此算法接受三个迭代器：前两个（与以往一样）表示第一个序列中的元素范围，第三个表示第二个序列的首元素：

```cpp
// roster2 中的元素数目应该至少与 roster1 一样多
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
```

由于 `equal` 利用迭代器完成操作，因此我们可以通过调用 `equal` 来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用 `==` 来比较两个元素类型即可。 例如，在此例中，`roster1` 可以是 `vector<string>`, 而 `roster2` 是 `list<const char*>`。

但是，`equal` 基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。 此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。

**WARNING**: 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。

**练习10.3：用 accumulate 求一个 `vector<int>` 中的元素之和。**

```cpp
/* 练习10.3：用 accumulate 求一个 vector<int> 中的元素之和。

【解答】Accumulate的前两个参数仍然是指定范围的一对迭代器，第三个参数是和的初值。*/

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <numeric>

using namespace std;

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file!" << endl;
        exit(1);
    }

    vector<int> vi;
    int val;
    while (in >> val)
        vi.push_back(val);

    cout << "The sum of the integers in the sequence is: "
         << accumulate(vi.begin(), vi.end(), 0) << endl;

    return 0;
}
```

```C++
/*练习10.4：假定 v 是一个 vector<double>，那么调用 accumulate(v.cbegin(), v.cend(), 0) 有何错误（如果存在的话）？

【解答】accumulate 的第三个参数是和的初值，它还决定了函数的返回类型，以及函数中使用哪个加法运算符。因此，本题中的调用是错误的，第三个参数 0 告知accumulate，和是整型的，使用整型加法运算符。
读者可尝试输入带小数的值．函数返回的是一个整数。

正确的调用方法是将 0.0 作为第三个参数传递给 accumulate。
读者可以修改、运行程序，观察运行结果。*/

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <numeric>

using namespace std;

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file!" << endl;
        exit(1);
    }

    vector<double> vd;
    double val;
    while (in >> val)
        vd.push_back(val);
    
    cout << "The sum of the floats in the sequence is: " 
         << accumulate(vd.begin(), vd.end(), 0.0) << endl;

    return 0;
}
```

**练习10.5：在本节对名册(roster)调用 `equal` 的例子中，如果两个名册中保存的都是 C 风格字符串而不是 `string`，会发生什么？**

【解答】
`equal` 使用 `==` 运算符比较两个序列中的元素。`string`类重载了 `==`，可比较两个字符串是否长度相等且其中元素对位相等。

而 C 风格字符串本质是 `char*` 类型， 用 `==` 比较两个 `char*` 对象，只是检查两个指针值是否相等，即地址是否相等，而不会比较其中字符是否相同。

所以，只有当两个序列中的指针都指向相同的地址时，`equal` 才会返回 `true`。否则，即使字符串内容完全相同，也会返回 `false`。

如下面的程序，`q` 中的每个字符串是 `p` 中字符串的拷贝，虽然内容相同，但是不同对象指向不同地址，因此 `equal` 判定它们不等。
而 `r` 中每个指针都是 `p` 中指针的拷贝，指向相同的地址，因此 `equal` 判定它们相等。

[注]：`strdup` 可以直接把要复制的内容复制给没有初始化的指针，因为它会自动分配空间给目的指针。
`strdup` 不是标准的c函数。`strdup()` 在内部调用了 `malloc()` 为变量分配内存，不需要使用返回的字符串时，需要用 `free()` 释放相应的内存空间，否则会造成内存泄漏。

```cpp
/*练习10.5：在本节对名册(roster)调用 equal 的例子中，如果两个名册中保存的都是 C 风格字符串而不是 string，会发生什么？*/

#include <iostream>
#include <algorithm>
#include <string.h>

using namespace std;

int main(int argc, char *argv[])
{
    char *p[] = { "Hello", "World", "!" };
    // q 中的每个字符串是 p 中字符串的拷贝，虽然内容相同，但是不同的对象指向不同地址
    char *q[] = { strdup(p[0]), strdup(p[1]), strdup(p[2]) };
    // r 中每个指针都是 p 中指针的拷贝，指向相同的地址，因此 equal 判定它们相等
    char *r[] = { p[0], p[1], p[2] };
    cout << equal(begin(p), end(p), q) << endl; //输出 0
    cout << equal(begin(p), end(p), r) << endl; //输出 1

    return 0;
}
```

### 10.2.2 写容器元素的算法

例如，算法`fill`接受一对迭代器表示一个范围，还接受个值作为第三个参数。
`fill` 将给定的这个值赋予输入序列中的每个元素。

```cpp
fill(vec.begin(), vec.end(), 0);    // 将每个元素重置为 0
// 将容器的一个子序列设置为 10
fill(vec.begin(), vec.begin() + vec.size()/2, 10);
```

**关键概念：迭代器参数**

一些算法从两个序列中读取元素。构成这两个序列的元素可以来自于不同类型的容器。例如，第一个序列可能保存于一个 `vector` 中，而第二个序列可能保存于一个 `list`、`deque`、内置数组或其他容器中。而且，两个序列中元素的类型也不要求严格匹配。算 法要求的只是能够比较两个序列中的元素。例如，对 `equal` 算法，元素类型不要求相同，但是我们必须能使用 `==` 比较来自两个序列中的元素。

操作两个序列的算法之间的区别在于我们如何传递第二个序列。一些算法，例如 `equal`，接受三个迭代器；前两个表示第一个序列的范围，第三个表示第二个序列中的首元素。其他算法接受四个迭代器：前两个表示第一个序列的元素范围，后两个表示第二个序列的范围。 

用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个一样长。 确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。例如，算法 `equal` 会将其第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果第二个序列是第一个序列的一个子集．则程序会产生一个严重错误 —— `equal` 会试图访问第二个序列中末尾之后（不存在）的元素。 

#### 算法不检查写操作

一些算法接受一个迭代器来指出一个单独的目的位置。
这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。

例如，函数`fill_n`接受一个单迭代器、一个计数值和一个值。
它将给定值赋予迭代器指向的元素开始的指定个元素。
我们可以用`fill_n`将一个新值赋予 `vector` 中的元素：

```cpp
vector<int> vec;    // 空vector
// 使用 vec，赋予它不同值
fill_n(vec.begin(), vec.size(), 0); // 将所有元素重置为 0
```

函数 `fill_n` 假定写入指定个元素是安全的。即，如下形式的调用：

`fill_n` 假定 `dest` 指向一个元素，而从`dest`开始的序列至少包含 `n` 个元素。

```cpp
fill_n(dest, n, val)
```

容易犯的错误：在一个空容器上调用 `fill_n`（或类似的写元素的算法）：

```cpp
vector<int> vec;    // 空向量
// 灾难：修改 vec 中的 10 个（不存在）元素
fill_n(vec.begin(), 10, 0);
```

这个调用是一场灾难。我们指定了要写入 `10` 个元素，但 `vec` 中并没有元素，它是空的。所以这条语句的结果是未定义的。

**WARNING**：向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素。

**练习10.6：编写程序，使用 fill_n 将一个序列中的 int 值都设置为 0。**

```cpp
/* 练习10.6：编写程序，使用 fill_n 将一个序列中的 int 值都设置为 0。*/

#include <iostream>
#include <fstream>
#include <vector
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file!" << endl;
        exit(1);
    }

    vector<int> vi;
    int val;
    while (in >> val) {
        vi.push_back(val);
        cout << val << " ";
    }
    cout << endl;

    fill_n(vi.begin(), vi.size(), 0);
    for (auto iter = vi.begin(); iter != vi.end(); iter++)
        cout << *iter << " ";

    return 0;
}
```

#### 介绍 `back_inserter`

一种保证算法有足够元素空间来容纳输出数据的方法是使用**插入迭代器**(insert iterator)。

`back_inserter`是定义在头文件`iterator`中的一个函数。

```cpp
vector<int> vec;    // 空向量
auto it = back_inserter(vec);   // 通过它赋值会将元素添加到 vec 中
*it = 42;   // vec 中现在有一个元素，值为 42
```

我们常常使用`back_inserter`来创建一个迭代器，作为算法的目的位置来使用。

```cpp
vector<int> vec;    // 空向量
// 正确：back_inserter 创建一个插入迭代器，可用来向 vec 添加元素
fill_n(back_inserter(vec), 10, 0);  // 添加 10 个元素到 vec
```

在每步迭代中，`fill_n`向给定序列的一个元素赋值。
由于我们传递的参数是`back_inserter`返回的迭代器，因此每次赋值都会在`vec`上调用`push_back`。
最终，这条`fill_n`调用语句向`vec`的末尾添加了`10`个元素，每个元素的值都是`0`。

**练习10.8：本节提到过，标准库算法不会改变它们所操作的容器的大小。为什么使用`back_inserter`不会使这一断言失效？**

严格来说．**标准库算法根本不知道有“容器”这个东西**。它们只接受迭代器参数，运行于这些迭代器之上，通过这些迭代器来访问元素。

因此，当你传递给算法普通迭代器时，这些迭代器只能顺序或随机访问容器中的元素，造成的效果就是算法只能读取元素、改变元素值、移动元素，但无法添加或删除元素。

但当我们传递给算法插入器，例如`back_inserter`时，**由于这类迭代器能调用下层容器的操作来向容器插入元素**，造成的算法执行的效果就是向容器中添加了元素。

因此，关键要理解：标准库算法从来不直接操作容器，它们只操作迭代器，从而间接访问容器。能不能插入和删除元素，不在于算法，而在于传递给它们的迭代器是否具有这样的能力。

**练习10.7(b)：下面程序是否有错误？如果有，请改正。**

```cpp
/*练习10.7：下面程序是否有错误？如果有，请改正。*/

(b)
vector<int> vec;
vec.reserve(10);
fill_n(vec.begin(), 10, 0);

/* (b）这段程序仍然是错误的。
粗看起来，reserve 为 vec 分配了至少能容纳 10 个 int 的内存空间，调用 fill_n 时，vec已有足够空间。
但泛型算法对于容器的要求并不是有足够的空间，而是足够的元素。
此时vec仍然为空，没有任何元素。
而算法又不具备向容器添加元素的能力，因此 fill_n 仍然失败。
这里，我们还是需要 back_inserter 来让 fill_n 有能力向 vec 添加元素。(重要！)
其实，只有 0 有能力做到这一点，空间大小并不是问题，容器都能根据需要自动扩容。*/

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    vector<int> vec;
    vec.reserve(10);
    fill_n(back_inserter(vec), 10, 0);

    for (auto iter = vec.begin(); iter != vec.end(); iter++)
        cout << *iter << " ";
    cout << endl;

    return 0;
}
```

#### 拷贝算法

拷贝（`copy`）算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。

此算法将输入范围中的元素拷贝到目的序列中。

```cpp
int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)];  // a2 与 a1 大小一样
// ret 指向拷贝到 a2 的尾元素之后的位置
auto ret = copy(begin(a1), end(a1), a2);    // 把 a1 的内容拷贝给 a2
```

我们定义了一个名为 `a2` 的数组，并使用 `sizeof` 确保 `a2` 与数组 `a1` 包含同样多元素（参见.9节，第139页）。接下来我们调用 `copy` 完成从 `a1` 到 `a2` 的拷贝。在调用 `copy` 后，两个数组中的元素具有相同的值。

`copy`返回的是其目的位置迭代器（递增后）的值。即，`ret`恰好直线高靠背到`a2`的尾元素之后的位置。

**练习10.7：下面程序是否有错误？如果有，请改正。**

```cpp
/*练习10.7：下面程序是否有错误？如果有，请改正。*/

(a)
vector<int> vec;
list<int> lst;
int i;
while (cin >> i)
    lst.push_back(i);
copy(lst.cbegin(), lst.cend(), vec.begin());

/* (a）是错误的。
因为泛型算法的一个基本特点是：算法总是通过迭代器操作容器，因此不能直接向／从容器添加、删除元素，无法改变容器大小。
因此，对于copy算法，要求目标序列至少要包含与源序列一样多的元素。
而此程序中，vec进行缺省初始化，它是空的，copy无法进行。
如需改变容器大小，需要使用一类特殊的称为插入器的迭代器。
我们可以将第三个参数改为 back_inserter(vec)，通过它，copy算法即可将lst中元素的拷贝插入到vec的末尾。*/

#include <iostream>
#include <fstream>
#include <vector>
#include <list>
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file!" << endl;
        exit(1);
    }

    list<int> lst;
    vector<int> vec;
    int val;
    while (in >> val)
        lst.push_back(val);

    copy(lst.begin(), lst.end(), back_inserter(vec));

    cout << equal(lst.begin(), lst.end(), vec.begin()) << endl;
    for (auto iter = vec.begin(); iter != vec.end(); iter++)
        cout << *iter << " ";
    cout << endl;

    return 0;
}
```

多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建一个新序列保存这此结果。
例如，`replace`算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。

此算法接受`4`个参数：前两个是**迭代器**，表示输入序列，后两个一个是**要搜索的值**， 另个是**新值**。它将所有等于第一个值的元素替换为第二个值：

```cpp
// 将所有值为 0 的元素改为 42
replace(ilst.begin(), ilst.end(), 0, 42);
```

如果我们希望保留原序列不变，可以调用`replace_copy`。

此算法接受额外第三个迭代器参数，指出调整后序列的保存位置：

```cpp
// 使用 back_inserter 按需要增长目标序列
replace_copy(ilst.cbegin(), ilst.cend(), back_inserter(ivec), 0, 42);
```

此调用后，`ilst` 并未改变，`ivec` 包含 `ilst` 的一份拷贝，不过原来的 `ilst` 中的值为 `0` 的元素在 `ivec` 中都变为 `42`。

### 总结一下

```cpp
// fill_n() 和 back_inserter()
fill_n(back_inserter(vec), 10, 0);

// fill_n()
fill_n(vi.begin(), vi.size(), 0);
for (auto iter = vi.begin(); iter != vi.end(); iter++)
    cout << *iter << " ";

// copy(), back_inserter()
copy(lst.begin(), lst.end(), back_inserter(vec));
cout << equal(lst.begin(), lst.end(), vec.begin()) << endl;
```

**练习10.10：你认为算法不改变容器大小的原因是什么？**

泛型算法的一大优点是“泛型”，也就是一个算法可用于多种不同的数据类型，算法与所操作的数据结构分离。这对编程效率的提高是非常巨大的。

要做到算法与数据结构分离，重要的技术手段就是使用迭代器作为两者的桥梁。算法从不操作具体的容器，从而也就不存在与特定容器绑定，不适用于其他容器的问题。算法只操作迭代器，由迭代器真正实现对容器的访问。不同容器实现自己特定的迭代器（但不同迭代器是相容的），算法操作不同迭代器就实现了对不同容器的访问。

因此，并不是算法应该改变或不该改变容器的问题。为了实现与数据结构的分离，为了实现通用性，**算法根本就不该知道容器的存在**。算法访问数据的唯一通道传来只是迭代器。是否改变容器大小，完全是迭代器的选择和责任。当我们向`fill_n`传递`back_inserter`时，虽然最终效果是向容器添加了新的元素，但对`fill_n`说，根本不知道这回事儿。它仍然像往常一样（通过迭代器）向元素赋予新值，不过这次是通过`back_inserter`来赋值，而`back_inserter`选择将新值添加到了容器而已。

### 10.2.3 重排容器元素的算法

`sort` 会重排输入序列中的元素，使之有序，它是利用元素类型的`<`运算符来实现排序的。

#### 消除重复单词

为了消除重复单词，首先将`vector`排序，使得重复的单词都相邻出现。
一旦`vector`排序完毕，我们就可以使用另一个称为`unique`的标准库算法来重排`vector`，使得不重复的元素出现在`vector`的开始部分。

由于算法不能执行容器的操作，我们将使用`vector`的`erase`成员来完成真正的删除操作：

```cpp
void elimDups(vector<string> &words)
{
    // 按字典序排序 words，以便查找重复单词
    sort(words.begin(), words.end());
    // unique 重排输入范围，使得每个单词只出现一次
    // 排列在范围的前部，返回指向不重复区域之后一个位置的迭代器
    auto end_unique = unique(words.begin(), words.end());
    // 使用向量操作 erase 删除重复单词
    words.erase(end_unique, words.end());
}
```

#### 使用`unique`

P343 有图, `end_unique`是最后一个不重复元素之后的位置

`words`的大小并未改变，它仍有`10`个元素。但这些元素的顺序被改变了——相邻的重复元索被“删除”了．我们将删除打引号是因为`unique`并不真的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分。`unique`返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。

`unique`的实现方式并不是删除重复值，而是将它们交换到了容器的末尾。

**Notes**：标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素。

```cpp
/*练习10.9：实现你自己的 elimDups。测试你的程序，分别在读取输入后、调用 unique 后以及调用 erase 后打印vector 的内容。*/

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

inline void output_words(vector<string> &words)
{
    for (auto iter = words.begin(); iter != words.end(); iter++)
        cout << *iter << " ";
    cout << endl;
}

void elimDups(vector<string> &words)
{
    output_words(words);

    sort(words.begin(), words.end());
    output_words(words);

    auto end_unique = unique(words.begin(), words.end());
    output_words(words);

    words.erase(end_unique, words.end());
    output_words(words);
}

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file!" << endl;
        exit(1);
    }

    vector<string> words;
    string word;
    while (in >> word)
        words.push_back(word);
    
    elimDups(words);

    return 0;
}
```

#### 使用容器操作删除元素

为了真正地删除无用元素，使用`erase`删除从`end_unique`开始直至`words`末尾的范围内的所有元素。

值得注意的是，即使`words`中没有重复单词，这样调用`erase`也是安全的．在此情况下，`unique`会返回`words.end()`。因此，传递给`erase`的两个参数具有相同的值`words.end()`。

迭代器相等意味着传递给`erase`的元素范围为空。删除一个空范围没有什么不良后果，因此程序即使在输入中无重复元素的情况下也是正确的。

## 10.3 定制操作

为了按长度重排 `vector`，我们将使用 `sort` 的第二个版本，此版本是重载过的，它接受第三个参数，此参数是一个 **谓词(predicate)**。

### 10.3.1 向算法传递函数

#### 谓词 (predicate)

标准库算法所使用的谓词分为两类：**一元谓词**(unary predicate)，意味着它们只接受单一参数和**二元谓词**(binary predicate)，意味着它们有两个参数。

```cpp
// 比较函数，用来按长度排序单词
bool isShorter(const string &s1, const string &s2)
{
    return s1.size() < s2.size();
}
// 按长度由短至长排序 words
sort(words.begin(), words.end(), isShorter);
```

#### 排序算法

为了保持相同长度的单词按字典序排列，可以使用 `stable_sort` 算法。这种稳定排序算法维持相等元素的原有顺序。
通过调用`stable_sort`，可以保持等长元素间的字典序：

```cpp
elimDups(words);    // 将 words 按字典序重排，并消除重复单词
// 按长度重新排序，长度相同的单词维持字典序
stable_sort(words.begin(), words.end(), isShorter);
for (const auto &s : words) // 无须拷贝字符串
    cout << s << " ";   // 打印每个元素，以空格分隔
cout << endl;
```

调用前`words`是按字典序排列的，调用之后，`words`会按元素大小排序....

```cpp
/*练习10.11：编写程序，使用 stable_sort 和 isShorter 将传递给你的 elimDups 版本的 vector 排序。打印 vector 的内容，验证你的程序的正确性。*/

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

inline void output_words(vector<string> &words)
{
    for (auto iter = words.begin(); iter != words.end(); iter++)
        cout << *iter << " ";
    cout << endl;
}

bool isShorter(const string &s1, const string &s2)
{
    return s1.size() < s2.size();
}

void elimDups(vector<string> &words)
{
    output_words(words);

    sort(words.begin(), words.end());
    output_words(words);

    auto end_unique = unique(words.begin(), words.end());
    output_words(words);

    words.erase(end_unique, words.end());
    output_words(words);

    stable_sort(words.begin(), words.end(), isShorter);
    output_words(words);
}

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file!" << endl;
        exit(1);
    }

    vector<string> words;
    string word;
    while (in >> word)
        words.push_back(word);
    
    elimDups(words);

    return 0;
}
```

```cpp
/*练习10.12：编写名为 `compareIsbn` 的函数，比较两个 `Sales_data` 对象的 `isbn()` 成员。使用这个函数排序一个保存`Sales_data` 对象的 `vector`。*/

我们将 `compareIsbn` 定义为一个二元谓词，接受两个 `Sales_data` 对象，通过 `isbn` 成员函数获取 `ISBN` 编号，若前者小于后者返回真，否则返回假。

```cpp
inline bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() < rhs.isbn();
}
```

在主程序中，将 `compareIsbn` 作为第三个参数传递给 `sort`，即可实现销售数据按 `ISBN` 号排序。

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include "Sales_data.h"
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    ifstream in (argv[1]);
    if (!in) {
        cout << "Fails to open the file!" << endl;
        exit(1);
    }
}

vector<Sales_data> sds;
Sales_data sd;
while (read(in, sd))
    sds.push_back(sd);

sort(sds.begin(), sds.end(), compareIsbn);

for (const auto &s : sds) {
    print(cout, s);
    cout << endl;
}

return 0;
```

```cpp
/*练习10.13：标准库定义了名为 `partition` 的算法，它接受一个谓词，对容器内容进行划分，使得谓词为 `true` 的值会排在容器的前半部分，而使谓词为 `false` 的值会排在后半部分。算法返回一个迭代器．指向最后一个使谓词为 `true` 的元素之 后的位置。编写函数．接受一个 `string`，返回一个 `bool` 值，指出 `string` 是否有 `5` 个或更多字符。使用此函数划分 `words`。打印出长度大于等于 `5` 的元素。

【出题思路】 练习定义和使用一元谓词
【解答】 本题要求谓词判断一个 `string` 对象的长度是否大于等于 `5`，而不是比较两个 `string` 对象，因此它应是一个一元谓词。其他与上一题基本类似。但需要注意，我们应该保存 `partition` 返回的迭代器 `iter`，打印范围 `[words.begin(), iter)` 中的字符串。*/

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

inline void output_words(vector<string>::iterator beg, vector<string>::iterator end)
{
    for (auto iter = beg; iter != end; iter++)
        cout << *iter << " ";
    cout << endl;
}

bool five_or_more(const string &s1)
{
    return s1.sisze() >= 5;
}

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file!" << endl;
        exit(1);
    }

    vector<string> words;
    string word;
    while (in >> word)
        words.push_back(word);
    output_words(words.begin(), words.end());

    auto iter = partition(words.begin(), words.end(), five_or_more);
    output_words(words.begin(), iter);

    return 0;
}
```

### 10.3.2 lambda表达式

#### 介绍 `lambda`

我们可以向一个算法传递任何类别的 **可调用对象（callable object）**。对于一个对象或一个表达式，如果可以对其使用调用运算符（参见1.5.2节，第21页），则称它为可调用的。即，如果 `e` 是一个可调用的表达式，则我们可以编写代码 `e(args)`，其中 `args` 是一个都好分隔的一个或多个参数的列表。

到目前为止，我们使用过的仅有的两种可调用对象是函数和函数指针（参见6.7节，第221页）。还有其他两种可调用对象：重载了函数调用运算符的类，我们将在 14.8节（第506页）介绍，以及**lambda表达式（lambda expression）**。

一个 `lambda` 表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个 `lambda` 具有一个返回类型、一个参数列表和一个函数体。但与函数不同，`lambda` 可能定义在函数内部。一个 `lambda` 表达式具有如下形式：

```cpp
[capture list](parameter list) -> return type { function body }
```

其中，`capture list`（捕获列表）是一个 `lambda` 所在函数中定义的局部变量的列表（通常为空）：`return type`、`parameter list` 和 `function body` 与任何普通函数一样，分别表示返回类型、 参数列表和函数体。但是，与普通函数不同，`lambda` 必须使用尾置返回（参见6.3.3节， 第206页）来指定返回类型。 

我们可以忽略参数列表和返回类型，当必须永远包含捕获列表和函数体

```cpp
auto f = [] { return 42; };
```

此例中，我们定义了一个可调用对象 `f`，它不接受参数，返回 `42`。

`lambda` 的调用方式与普通函数的调用方式相同，都是使用调用运算符：

```cpp
cout << f() << endl; // 打印42
```

在 `lambda` 中忽略括号和参数列表等价于指定一个空参数列表。在此例中，当调用 `f` 时，参数列表是空的。如果忽略返回类型，`lambda` 根据函数体中的代码推断出返回类型。 如果函数体只是一个 `return` 语句，则返回类型从返回的表达式的类型推断而来。否则，返回类型为 `void`。

**Note**：如果 `lambda` 的函数体包含任何单一 `return` 语句之外的内容，且未指定返回类型，则返回 `void`。

#### 向 `lambda` 传递参数

与一个普通函数调用类似，调用一个 `lambda` 时给定的实参被用来初始化 `lambda` 的形参。通常，实参和形参的类型必须匹配。但与普通函数不同，`lambda` 不能有默认参数（参见6.5.1节，第211页》。因此，一个 `lambda` 调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。
作为一个带参数的 `lambda` 的例子，我们可以编写一个与 `isShorter` 函数完成相同功能的 `lambda`：

```cpp
// 比较函数，用来按长度排序单词
bool isShorter(const string &s1, const string &s2)
{
    return s1.size() < s2.size();
}
// 按长度由短至长排序 words
sort(words.begin(), words.end(), isShorter);
```

```cpp
[](const string &a, const string &b)
	{ return a.size() < b.size(); }
```

空捕获列表表明此 `lambda` 不使用它所在函数中的任何局部变量。`lambda` 的参数与 `isShorter` 的参数类似，是 `const string` 的引用。`lambda` 的函数体也与 `isShorter` 类似，比较其两个参数的 `size()`，并根据两者的相对大小返回一个布尔值。

如下所示，可以使用此 `lambda` 来调用 `stable_sort`：

```cpp
// 按长度排序长度相同的单词维持字典序
stable_sort(words.begin(), words.end(),
            [](const string&a, const string &b)
            	{ return a.size() < b.size(); });
```

当 `stable_sort` 需要比较两个元素时，它就会调用给定的这个 `lambda` 表达式。

#### 使用捕获列表

我们现在己经准备好解决原来的问题了——编写一个可以传递给 `find_if` 的可调用表达式。我们希望这个表达式能将输入序列中每个 `string` 的长度与 `biggies` 函数中的 `sz` 参数的值进行比较。

```cpp
// 使程序只打印大于等于给定长度的单词
void biggies(vector<string> &words, vector<string>::size_type sz)
{
    elimDups(words); // 将 words 按字典序排序，删除重复单词
    // 按长度排序，长度相同的单词维持字典序
    stable_sort(words.begin(), words.end(), isShorter);
    // 获取一个迭代器，指向第一个满足 size() >= sz 的元素
    // 计算满足 size >= sz 的元素的数目
    // 打印长度大于等于给定值的单词，每个单词后面接一个空格
}
```

虽然一个 `lambda` 可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个 `lambda` 通过将局部变量包含在其捕获列表中来指出将会使用这些变量。 捕获列表指引 `lambda` 在其内部包含访问局部变量所需的信息。

在本例中，我们的 `lambda` 会捕获 `sz`，并只有单一的 `string` 参数。其函数体会将 `string` 的大小与捕获的 `sz` 的值进行比较：

```cpp
[sz](const string &a)
	{ return a.size() >= sz; };
```

`lambda` 以一对 `[]` 开始，我们可以在其中提供一个以逗号分隔的名字列表，这些名字都是它所在函数中定义的。 由于此 `lambda` 捕获`sz`，因此 `lambda` 的函数体可以使用 `sz`。 `lambda` 不捕获 `words` 因此不能访问此变量。如果我们给 `lambda` 提供一个空捕获列表，则代码会编译错误：

```cpp
// 错误：sz 未捕获
[](const string &a)
	{ return a.size() >= sz; };
```

**Note**：一个 `lambda` 只有在其捕获列表中国捕获一个它所在函数的局部变量，才能在函数中使用该变量。

#### 调用 `find_if`

使用此 `lambda`，我们就可以查找第一个长度大于等于 `sz` 的元素：

```cpp
// 获取一个迭代器，指向第一个满足 size() >= sz 的元素
auto wc = find_if(words.begin(), words.end(),
                 [sz](const string &a)
                { return a.size() >= sz; });
```

这里对 `find_if` 的调用返回一个迭代器，指向第一个长度不小于给定参数 `sz` 的元素。 如果这样的元素不存在，则返回 `words.end()` 的一个拷贝。

我们可以使用 `find_if` 返回的迭代器来计算从它开始到 `words` 的末尾一共有多少个元素（参见3.4.2节，第99页）: 

```cpp
// 计算满足 size >= sz 的元素的数目
auto count = words.end() - wc;
cout << count << " " << make_plural(count, "word", "s")
     << " of length " << sz << " or longer" << endl;
```

我们的输出语句调用 `make_plural` (参见6.3.2节，第201页）来输出“`word`“，或 “`words`” 具体输出哪个取决于大小是否等于 `1`。 

#### `for_each` 算法

问题的最后一部分是打印 `words` 中长度大于等于 `sz` 的元素。为了达到这一目的，我们可以使用 `for_each` 算法。此算法接受一个可调用对象，并对输入序列中每个元素调用此对象：

```cpp
// 打印长度大于等于给定值的单词，每个单词后面接一个空格
for_each(wc, words.end(),
        [] (const string &s) {cout << s << " ";});
cout << endl;
```

此 `lambda` 中的捕获列表为空，但其函数体中还是使用了两个名字：`s` 和 `cout`，前者是它自己的参数。 
捕获列表为空，是因为我们只对 `lambda` 所在函数中定义的（非`static`）变量使用捕获列表。一个 `lambda` 可以直接使用定义在当前函数之外的名字。在本例中，`cout` 不是定 义在 `biggies` 中的局部名字，而是定义在头文件 `iostream` 中。因此，只要在 `biggies` 出现的作用域中包含了头文件 `iostream`，我们的 `lambda` 就可以使用 `cout`。 

**Note**：捕获列表只用于局部非 `static` 变量，`lamdba` 可以直接使用局部 `static` 变量和在它所在函数之外声明的名字。

#### 完整的 `biggies`

到目前为止，我们已经解决了程序的所有细节，下面就是完整的程序：

```cpp
void biggies(vector<string> &words, vector<string>::size_type sz)
{
    elimDups(words); // 将 words 按字典序排序，删除重复单词
    // 按长度排序，长度相同的单词维持字典序
    stable_sort(words.begin(), words.end(),
                [](const string &a, const string &b)
	                { return a.size() < b.size(); });
    // 获取一个迭代器，指向第一个满足 sizes() >= sz 的元素
    auto wc = find_if(words.begin(), words.end(),
                [sz](const string &a)
                    { return a.size() >= sz; });
    // 计算满足 size >= sz 的元素的数目
    auto count = words.end() - wc;
    cout << count << " " << make_plural(count, "word", "s")
         << " of length " << sz << " or longer" << endl;
    // 打印长度大于等于给定值的单词，每个单词后面接一个空格
    for_each(wc, words.end(),
    		 [](const string &s) { cout << s << " ";});
    cout << endl;
}
```

**练习10.14：编写一个 `lambda`，接受两个 `int`，返回它们的和。**

【出题思路】练习定义和使用简单的 `lambda`。
【解答】 由于此 `lambda` 无须使用所在函数中定义的局部变量，所以捕获列表为空。参数列表为两个整型。返回类型由函数体唯一的语句——返回语句推断即可。

```cpp
#include <iostream>

using namespace std;

int main(int argc, char *argv[])
{
    auto sum = [] (int a, int b) { return a + b; };

    cout << sum(1, 1) << endl;
    
    return 0;
}
```

**练习10.15：编写一个 `lambda`，捕获它所在函数的 `int`，并接受一个 `int` 参数。`lambda` 应该返回捕获的 `int` 和 `int` 参数的和。**

```cpp
#include <iostream>

using namespace std;

void add(int a)
{
    auto sum = [a] (int b) { return a + b; };

    cout << sum(1) << endl;
}

int main(int argc, char *argv[])
{
    add(1); //输出 2
    add(2); //输出 3

    return 0;
}
```

**练习10.16：使用 lambda 编写你自己版本的 `biggies`。**

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include "make_plural.h"

using namespace std;

inline void output_words(vector<string> &words)
{
    for (auto iter = words.begin(); iter != words.end(); iter++)
        cout << *iter << " ";
    cout << endl;
}

void elimDups(vector<string> &words)
{
    sort(words.begin(), words.end());
    auto end_unique = unique(words.begin((), words.end()));
    words.erase(end_unique, words.end());
}

void biggies(vector<string> &words,
            vector<string>::size_type sz)
{
    elimDups(words); // 将 words 按字典序排序，删除重复单词
    // 按长度排序，长度相同的单词维持字典序
    stable_sort(words.begin(), words.end(),
            [](const string &a, const string &b)
                { return a.size() < b.size(); });
    // 获取一个迭代器，指向第一个满足 size() >= sz 的元素
    auto wc = find_if(words.begin(), words.end(),
            [sz](const string &a)
                { return a.size() >= sz; });
    // 计算满足 size >= sz 的元素的数目
    auto count = words.end() - wc;
    cout << count << " " << make_plural(count, "word", "s")
         << " of length " << sz << " or longer" << endl;
    // 打印长度大于等于给定值的单词，每个的那次后面借一个空格
    for_each(wc, words.end(),
        [](const string &s) { cout << s << " "; });
    cout << endl;
}

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file! " << endl;
        exit(1);
    }

    vector<string> words;
    string word;
    while (in >> word)
        words.push_back(word);
    biggies(words, 4);

    return 0;
}
```

**练习10.12：编写名为 `compareIsbn` 的函数，比较两个 `Sales_data` 对象的 `isbn()` 成员。使用这个函数排序一个保存`Sales_data` 对象的 `vector`。**

我们将 `compareIsbn` 定义为一个二元谓词，接受两个 `Sales_data` 对象，通过 `isbn` 成员函数获取 `ISBN` 编号，若前者小于后者返回真，否则返回假。

```cpp
inline bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() < rhs.isbn();
}
```

在主程序中，将 `compareIsbn` 作为第三个参数传递给 `sort`，即可实现销售数据按 `ISBN` 号排序。

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include "Sales_data.h"
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    ifstream in (argv[1]);
    if (!in) {
        cout << "Fails to open the file!" << endl;
        exit(1);
    }
}

vector<Sales_data> sds;
Sales_data sd;
while (read(in, sd))
    sds.push_back(sd);

sort(sds.begin(), sds.end(), compareIsbn);

for (const auto &s : sds) {
    print(cout, s);
    cout << endl;
}

return 0;
```

**练习10.17：重写 10.3.1 接练习 10.12（第345页）的程序，在对 `sort` 的调用中使用 `lambda` 来代替函数 `compareIsbn`。**

解答：此 `lambda` 比较两个给定的 `Sales_data` 对象，因此捕获列表为空，有两个 `Sales_data` 对象引用的参数。函数体则与 `compareIsbn` 相同。

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include "Sales_data.h"
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file! " << endl;
        exit(1);
    }

    vector<Sales_data> sds;
    Sales_data sd;
    while (read(in, sd))
        sds.push_back(sd);
    
    sort(sds.begin(), sds.end(),
        [](const Sales_data &lhs, const Sales_data &rhs)
        { return lhs.isbn() < rhs.isbn(); });
    
    for (const auto &s : sds) {
        print(cout, s);
        cout << endl;
    }

    return 0;
}
```

**练习10.18：重写 `biggies`，用 `partition` 代替 `find_if`。我们在10.3.1节练习10.13（第345页）中介绍了 `partition` 算法。**

对于本题而言，若使用 `find_if`，要求序列已按字符串长度递增顺序排好序。`find_if` 返回第一个长度 `>=sz` 的字符串的位置 `wc`，则所有满足长度 `>=sz` 的字符串位于范围 `[wc, end)` 之间。

而 `partition` 不要求序列己排序，它对所有字符串检查长度是否 `>=sz`，将满足条件的字符串移动到序列前端，不满足条件的字符串都移动到满足条件的字符串之后，返回满足条件的范围的尾后迭代器。因此满足条件的字符串位于范围 `[begin, wc)` 之间。

因此，在 `partition` 之前不再需要 `stable_sort`，计数语句和打印语句也都要进行相应修改。

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include "make_plural.h"

using namespace std;

void elimDups(vector<string> &words)
{
    sort(words.begin(), words.end());
    auto end_unique = unique(words.begin(), words.end());
    words.erase(end_unique, words.end());
}

void biggies(vector<string> &words, vector<string>::size_type sz)
{
    elimDups(words); // 将 words 按字典序排序，删除重复单词
    for_each(words.begin(), words.end(),
        [](const string &s){ cout << s << " "; });
    cout << endl;
    // 获取一个迭代器，指向最后一个满足 size() >= sz 的元素之后的位置
    auto wc = partition(words.begin(), words.end(),
                    [sz](const string &a)
                        { return a.size() >= sz; });
    // 计算满足 size >= sz 的元素的数目
    auto count = wc - words.begin();
    cout << count << " " << make_plural(count, "word", "s")
         << " of length " << sz << " or longer" << endl;
    // 打印长度大于等于给定值的单词，每个单词后面接一个空格
    for_each(words.begin(), wc,
        [](const string &s) { cout << s << " "; });
    cout << endl;
}

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file! " << endl;
        exit(1);
    }

    vector<string> words;
    string word;
    while (in >> word)
        words.push_back(word);
    
    biggies(words, 4);

    return 0;
}
```

**练习10.19：用 `stable_partition` 重写前一题的程序，与 `stable_sort` 类似，在划分后的序列中维持原有元素的顺序。**

【出题思路】理解 `stable_partition` 和 `partition` 的不同。
【解答】 将上一题程序中的 `partition` 换为 `stable_partition` 即可。在输入文件上观察两个程序输出的不同。

### 10.3.3 lambda捕获和返回

当定义一个 `lambda` 时，编译器生成一个与 `lambda` 对应的新的（未命名的）类类型。我们将在14.8.1节（第507页）介绍这种类是如何生成的。目前，可以这样理解，当向一个函数传递一个 `lambda` 时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用 `auto` 定义一个用 `lambda` 初始化的变量时，定义了一个从 `lambda` 生成的类型的对象。

默认情况下，从 `lambda` 生成的类都包含一个对应该 `lambda` 所捕获的变量的数据成员。类似任何普通类的数据成员， `lambda` 的数据成员也在 `lambda` 对象创建时被初始化。

#### 值捕获

类似参数传递，变量的捕获方式也可以是值或引用。表10.1（第352页）列出了几种不同的构造捕获列表的方式。到目前为止，我们的`lambda` 采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在 `lambda` 创建时拷贝，而不是调用时拷贝：

```cpp
void fcn1()
{
    size_t v1 = 42; //局部变量
    // 将 v1 拷贝到名为 f 的可调用对象
    auto f = [v1] { return v1; };
    v1 = 0;
    auto j = f(); // j 为 42； f 保存了我们创建它时 v1 的拷贝
}
```

由于被捕获变量的值是在 `lambda` 创建时拷贝，因此随后对其修改不会影响到 `lambda` 内对应的值。 

#### 引用捕获

我们定义 `lambda` 时可以采用应用方式捕获变量。例如：

```cpp
void fcn2()
{
    size_t v1 = 42; // 局部变量
    // 对象 f2 包含 v1 的引用
    auto f2 = [&v1] { return v1; };
    v1 = 0;
    auto j = f2(); // j 为 0； f2 保存 v1 的引用，而非拷贝
}
```

`v1` 之前的 `&` 指出 `v1` 应该以引用方式捕获。一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在 `lambda` 函数体内使用此变量时，实际上使用的是引用所绑定的对象。在本例中，当 `lambda` 返回 `v1` 时，它返回的是 `v1` 指向的对象的值。

引用捕获与返回引用（参见6.3.2节，第201页）有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就必须确保被引用的对象在 `lambda` 执行的时候是存在的。`lambda` 捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果 `lambda` 可能在函数结束后执行，捕获的引用指向的局部变量己经消失。

引用捕获有时是必要的。例如，我们可能希望 `biggies` 函数接受一个 `ostream` 的引用，用来输出数据，并接受一个字符作为分隔符：

```cpp
void biggies(vector<string> &words,
            vector<string>::size_type sz,
            ostream &os = cout, char c = ' ')
{
    // 与之前例子一样的重排 words 的代码
    // 打印 count 的语句改为打印到 os
    for_each(words.begin(), words.end(),
            [&os, c](const string &s) { os << s << c; });
}
```

我们不能拷贝 `ostream` 对象（参见8.1.1节，第279页），因此捕获 `os` 的唯一方法就是捕获其引用（或指向 `os` 的指针）。

当我们向一个函数传递一个 `lambda` 时，就像本例中调用 `for_each` 那样，`lambda` 会立即执行。在此情况下，以引用方式捕获 `os` 没有问题，因为当 `for_each` 执行时， `biggies` 中的变量是存在的。

我们也可以从一个函数返回 `lambda`。函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个 `lambda`，则与函数不能返回一个局部变量的引用类似，此 `lambda` 也不能包含引用捕获。

**WARNING**：当以引用方式捕获一个变量时，必须保证在 `lambda` 执行时变量是存在的。

**建议：尽量保持 `lambda` 的变量捕获简单化**

一个 `lambda` 捕获从 `lambda` 被创建（即，定义 `lambda` 的代码执行时）到 `lambda` 自身执行（可能有多次执行）这段时问内保存的相关信息。确保 `lambda` 每次执行的时候这些信急都有预期的意义，是程序员的责任。

捕获一个普通变量，如 `int`、`string` 或其他非指针类型，通常可以采用简单的值捕获方式。在此情况下，只需关注变量在捕获时是否有我们所需的值就可以了。

如果我们捕获一个指针或迭代器，或采用引用捕获方式，就必须确保在 `lambda` 执行时，绑定到迭代器、指针或引用的对象仍然存在。而且，需要保证对象具有预期的值。 在 `lambda` 从创建到它执行的这段时间内，可能有代码改变绑定的对象的值。也就是说，在指针（或引用）被捕获的时刻，绑定的对象的值是我们所期望的．但在 `lambda` 执行时，该对象的值可能已经完全不同了。

一般来说，我们应该尽量减少捕获的数据量，来避免潜在的捕获导致的问题。而且，如果可能的话，应该避免捕获指针或引用。

#### 隐式捕获

除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据 `lambda` 体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个 `&` 或 `=`。`&` 告诉编译器采用捕获引用方式，`=` 则表示采用值捕获方式。例如，我们可以重写传递给 `find_if` 的 `lambda `：

```cpp
// sz 为隐式捕获，值捕获方式
wc = find_if(words.begin(), words.end(),
            [=](const string &s)
             { return s.size() >= sz; });
```

如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获：

```cpp
void biggies(vector<string> &words,
            vector<string>::size_type sz,
            ostream &os = cout, char c = ' ')
{
    // 其他处理与前例一样
    // os 隐式捕获，引用捕获方式；c 显式捕获，值捕获方式
    for_each(words.begin(), words.end(),
            [&, c](const string &s) { os << s << c; });
    // os 显式捕获，引用捕获方式；c 隐式捕获，值捕获方式
    for_each(words.begin(), words.end(),
            [=, &os](const string &s) { os << s << c; });
}
```

当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个 `&` 或 `=`。此符号指定了默认捕获方式为引用或值。

当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。即，如果隐式捕获是引用方式（使用了`&`)，则显式捕获命名变量必须采用值方式，因此不能在其名字前使用 `&`。类似的，如果隐式捕获采用的是值方式（使用了`=`)，则显式捕获命名变量必须采用引用方式，即，在名字前使用 `&`。

| 表10.1：               | `lambda` 捕获列表                                            |
| ---------------------- | ------------------------------------------------------------ |
| `[]`                   | 空捕获列表。`lambda` 不能使用所在函数中的变量。一个 `lambda` 只有捕获变最后才能使用它们。 |
| `[names]`              | `names` 是一个逗号分隔的名字列表，这些名字部是 `lambda` 所在函数的局部变量。默认情况下，捕获列表中的变量都被拷贝。名字前如果使用了 `&`，则采用引用捕获方式 |
| `[&]`                  | 隐式捕获列表，采用引用捕获方式。`lambda` 体中所使用的来自所在函数的实体都采用引用方式使用 |
| `[=]`                  | 隐式捕获列表，采用值捕获方式。`lambda` 体将拷贝所使用的来自所在函数的实体的值 |
| `[&, identifier_list]` | `identifier_list` 是一个逗号分隔的列表，包含 `0` 个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。`identifier_list` 中的名字前面不能使用 `&` |
| `[=, identifier_list]` | `identifier_list` 中的变量都采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。`identifier_list` 中的名字不能包括 `this`，且这些名字之前必须使用 `&`。 |

#### 可变 `lambda`

默认情况下，对于一个值被拷贝的变量，`lambda` 不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字 `mutable`。因此，可变 `lambda` 能省略参数列表：

```cpp
void fcn3()
{
    size_t v1 = 42; // 局部变量
    // f 可以改变它所捕获的变量的值
    auto f = [v1] () mutable { return ++v1; };
    v1 = 0;
    auto j = f(); // j 为 43
}
```

一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个 `const` 类型还是一个非 `const` 类型：

```cpp
void fcn4()
{
    size_t v1 = 42; // 局部变量
    // v1 是一个非 const 变量的引用
    // 可以通过 f2 中的引用来改变它
    auto f2 = [&v1] { return ++v1; };
    v1 = 0;
    auto j = f2(); // j 为 1
}
```

#### 指定 `lambda` 返回类型

到目前为止，我们所编写的 `lambda` 都只包含单一的 `return` 语句。因此，我们还未遇到必须指定返回类型的情况。默认情况下，如果一个 `lambda` 体包含 `return` 之外的任何语句，则编译器假定此 `lambda` 返回 `void`。与其他返回 `void` 的函数类似，被推断返回 `void` 的 `lambda` 不能返回值。

下面给出了一个简单的例子，我们可以使用标准库 `transform` 算法和一个 `lambda` 来将一个序列中的每个负数替换为其绝对值：

```cpp
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i) { return i < 0 ? -i : i; });
```

函数 `transform` 接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中每个元素调用可调用对象，并将结果写到目的位置。如本例所示，目的位置迭代器与表示输入序列开始位置的迭代器可以是相同的。当 输入迭代器和目的迭代器相同时，`transform` 将输入序列中每个元素替换为可调用对象操作该元素得到的结果。

在本例中，我们传递给 `transform` 一个 `lambda`，它返回其参数的绝对值。`lambda` 体是单一的 `return` 语句，返回一个条件表达式的结果。我们无须指定返回类型，以根据条件运算符的类型推断出来。
但是，如果我们将程序改写为看起来是等价的 `if` 语句，就会产生编译错误：

```cpp
// 错误：不能推断 lambda 的返回类型
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i) { if (i < 0) return -i; else return i; });
```
编译器推断这个版本的 `lambda` 返回类型为 `void`，但它返回了一个 `int` 值。

当我们需要为一个 `lambda` 定义返回类型时，必须使用尾置返回类型（参见6.3.3节，第206页）：

```cpp
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i) -> int
         { if (i < 0) return -i; else return i; });
```

在此例中，传递给 `transform` 的第四个参数是一个 `lambda`，它的捕获列表是空的，接受单一 `int` 参数，返回一个 `int` 值。它的函数体是一个返回其参数的绝对值的 `if` 语句。

**练习10.20：标准库定义了一个名为 `count_if` 的算法。类似 `find_if`，此函数接受一对迭代器，表示一个输入范围，还接受一个谓词，会对输入范围中每个元素执行。 `count_if` 返回一个计数值，表示谓词有多少次为真。使用 `count_if` 重写我们程序中统计有多少单词长度超过 `6` 的部分。**

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include "make_plural.h"

using namespace std;

inline void output_words(vector<string> &words)
{
    for (auto iter = words.begin(); iter != words.end(); iter++)
        cout << *iter << " ";
    cout << endl;
}

void biggies(vector<string> &words, vector<string>::size_type sz)
{
    output_words(words);
    // 统计满足 size() >= sz 的元素的个数
    auto bc = count_if(words.begin(), words.end(),
        [sz](const string &a)
            { return a.size() >= sz; });
    cout << bc << " " << make_plural(bc, "word", "s")
         << " of length " << sz << " or longer" << endl;
}

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file!" << endl;
        exit(1);
    }

    vector<string> words;
    string word;
    while (in >> word)
        words.push_back(word);

    biggies(words, 6);

    return 0;
}
```

**练习10.21：编写一个 `lambda`，捕获一个局部 `int` 变量，并递减变量值，直至它变为 `0`。一旦变量变为 `0`，再调用 `lambda` 应该不再递减变量。`lambda` 应该返回一个 `bool` 值，指出捕获的变量是否为 `0`。**

解答：若 `lambda` 需要改变捕获的局部变量的值，需要在参数列表之后、函数体之前使用 `mutable` 关键字。
对于本体，由于 `lambda` 有两个返回语句（`i` 大于 `0` 时返回 `false`，等于 `0` 时返回 `true`），还需要显式指定 `lambda` 的返回类型——使用尾置返回类型，在参数列表后使用 `->bool`。注意，正确的顺序是 `mutable -> bool`。
由于 `i` 的初始值为 `5`，程序执行后会打印 `5` 个 `0` 和 `1` 个 `1`。

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

void mutable_lambda(void)
{
    int i = 5;
    auto f = [i] () mutable -> bool { if (i > 0) {i--; return false;} else return true; };

    for (int j = 0; j < 6; j++)
        cout << f() << " ";
    cout << endl;
}

int main(int argc, char *argv[])
{
    mutable_lambda();

    return 0;
}
```

### 10.3.4 参数绑定

P354

#### 标准库 `bind` 函数

我们可以解决向 `check_size` 传递一个长度参数的问题，方法是使用一个新的名为 `bind` 的标准库函数，它定义在头文件 `functional` 中。可以将 `bind` 函数看作一个通用的函数适配器（参见9.6节．第329页），它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。

```cpp
// 调用 bind 的一般形式为：
auto newCallable = bind(callable, arg_list);
```

其中，`newCallable` 本身是一个可调用对象，`arg_list` 是一个逗号分隔的参数列表，对应给定的 `callable` 的参数。即，当我们调用`newCallable` 时，`newCallable` 会调用 `callable`，并传 递给它 `arg_list` 中的参数。

`arg_list`中的参数可能包含形如 `_n` 的名字，其中 `n` 是一个整数。这些参数是“占位符” 表示 `newCallable` 的参数，它们占据了传递给 `newCallable` 的参数的“位置”。数值 `n` 表示 生成的可调用对象中参数的位置：`_1` 为 `newCallable` 的第一个参数，`_2` 为第二个参数，依此类推。

#### 绑定 `check_size` 的 `sz` 参数

我们将使用 `bind` 生成一个调用 `check_size` 的对象，如下所示，它用一个定值作为其大小参数来调用 `check_size`：

```c++
// check6 是一个可调用对象，接受一个string类型的参数
// 并用此string和值6 来调用 check_size
auto check6 = bind(check_sizse, _1, 6);
```

看不懂，未完待续 P355

## 10.4 再探迭代器

除了为每个容器定义的迭代器之外，标准库在头文件 `iterator` 中还定义了额外几种迭代器，这些迭代器包括以下几种。

- **插入迭代器** (`insert iterator`)：这些迭代器被绑定到一个容器上，可用来向容器插入元素。
- **流迭代器**(`stream iterator`)：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的 `IO` 流。
- **反向迭代器**(`reverse iterator`)：这些迭代器向后而不是向前移动，除了 `forward_list` 之外的标准库容器都有反向迭代器。
- **移动迭代器**(`move iterator`)：这些专用的迭代器不是拷贝其中的元素，而是移动它们。

### 10.4.1 插入迭代器

插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。表10.2 列出了这种迭代器支持的操作。

| 表10.2：          | 插入迭代器操作                                               |
| ----------------- | ------------------------------------------------------------ |
| `it = t`          | 在 `it` 指定的当前位置插入值 `t`。假定 `c` 是 `it` 绑定的容器，依赖于插入迭代器的不同种类，此赋值会分别调用 `c.push_back(t)`、`c.push_front(t)` 或 `c.insert(t, p)` ，其中 `p` 为传递给 `inserter` 的迭代器位置。 |
| `*it, ++it, it++` | 这些操作虽然存在，但不会对 `it` 做任何事情，每个操作都返回 `it`。 |

插入起有三种类型，差异在于元素插入的位置：

- `back_inserter` 创建一个使用 `push_back` 的迭代器。
- `front_inserter` 创建一个使用 `push_front` 的迭代器。
- `inserter` 创建一个使用 `insert` 的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。

**Note**：只有在容器支持 `push_front` 的情况下，我们才可以使用 `front_inserter`。类似的，只有在容器支持 `push_back` 的情况下，我们才能使用 `back_inserter`。

理解插入器的过程是很重要的。当调用 `inserter(c, iter)` 时，我们得到一个迭代器，接下来使用它时会将元素插入到 `iter` 原来所指向的元素之前的位置。即，如果 `it` 是由 `inserter` 生成的迭代器，则下面这样的赋值语句，

```cpp
*it = val;
```

其效果与下面代码一样

```cpp
it = c.insert(it, val); // it 指向新加入的元素
++it; // 递增 it 使它指向原来的元素
```

```cpp
list<int> lst = {1,2,3,4};
list<int> lst2, lst3; // 空 list
// 拷贝完成之后，lst2 包含4 3 2 1
copy(lst.cbegin(), lst.cend(), front_inserter(lst2));
// 拷贝完之后，lst3 包含1 2 3 4
copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));
```

当调用 `front_inserter(c)` 时，我们得到一个插入迭代器，接下来会调用 `push_front`。当每个元素被插入到容器 `c` 中时，它变为 `c` 的新的首元素。因此 `front_inserter` 生成的迭代器会将插入的元素序列的顺序颠倒过来，而 `inserter` 和 `back_inserter` 则不会。

**练习10.26：解释三种插入迭代器的不同之处。**

三者的差异在于如何向容器插入元素：
`back_inserter` 调用 `push_back`，`front_inserter` 调用 `push_front`，`inserter` 则调用 `insert`。

显然，这也决定了它们插入元素位置的不同。`back_inserter` 总是插入到容器尾元素之后，`front_inserter` 总是插入到容器首元素之前，而 `insert` 则是插入到给定位置（作为`inserter` 的第二个参数传递给它）之前。因此，需要注意这些特点带来的元素插入效果的差异。例如，使用 `front_inserter` 向容器插入一些元素元素，元素最终在容器中的顺序与插入顺序相反，但 `back_inserter` 和 `inserter` 则不会有这个问题。

**练习10.27：除了 `unique` (参见10.2.3节，第343页) 之外，标准库还定义了名为 `unique_copy` 的函数，它接受第三个迭代器，表示拷贝不重复元素的目的位置。编写一个程序,使用 `unique_copy` 将一个 `vector` 中不重复的元素拷贝到一个初始为空的 `list` 中。**

本题练习 `unique_copy` 的使用，以及使用插入迭代器帮助算法(`unique_copy`)实现向容器插入新元素。

本题要求将 `vector` 中不重复元素按原顺序拷贝到空 `list` 中，因此使用 `back_inserter` 即可。需要注意的是，与 `unique` 一样，`unique_copy` 也要求在原容器中重复元素是相邻存放的。因此，若 `vector` 未排序且重复元素未相邻存放，`unique_copy` 就会失败。稳妥的方法是先对 `vector` 排序。

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    vector<int> vi = { 1, 2, 2, 3, 4, 5, 5, 6};
    list<int> li;
    
    unique_copy(vi.begin(), vi.end(), back_inserter(li));
    
    for (auto v : li)
        cout << v << " ";
    cout << endl;
    
    return 0;
}
```

由于要保持原顺序，显然使用 `inserter` 也是可以的，将 `back_inserter(li)` 替换为 `inserter(li, li.begin())`  即可。

**练习10.28：一个 `vector` 中保存 `1~9` 共 `9` 个值，将其拷贝到三个其他容器中，分别使用 `inserter`、`back_inserter` 和 `front_inserter` 将元素添加到三个容器中，对每种 `inserter` 估计输出序列是怎样的，运行程序验证你的估计是否正确。**

解答：若三个目的容器均为空，则显然 `insert` 和 `back_insert` 的输出结果是 `1 2 3 4 5 6 7 8 9`，而 `front_inserter` 的结果是 `9 8 7 6 5 4 3 2 1`。但如果目的容器不空，则 `inserter` 的结果取决于传递给它的第二个参数（一个迭代器）指向什么位置。

```cpp
#include <iostream>
#include <vector>
#include <list>
#iclude <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    vector<int> vi = { 1, 2, 3, 4, 5, 6, 7, 8, 9};
    list<int> li1, li2, li3;
    
    unique_copy(vi.begin(), vi.end(), inserter(li1, li1.begin()));
    for (auto v : li1)
        cout << v << " ";
    cout << endl;
    
    unique_copy(vi.begin(), vi.end(), back_inserter(li2));
    for (auto v : li2)
        cout << v << " ";
    cout << endl;
    
    unique_copy(vi.begin(), vi.end(), front_inserter(li3));
    for (auto v : li3)
        cout << v << " ";
    cout << endl;
    
    return 0;
}
```

### 10.4.2 iostream迭代器

虽然 `iostream` 类型不是容器，但标准库定义了可以用这些 `IO` 类型对象的迭代器（参见8.1节，第278页）。`istream_iterator` （参见表 10.3）读取输入流，`ostream_iterator`（参见表10.4节，第361页）向一个输出流写数据。这些迭代器将它们对应的流当做一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。

#### `istream_iterator` 操作

当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。
一个 `istream_iterator` 使用 `>>` 来读取流。因此，`istream_iterator` 要读取的类型必须定义了输入运算符。当创建一个 `istream_iterator` 时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当做尾后值使用的迭代器。

```cpp
istream_iterator<int> int_it(cin); // 从cin读取int
istream_iterator<int> int_eof; // 尾后迭代器
ifstream in("afile");
istream_iterator<string> str_it(in); // 从"afile"读取字符串
```

下面是一个用 `istream_iterator` 从标准输入读取数据，存入一个 `vector` 的例子：

```cpp
istream_iterator<int> in_iter(cin); // 从cin读取int
istream_iterator<int> eof; 			// istream尾后迭代器
while (in_iter != eof)				// 当有数据可供读取时
    // 后置递增运算读取流，返回迭代器的旧值
    // 解引用迭代器，获得从流读取的前一个值
    vec.push_back(*in_iter++);
```

此循环从 `cin` 读取 `int` 值，保存在 `vec` 中。在每个循环部中，循环体代码检查 `in_iter` 是否等于 `eof`。`eof` 被定义为空的 `istream_iterator`，从而可以当做尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到 `IO` 错误，迭代器的值就与尾后迭代器相等。

此程序最困难的部分是传递给 `push_back` 的参数，其中用到了解引用运算符和后置递增运算符。该表达式的计算过程与我们之前写过的其他结合解引用和后置递增运算的表达式一样。后置递增运算会从流中读取下一个值，向前推进，但返回的是迭代器的旧值，迭代器的旧值包含了从流中读取的前一个值，对迭代器进行解引用就能获得此值。

我们可以将程序重写为如下形式，这体现了 `istream_iterator` 更有用的地方：

```cpp
istream_iterator<int> in_iter(cin), eof; // 从 cin 读取 int
vector<int> vec(in_iter, eof); // 从迭代器范围构造 vec
```

本例中，我们用一对表示元素范围的迭代器来构造 `vec`。这两个迭代器是 `istream_iterator`，这意味着元素范围是通过从关联的流中读取数据获得的。这个构造函数从 `cin` 中读取数据，直至遇到文件尾或者遇到一个不是 `int` 的数据为止。从流中读取的数据被用来构造 `vec`。

| 表10.3：                      | `istream_iterator` 操作                                      |
| ----------------------------- | ------------------------------------------------------------ |
| `istream_iterator<T> in(is);` | `in` 从输入流 `is` 读取类型为 `T` 的值                       |
| `istream_iterator<T> end;`    | 读取类型为 ` T`的值的 `istream_iterator` 迭代器，表示尾后位置- |
| `in1 == in2`                  | `in1` 和 `in2` 必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同的输入，则两者相等。 |
| `in1 != in2`                  |                                                              |
| `*in`                         | 返回从流中读取的值                                           |
| `in->mem`                     | 与 `(*in).mem` 的含义相同                                    |
| `++in, in++`                  | 使用元素类型所定义 `>>` 的运算符从输入流中读取下一个值。与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值。 |

#### 使用算法操作流迭代器

我们可以用某些算法来操作流迭代器。例子，我们可以用一对 `istream_iterator` 来调用 `accumulate`：

```cpp
istream_iterator<int> in(cin), eof;
cout << accumulate(in, eof, 0) << endl;
```

此调用会计算出从标准输入读取的值的和。如果输入为：
`23 109 45 89 6 30 42 90 3 14 23 56 23 8 8 19 23`
则输出 `664`。

#### `istream_iterator` 允许使用懒惰求值

当我们将一个 `istream_iterator` 绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建了一个 `istream_iterator`，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。

#### `ostream_iterator`操

我们可以对任何具有输出运算符（`<<` 运算符）的类型定义 `ostream_iterator`。当创建一个 `ostream_iterator` 时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个C风格字符串（即，一个字符串字面常量或者一个指向以空字符结尾的字符数组的指针）。必须将 `ostream_iterator` 绑定到一个指定的流，不允许空的或者表示尾后位置的 `ostream_iterator`。

| 表10.4：                          | `ostream_iterator` 操作                                      |
| --------------------------------- | ------------------------------------------------------------ |
| `ostream_iterator<T> out(os);`    | `out` 将类型为 `T` 的值写到输出流 `os` 中                    |
| `ostream_iterator<T> out(os, d);` | `out` 将类型为 `T` 的值写到输出流 `os` 中，每个值后面都输出一个 `d`。`d` 指向一个空字符结尾的字符数组。 |
| `out = val`                       | 用 `<<` 运算符将 `val` 写入到 `out` 所绑定的 `ostream` 中。`val` 的类型必须与`out` 可写的类型兼容。 |
| `*out, ++out, out++`              | 这些运算符是存在的，但不对 `out` 做任何事情。每个运算符都返回 `out`。 |

我们可以用 `ostream_iterator` 来输出值的序列：

```cpp
ostream_iterator<int> out_iter(cout, " ");
for (auto e : vec)
    *out_iter++ = e; // 赋值语句实际上将元素写到 cout
cout << endl;
```

此程序将 `vec` 中的每个元素写到 `cout`，每个元素后加一个空格，每次向 `out_iter` 赋值时，写操作就会被提交。

值得注意的是，当我们向 `out_iter` 赋值时，可以忽略解引用和递增运算。即，循环可以重写成下面的样子：

```cpp
for (auto e : vec)
    out_iter = e; // 赋值语句将元素写到 cout
cout << endl;
```

运算符 `*` 和 `++` 实际上对 `ostream_iterator` 对象不做任何事情，因此忽略它们对我们的程序没有任何影响。但是，推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保持一致。如果想将此循环改为操作其他迭代器类型，修改起来非常容易。而且，对于读者来说，此循环的行为也更为清晰。

可以通过调用 `copy` 来打印 `vec` 中的元素，这比编写循环更为简单：

```cpp
copy(vec.begin(), vec.end(), out_iter);
cout << endl;
```

#### 使用流迭代器处理类类型

我们可以为任何定义了输入运算符 `>>` 的类型创建 `istream_iterator` 对象。类似的，只要类型有输出运算符 `<<`，我们就可以为其定义 `ostream_iterator`。由于 `Sales_item` 既有输入运算符，也有输出运算符，因此可以使用 `IO` 迭代器重写 1.6节(第21页)中的书店程序。

```cpp
istream_iterator<Sales_item> item_iter(cin), eof;
ostream_iterator<Sales_item> out_iter(cout, "\n");
//将第一笔交易记录存在sum中，并读取下一条记录
Sales_item sum = *item_iter++;
while (item_iter != eof) {
    //如果当前交易（存在 item_iter 中）有着相同的 ISBN 号
    if (item_iter->isbn() == sum.isbn())
        sum += *item_iter++; //将其加到sum上并读取下一条记录
    else {
        out_iter = sum;		//输出sum当前值
        sum = *item_iter++;	//读取下一条记录
    }
}
out_iter = sum;	//记得打印最后一组记录的和
```

此程序使用 `item_iter` 从 `cin` 读取 `Sales_item` 交易记录，并将和写入 `cout`，每个结果后面都跟一个换行符。定义了自己的迭代器后，我们就可以用 `item_iter` 读取第一条交易记录，用它的值来初始化 `sum`：

```cpp
// 将第一条交易记录保存在sum中，并读取下一条记录
Sales_item sum = *item_iter++;
```

此处我们对 `item_iter` 执行后置递增操作，对结果进行解引用操作。这个表达式读取下一条交易记录，并用之前保存在 `item_iter` 中的值来初始化 `sum`。

`while` 循环会反复执行，直至在 `cin` 上遇到文件尾为止。在 `while` 循环体中，我们检查 `sum` 与刚刚读入的记录是否对应同一本书。如果两者的 ISBN 不同，我们将 `sum` 赋予 `out_iter`，这将会打印 `sum` 的当前值，并接着打印一个换行符。在打印了前一本书的交易金额之和后，我们将最近读录的交易记录的副本赋予 `sum`，并递增迭代器，这将读取下一条交易记录。循环会这样持续下去，直至遇到错误或文件尾。在退出之前，记住要打印输入中最后一本书的交易金额之和。

**练习10.29：编写程序，使用流迭代器读取一个文本文件，存入一个 `vector` 中的 `string` 里。**

解答：练习流迭代器的简单使用。
虽然流不是容器，但标准库提供了通过迭代器访问流的方法。声明一个流迭代器时，需指出所绑定的流。对于本题，首先打开一个文本文件，将此文件的流作为参数提供给流迭代器的构造函数即可。当默认构造流迭代器时，得到一个尾后迭代器，对应文件结束。

```c++
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file! " << endl;
        exit(1);
    }
    
    // 创建流迭代器，从文件读入字符串
    istream_iterator<string> in_iter(in);
    // 尾后迭代器
    istream_iterator<string> eof;
    vector<string> words;
    while (in_iter != eof)
        words.push_back(*in_iter++); // 存入vector并递增迭代器
    for (auto word : words)
        cout << word << " ";
    cout << endl;
    
    return 0;
}
```

**练习10.30：使用流迭代器，`sort` 和 `copy` 从标准输入读取一个整数序列，将其排序，并将结果写到标准输出。**

解答：练习输出流迭代器的使用。
使用流迭代器从标准输入读取整数序列的程序与上一题类似，创建流迭代器时指出是 `int` 并用 `cin` 代替文件流对象即可。
用 `copy` 将整数写到标准输出，需要声明一个输出流迭代器，作为第三个参数传递给 `copy`。将 `cin` 传递给输出流迭代器的构造函数，`copy` 即可将整数写到标准输出。将 "` `" 作为第二个参数传递给输出流迭代器的构造函数，表示在每个输出之后写一个空格，从而将整数分隔开来输出。


```c++
#include <iostream>
#include <fstream>
#include <vector>
#include <iterator>
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    // 创建流迭代器，从标准输入读入整数
    istream_iterator<int> in_iter(cin);
    // 尾后迭代器
    istream_iterator<string> eof;
    vector<int> vi;
    while (in_iter != eof)
        vi.push_back(*in_iter++); // 存入vector并递增迭代器

    sort(vi.begin(), vi.end());
    
    ostream_iterator<int> out_iter(cout, " ");
    copy(vi.begin(), vi.end(), out_iter);
    
    return 0;
}
```

**练习10.31：修改前一题的程序使其只打印不重复的元素，你的程序应使用 `unique_copy`(参见10.4.1节，第359页)。**

解答：继续练习输出流迭代器的使用，并复习 `unique_copy` 的使用。
用 `unique_copy` 替代上提的 `copy` 即可。

```c++
#include <iostream>
#include <fstream>
#include <vector>
#include <iterator>
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    // 创建流迭代器，从标准输入读入整数
    istream_iterator<int> in_iter(cin);
    // 尾后迭代器
    istream_iterator<string> eof;
    vector<int> vi;
    while (in_iter != eof)
        vi.push_back(*in_iter++); // 存入vector并递增迭代器

    sort(vi.begin(), vi.end());
    
    ostream_iterator<int> out_iter(cout, " ");
    unique_copy(vi.begin(), vi.end(), out_iter);
    
    return 0;
}
```

**练习10.32：重写1.6节（第21页）中的书店程序**

未完待续

**练习10.33：编写程序接受三个参数，一个输入文件和两个输出文件的文件名。输入文件保存的应该是整数。使用 `istream_iterator` 读取输入文件。使用 `ostream_iterator` 将奇数写入第一个输出文件，每个值之后都跟一个空格。将偶数写入第二个输出文件，每个值都独占一行。**

解答：本题通过一个稍大的例子巩固输入和输出流迭代器的使用。

```c++
#include <iostream>
#include <fstream>
#include <iterator>
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    if (argc != 4) {
        cout << "Usage: exercise.exe in_file out_file1 out_file2" << endl;
        return -1;
    }
    
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the fiel! " << endl;
        exit(1);
    }
    
    ofstream out1(argv[2]);
    if (!out1) {
        cout << "Fails to open file1 ! " << endl;
        exit(1);
    }
    
    ofstream out2(argv[3]);
    if (!out2) {
        cout << "Fails to open file2 ! " << endl;
        exit(1);
    }
    
    // 创建流迭代器从文件读入整数
    istream_iterator<int> in_iter(in);
    // 尾后迭代器
    istream_iterator<int> eof;
    // 第一个输出文件以空格间隔整数
    ostream_iterator<int> out_iter1(out1, " ");
    // 第二个输出文件以换行间隔整数
    ostream_iterator<int> out_iter2(out2, "\n");
    while (in_iter != eof) {
        if (*in_iter & 1) //奇数写入第一个输出文件
            *out_iter1++ = *in_iter;
        else *out_iter2++ = *in_iter; //偶数写入第二个输出文件
        in_iter++;
    }
    
    return 0;
}
```

## 10.4.3 反向迭代器

除了 `forward_list` 之外，其他容器都支持反向迭代器，我们可以通过调用 `rbegin`、`rend`、`crbegin` 和 `crend` 成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有 `const` 和非 `const` 版本。

下面的循环是一个使用反向迭代器的例子，它按逆序打印 `vec` 中的元素：

```c++
vector<int> vec = {0,1,2,3,4,5,6,7,8,9};
//从尾元素到首元素的反向迭代器
for (auto r_iter = vec.crbegin(); //将 r_iter 绑定到尾元素
     r_iter != vec.crend(); 	  //crend 指向首元素之前的位置
     ++r_iter)					  //实际是递减，移动到前一个元素
    cout << *r_iter << endl;	  //打印 9, 8, 7, ... 0
```

虽然颠倒递增和递减运算符的含义可能看起来令人混淆，但这样做使我们可以用算法透明的向前或向后处理容器。例如，可以通过向 `sort` 传递一对反向迭代器，来将 `vector` 整理为递减序：

```c++
sort(vec.begin(), vec.end()); // 按“正常序”排序 vec
// 按逆序排序，将最小元素放在 vec 的末尾
sort(vec.rbegin(), vec.rend());
```

#### 反向迭代器需要递减运算符

除了 `forward_list` 之外，标准容器上的其他迭代器都既支持递增运算又支持递减运算。但是流迭代器不支持递减运算，因为不可能在一个流中反向移动，因此不可能从一个 `forward_list` 或一个流迭代器创建反向迭代器。

#### 反向迭代器和其他迭代器间的关系

假定有一个名为 `line` 的 `string`，保存着一个逗号分隔的单词列表，我们希望打印 `line` 中的第一个单词。使用 `find` 可以很容易地完成这一任务：

```c++
// 在一个逗号分隔的列表中查找第一个元素
auto comma = find(line.cbegin(), line.cend(), ',');
cout << string(line.cbegin(), comma) << endl;
```

如果 `line` 中有逗号，那么 `comma` 将指向这个逗号；否则他将等于 `line.cend()`。当我们打印从 `line.cbegin()` 到 `comma` 之间的内容时，将打印到逗号为止的字符，或者打印整个 `string` （如果其中不含逗号的话）。

如果希望打印最后一个单词，可以改用反向迭代器：

```c++
// 在一个逗号分隔的列表中查找最后一个元素
auto rcomma = find(line.crbegin(), line.crend(), ',');
```

由于我们将 `crbegin()` 和 `crend()` 传递给 `find`，`find` 将从 `line` 的最后一个字符开始向前搜索。当 `find` 完成后，如果 `line` 中有逗号，则 `rcomma` 指向最后一个逗号——即，它指向反向搜索中找到的第一个逗号。如果 `line` 中没有逗号，则 `rcomma` 指向 `line.crend()`。

当我们试图打印找到的单词时，最有意思的部分就来了，看起来下面的代码是显然的方法，但它会生成错误的输出结果。例如我们的输入是 `FIRST, MIDDLE, LAST`，则这条语句会打印 `TSAL` 而不是 `LAST`。

```c++
// 错误：将逆序输出单词的字符
cout << string(line.crbegin(), rcomma) << endl;
```

图10.2说明了问题所在，我们使用的是反向迭代器，会反向处理 `string`。因此，上述输出语句从 `crbegin()` 开始反向打印 `line` 中内容。而我们希望按正常顺序打印从 `rcomma` 开始到 `line` 末尾间的字符。但是我们不能直接使用 `rcomma`，因为它是一个反向迭代器，意味着它会反向朝着 `string` 的开始位置移动。需要做的是将 `rcomma` 转换回一个普通迭代器，能在 `line` 中正向移动。我们通过调用 `reverse_iterator` 的 `base` 成员函数来完成这一转换，此成员函数会返回其对应的普通迭代器：

```c++
//正确:得到一个正向迭代器。从逗号开始读取字符直到line末尾
cout << string(rcomma.base(), line.cend()) << endl;
```

![图10.2：反向迭代器和普通迭代器间的关系](https://raw.githubusercontent.com/KimmiGYH/CPP_Primer_Notes_Public/master/%E7%AC%AC10%20%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.4.3%20%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8/%E5%9B%BE10.2%EF%BC%9A%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%99%AE%E9%80%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png)

图10.2中的对象显示了普通迭代器与反向迭代器之间的关系。例如，`rcomma` 和 `rcomma.base()` 指向不同的元素，`line.crbegin()` 和 `line.cend()` 也是如此。这些不同保证了元素范围无论是正向处理还是反向处理都是相同的。

从技术上讲，普通迭代器与反向迭代器的关系反映了左闭合区间的特性。关键点在于 `[line.crbegin(), rc omma)` 和 `[rcomma.base(), line.cend())`  指向 `line`中，相同的元素范围。为了实现这一点，`rcomma` 和 `rcomma.base()` 必须生成相邻位置而不是相同位置，`crbegin()` 和 `cend()` 也是如此。

**Note**：反向迭代器的目的是表示元素范围，而这些范围是不对称的，这导致一个重要的结果：当我们从一个普通迭代器初始化一个反向迭代器，或是给一个反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同的元素。

**练习10.34：使用 `reverse_iterator` 逆序打印一个 `vector`。**

解答：练习反向迭代器的简单使用。

```c++
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    if (argc != 2) {
        cout << "Usage: exercise.exe in_file" << endl;
        return -1;
    }
    
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file! " << endl;
        exit(1);
    }
    
    vector<int> vi;
    int v;
    while (in >> v) //从文件中读取整数
        vi.push_back(v);
    
    for (auto r_iter = vi.crbegin(); r_iter != vi.crend(); ++r_iter)
        cout << *r_iter << " ";
    cout << endl;
    
    return 0;
}
```

**练习10.35：使用普通迭代器逆序打印一个 `vector`。**

解答：体会反向迭代器和普通迭代器的差异。

若使用普通迭代器反向遍历容器，首先通过 `cend` 获得容器的尾后迭代器，循环中递减该迭代器，直到它与 `begin` 相等为止。但需要注意的是，遍历所用迭代器的初值为尾后位置，终值为 `begin` 之后的位置。也就是说，在每个循环步中，它指向的都是我们要访问的元素之后的位置。因此，我们在循环中首先将其递减，然后通过它访问容器元素，而在循环语句的第三个表达式中就不再递减迭代器了。
显然，对于反向遍历容器，使用反向迭代器比普通迭代器更加清晰易懂。

```c++
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    if (argc != 2) {
        cout << "Usage: exercise.exe in_file" << endl;
        return -1;
    }
    
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file! " << endl;
        exit(1);
    }
    
    vector<int> vi;
    int v;
    while (in >> v) //从文件中读取整数
        vi.push_back(v);
    
    for (auto r_iter = vi.cend(); r_iter != vi.begin();)
        cout << *(--r_iter) << " "; //终值为 begin 之后的位置
    cout << endl;
    
    return 0;
}
```

**练习10.36：使用 `find` 在一个 `int` 的 `list` 中查找最后一个值为 `0` 的元素。**

解答：练习反向迭代器和算法的结合。

借助反向迭代期可以扩展算法的能力。例如，使用普通迭代器，`find` 能查找给定值，在容器中第一次出现的位置。如果要查找最后一次出现的位置，还使用普通迭代器的话，代码会很复杂。但借助反向迭代器，`find` 可以逆序遍历容器中的元素，从而 “第一次出现位置” 实际上也就是正常顺序的最后一次出现位置了。

注意：
1. 由于 `list` 是链表数据结构，元素不连续存储，其迭代器不支持算术运算。因此，程序中用一个循环来计数位置编号。
2. 由于程序技术的是正向位置编号，因此需要将 `find` 找到的反向迭代器 `last_z` 转换为普通迭代器（使用`base` 成员函数）。但要注意，反向迭代器与普通迭代器的转换是左闭合区间的转换，而非精确位置的转换。`last_z.base()` 指向的并非最后一个 `0`，而是它靠近容器尾方向的邻居。因此首先要将 `last_z` 向容器首方向推进一个位置（`++`），然后再调用 `base`，得到的就是指向最后一个 `0` 的普通迭代器了。

```c++
#include <iostream>
#include <list>
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    list<int> li = { 0, 1, 2, 0, 3, 4, 5, 0, 6};
    //利用反向迭代器查找最后一个0
    auto last_z = find(li.rbegin(), li.rcend(), 0);
    //将迭代器向链表头方向推进一个位置
    //转换为普通迭代器时，将回到最后一个 0 的位置
    last_z ++;
    int p = 1;
    //用 base 将 last_z 转换为普通迭代器
    //从连表头开始遍历，计数最后一个 0 的编号
    for (auto iter = li.begin(); iter != last_z.base(); iter++, p++);
    if (p >= li.size()) // 未找到 0
        cout << "容器中没有 0" << endl;
    else cout << "最后一个 0 在第" << p << "个位置" << endl;
    
    return 0;
}
```

**练习10.37：给定一个包含 10 个元素的 `vector`，将位置3到7之间的元素按逆序拷贝到一个 `list` 中。**

解答：深入理解反向迭代器和普通迭代器间的差异及相互转换。

反向迭代器和普通迭代器的转换是左闭合区间的转换。
对 10 个元素的 `vector vi`，包含位置3~7之间的元素的迭代器区间如下所示：

```cpp
0  1  2  3  4  5  6  7  8  9 
      il             i2
```

第一个迭代器是 `vi.begin()+2`，第二个迭代器指向位置8，即 `vi.begin()+7`。

当这两个迭代器转换为反向迭代器时，位置如下：

```cpp
0  1  2  3  4  5  6  7  8  9 
   re             rb
```

虽然与正向迭代器的位置不同，但左闭合区间 `[rb, re)` 仍然对应位置3~7之间的元素。显然，普通—反向迭代器间的这种错位，恰恰是因为标准库的范围概念是左闭合区间造成的。
另外注意 `back_inserter` 和流迭代器的使用。

```c++
#include <iostream>
#include <vector>
#include <list>
#include <iterator>
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    ostream_iterator<int> out_iter(cout, " ");
    vector<int> vi = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    //用流迭代器和 copy 输出 int序列
    copy(vi.begin(), vi.end(), out_iter);
    cout << endl;
    
    list<int> li;
    // 将vi[2]，也就是第3个元素的位置转换为反向迭代器
    vector<int>::reverse_iterator re(vi.begin()+2);
    // 将vi[7]，也就是第8个元素的位置转换为反向迭代器
    vector<int>::reverse_iterator rb(vi.begin()+7);
    // 用反向迭代器将元素逆序拷贝到 list
    copy(rb, re, back_inserter(li));
    copy(li.begin(), li.end(), out_iter);
    
    return 0;
}
```

## 10.5 泛型算法结构

任何算法的最基本的特性就是它要求其迭代器提供的一些操作，某些算法如 `find` 只要求通过迭代器访问元素，递增迭代器以及比较两个迭代期是否相等这些能力。其他一些算法如 `sort` 还要求读、写和随机访问元素的能力。算法所要求的迭代器操作可以分为 5 个 **迭代器类别（iterator category）**。每个算法都会对它的每个迭代器参数指明须提供哪类迭代器。

| 表10.5：       | 迭代器类别                           |
| -------------- | ------------------------------------ |
| 输入迭代器     | 只读，不写；单遍扫描，只能递增       |
| 输出迭代器     | 只写，不读；单遍扫描，只能递增       |
| 前向迭代器     | 可读写；多遍扫描，只能递增           |
| 双向迭代器     | 可读写；多遍扫描，可递增递减         |
| 随机访问迭代器 | 可读写，多遍扫描，支持全部迭代器运算 |

### 10.5.1 5类迭代器

#### 迭代器类别

**输入迭代器**（input iterator）：可以读取序列中的元素，一个输入迭代器必须支持：
- 用于比较两个迭代器的相等和不相等运算符（`==`、`!=`）
- 用于推进迭代器的前置和后置递增运算（`++`）
- 用于读取元素的结引用运算符（`*`）；解引用只会出现在赋值运算符的右侧
- 箭头运算符（`->`）等价于（`(*it).member`），即，解引用迭代器，并提取对象的成员

输入迭代器只用于顺序访问。对于一个输入迭代器，`*it++` 保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描算法。算法 `find` 和 `accumulate` 要求输入迭代器；而 `istream_iterator` 是一种输输入迭代器。

**输出迭代器**（output iterator）：可以看作输入迭代器功能上的补集——只写二不读元素。输出迭代器必须支持：
- 用于推进迭代器的前置和后置递增运算（`++`）
- 解引用运算符（`*`），只出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素）

我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如，`copy` 函数的第三个参数就是输出迭代器。 `ostream_iterator` 类型也是输出迭代器。

**前向迭代器**（forward iterator）：可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代期的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法 `replace` 要求前向迭代期，`forward_list` 上的迭代期是前向迭代期。

**双向迭代器**（bidirectional iterator）：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（`--`）。算法 `reverse` 要求双向迭代器，除了 `forward_list` 之外，其他标准库都提供符合双向迭代器要求的迭代器。

**随机访问迭代器**（random-access iterator）：提供在常量时间内访问序列中任意元素的能力。此类迭代器支持双向迭代器的所有功能，此外还支持表3.7（第99页）中的操作：

- 用于比较两个迭代器相对位置的关系运算符（`<`、`<=`、`>` 和 `>=`）
- 迭代器和一个整数值的加减运算（`+`、`+=`、`-` 和 `-=`），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置
- 用于两个迭代器上的减法运算符（`-`），得到两个迭代器的距离
- 下标运算符（`iter[n]`），与 `*(iter[n])` 等价

算法 `sort` 要求随机访问迭代器。`array`、`deque`、`string` 和 `vector` 的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。

**练习10.38：列出5个迭代期类别，以及每类迭代器所支持的操作。**

**输入迭代器**：只读，不写；单遍扫描，只能递增；还支持相等性判定运算符（`==`、`!=`）、解引用运算符（`*`）（只出现在赋值运算符右侧）和箭头运算符（`->`）。

**输出迭代器**：只写，不读；单遍扫描，只能递增，支持解引用运算符（`*`）（只出现在赋值运算符左侧）。

**前向迭代器**：可读写；多遍扫描，只能递增，支持所有输入、输出迭代器的操作。

**双向迭代器**：可读写；多遍扫描，可递增递减，支持所有前向迭代器操作。

**随机访问迭代器**：可读写，多遍扫描，支持全部迭代器运算，除了上述迭代器类别支持的操作外，还有比较两个迭代器相对位置的关系运算符（`<`、`<=`、`>` 和 `>=`）、迭代器和一个整数值的加减运算（`+`、`+=`、`-` 和 `-=`）令迭代器在序列中前进或后退给定整数个元素、两个迭代器上的减法运算符（`-`）得到其距离以及下标运算符。

**练习10.39：`list` 上的迭代器属于哪类？`vector` 呢？**

`list` 上的迭代器是双向迭代器，`vector` 上的迭代器是随机访问迭代器。

**练习10.40：你认为 `copy` 要求哪类迭代器？`reverse` 和 `unique` 呢？**

`copy` 要求前两个参数至少是输入迭代器，表示一个输入范围。它读取这个范围中的元素，写入到第三个参数表示的输出序列中，因此第三个参数至少是输出迭代器。

`reverse` 要反向处理序列，因此它要求两个参数至少是双向迭代器。

`unique` 顺序扫描元素，覆盖重复元素，因此要求两个参数至少是前向迭代器。

“至少”意味着能力更强的迭代器是可接受的。

### 10.5.2 算法形参模式

### 算法形参模式

在任何其它算法分类之上，还有一组参数规范。理解这些参数规范对学习新算法很有帮助——通过理解参数的含义，你可以将注意力集中在算法所做的操作上。大多数算法具有如下4种形式之一。

```cpp
alg(beg, end, other args);
alg(beg, end, dest, other args);
alg(beg, end, beg2, other args);
alg(beg, end, beg2, end2, other args);
```

`beg` 和 `end` 表示算法所操作的输入范围，`dest` 表示指定目的位置，`beg2`, `end2` 表示第二个范围。

#### 接受单个目标迭代器的算法

`dest` 参数是一个表示算法可以写入的目的位置的迭代器。

**WARNING**：向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。

如果 `dest` 是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已存在的元素内。更常见的情况是，`dest` 被绑定到一个插入迭代器或是一个 `ostream_iterator`。插入迭代器会将新元素添加到容器中，因而保证空间是足够的。`ostream_iterator` 会将数据写入到一个输出流，同样不管要写入多少个元素都没有问题。

#### 接受第二个输入序列的算法

**WARNING**：接受单独 `beg2` 的算法，假定从 `beg2` 开始的序列与 `beg` 和 `end` 所表示的范围至少一样大。

### 10.5.3 算法命名规范

#### 一些算法使用重载形式传递一个谓词

接受谓词参数来代替 `<` 或 `==` 运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替 `<` 或 `==`。

```cpp
unique(beg, end); // 使用 == 运算符比较元素
unique(beg, end, comp); // 使用 comp 比较元素
```

两个调用都重新整理给定序列，将相邻的重复元素删除。第一个调用使用元素类型的 `==` 运算符来检查重复元素；第二个则调用 `comp` 来确定两个元素是否相等。
由于两个版本的函数在参数个数上不相等，因此具体应该调用哪个版本不会产生歧义。

#### `_if` 版本的算法

接受一个元素值的算法，通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的 `_if` 前缀：

```cpp
find(beg, end, val);	// 查找输入范围中 val 第一次出现的位置
find_if(beg, end, pred);// 查找第一个令 pred 为真的元素
```

这两个算法都在输入范围中查找特定元素第一次出现的位置。算法 `find` 查找第一个指定值；算法 `find_if` 查找使得 `pred` 返回非零值的元素。

这两个算法提供了命名上差异的版本，而非重载版本，因为两个版本的算法都接受相同数目的参数。因此可能产生重载歧义，虽然很罕见，但为了避免任何可能的歧义，标准库选择提供不同名字的版本而不是重载。

#### 区分拷贝元素的版本和不拷贝的版本

默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如果我们所见，写到额外目的空间的算法都在名字后面附加一个 `_copy`：

```cpp
reverse(beg, end); // 反转输入范围中元素的顺序
reverse_copy(beg, end, dest); // 将元素按逆序拷贝到dest
```

一些算法同时提供 `_copy` 和 `_if` 版本。这些版本接受一个目的位置迭代器和一个谓词：

```cpp
// 从 v1 中删除奇数元素
remove_if(v1.begin(), v1.end(), 
            [](int i) { return i % 2; });
// 将偶数元素从 v1 拷贝到 V2；V1 不变
remove_copy_if(v1.begin(), v1.end(), back_inserter(v2),
              [] (int i) { return i % 2; });
```

两个算法都调用了 `lambda` （参见10.3.2节，第346页）来确定元素是否为奇数。在第一个调用中，我们从输入序列中将奇数元素删除。在第二个调用中，我们将非奇数（亦即偶数）元素从输入范围拷贝到 `v2` 中。

**练习10.41：仅根据算法和参数的名字，描述下面每个标准库算法执行什么操作：**

```cpp
replace(beg, end, old_val, new_val);
replace_if(beg, end, pred, new_val);
replace_copy(beg, end, dest, old_val, new_val);
replace_copy_if(beg, end, dest, pred, new_val);
```

解答：理解标准库算法的命名规范。

1. 将范围 `[beg, end)` 间值等于 `old_val` 的元素替换为 `new_val`。
2. 将范围 `[beg, end)` 间满足谓词 `pred`  的元素替换为 `new_val`。
3. 将范围 `[beg, end)` 间的元素拷贝到目的序列 `dest` 中，将其中值等于 `old_val` 的元素替换为 `new_val`。
4. 将范围 `[beg, end)` 间的元素拷贝到目的序列 `dest` 中，将其中满足谓词 `pred`  的元素替换为 `new_val`。

## 10.6 特定容器算法

与其他特定容器不同，链表类型 `list` 和 `forward_list` 定义了几个成员函数形式的算法，如表10.6所示。特别是，它们定义了独有的 `sort`、`merge`、`remove`、`reverse` 和 `unique`。通用版本的 `sort` 要求随机访问迭代器，因此不能用于 `list` 和 `forward_list`，因为这两个类型分别提供双向迭代器和前向迭代器。

链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速”交换“元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。

**Best Practices**：对于 `list` 和`forward_list` 应该优先使用成员函数版本的算法，而不是通用算法。

| 表10.6：                | `list` 和 `forward_list` 成员函数版本的算法                  |
| ----------------------- | ------------------------------------------------------------ |
| 这些操作都返回 `void`   |                                                              |
| `lst.merge(lst)`        | 将来自 `lst2` 的元素合并入 `lst`。`lst` 和 `lst2` 都必须是有序的。 |
| `lst.merge(lst2, comp)` | 元素将从 `lst2` 中删除。在合并之后，`lst2` 变为空。第一个版本使用 `<` 运算符；第二个版本使用给定的比较操作 |
| `lst.remove(val)`       | 调用 `erase` 删除掉与给定值相等（`==`）或令一元谓词为真的每个元素 |
| `lst.remove_if(pred)`   |                                                              |
| `lst.reverse()`         | 反转 `lst` 中元素的顺序                                      |
| `lst.sort()`            | 使用 `<` 或给定比较操作排序元素                              |
| `lst.sort(comp)`        |                                                              |
| `lst.unique()`          | 调用 `erase` 删除同一个值的连续拷贝。第一个版本使用 `==`；第二个版本使用给定的二元谓词 |
| `lst.unique(pred)`      |                                                              |

#### `splice` 成员

链表类型还定义了 `splice` 算法，其描述见表10.7。此算法是链表数据结构所特有的，因此不需要通用版本。

| 表10.7：          | `list` 和 `forward_list` 的 `splice` 成员函数的参数          |
| ----------------- | ------------------------------------------------------------ |
|                   | `lst.splice(args)` 或 `flst.splice_after(args)`              |
| `(p, lst2)`       | `p` 是一个指向 `lst` 中元素的迭代器，或一个指向 `flst` 首前位置的迭代器。函数将 `lst2` 的所有元素移动到 `lst` 中 `p` 之前的位置或是 `flst` 中 `p` 之后的位置。将元素从 `lst2` 中删除。`lst2` 的类型必须与 `lst` 或 `flst` 相同，且不能是同一个链表 |
| `(p, lst2, p2)`   | `p2` 是一个指向 `lst2` 中位置的有效的迭代器。将 `p2` 指向的元素移动到 `lst` 中，或将 `p2` 之后的元素移动到 `flst` 中。`lst2` 可以是与 `lst` 或 `flst` 相同的链表 |
| `(p, lst2, b, e)` | `b` 和 `e` 必须表示 `lst2` 中的合法范围。将给定范围中的元素从 `lst2` 移动到 `lst` 或 `flst`。`lst2`与 `lst`（或`flst`）可以是相同的链表，但 `p` 不能指向给定范围中元素 |

#### 链表特有的操作会改变容器

多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。例如，`remove` 的链表版本会删除指定的元素。`unique` 的链表版本会删除第二个和后继的重复元素。

类似的，`merge` 和 `splice` 会销毁其参数。例如，通用版本的 `merge` 将合并的序列写到一个给定的目的迭代器；两个输入序列是不变的。而链表版本的 `merge` 函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用 `merge` 的链表对象中。在 `merge` 之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。

**练习10.42：使用 `list` 代替 `vector`，重新实现10.2.3节（第343页）中的去除重复单词的程序。**

本题要使用链表专用的 `sort` 和 `unique` 算法，与泛型算法的不同点有如下两点：

1. 它们是以链表类的成员函数形式实现的，因此使用方式是在链表对象上调用它们，也并不需要迭代器参数指出处理的序列。

2. 由于是以成员函数形式实现的，是直接操作容器而非通过迭代器访问容器元素，因此这些算法具有修改容器的能力（添加、删除元素）。例如，`unique` 会调用 `erase` 直接真正删除重复元素，容器的大小会变小，而不是像泛型 `unique` 算法那样只是覆盖重复元素，并不改变容器大小。因此程序已不再需要调用 `erase`了。

```cpp
#include <iostream>
#include <fstream>
#include <list>
#include <string>
#include <algorithm>

using namespace std;

inline void output_words(list<string>& words)
{
    for (auto iter = words.begin(); iter != words.end(); iter++)
        cout << *iter << " ";
    cout << endl;
}

void elimDups(list<string>& words)
{
    output_words(words);
    
    words.sort();
    output_words(words);
    
    words.unique();
    output_words(words);
}

int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cout << "Fails to open the file! " << endl;
        exit(1);
    }
    
    list<string> words;
    string word;
    while (in >> word)
        words.push_back(word);
    
    elimpDups(words);
    return 0;
}
```
