/* 练习9.11：对 6 种创建和初始化 vector 对象的方法，每一种都给出一个实例。解释每个 vector 包含什么值。*/

(1) vector<int> ilist1;

/* 默认初始化，vector 为空 —— size 返回 0，表明容器中尚未有元素；
capacity 返回 0，意味着尚未分配存储空间。
这种初始化方式适合于元素个数和值未知，需要在程序运行中动态添加的情况。*/

(2) vector<int> ilist2(ilist);

/* ilist2 初始化为 ilist 的拷贝，ilist 必须与 ilist2 类型相同，即也是 int 的 vector 类型，ilist2 将具有与 ilist 相同的容量和元素。*/

    vector<int> ilist2_1 = ilist;   // 等价方式

(3) vector<int> ilist = {1, 2, 3.0, 4, 5, 6, 7};

/* ilist 初始化为列表中元素的拷贝，列表中的元素类型必须与 ilist 的元素类型相容，在本例中必须是与整形相容的数值类型。
对于整形，会直接拷贝其值，对于其他类型则需进行类型转换（如 3.0 转换为 3）。
这种初始化方式适合元素数量和值预先可知的情况。*/

    vector<int> ilist{1, 2, 3.0, 4, 5, 6, 7};   // 等价方式

(4) vector<int> ilist(ilist.begin() + 2, ilist.end() - 1);

/* ilist3 初始化为两个迭代器指定范围中的元素的拷贝，范围中的元素类型必须与 ilist3 的元素类型相容，在本例中 ilist3 被初始化为 {3, 4, 5, 6}。

注意，由于只要求范围中元素类型鱼待初始化的容器的元素类型相容，因此，迭代器来自于不同类型的容器是可能的，例如，用一个 double 的 list 的范围来初始化 ilist3 是可行的。

另外，由于构造函数只是读取范围中的元素并进行拷贝，因此使用普通迭代器还是 const 迭代器来指出范围并无区别。

这种初始化方法特别适合于获取一个序列的子序列。*/

(5) vector<int> ilist4(7);

/* 默认值初始化，ilist4 中将包含 7 个元素，每个元素进行缺省的值初始化，对于 int，也就是被赋值为 0，因此 ilist4 被初始化为包含 7 个 0.
当程序运行初期元素大致数量可预知，而元素的值需动态获取时，可采用这种初始化方法。*/

(6) vector<int> ilist5(7, 3);

/* 指定值初始化，ilist5 被初始化为包含 7 个值为 3 的int。*/
