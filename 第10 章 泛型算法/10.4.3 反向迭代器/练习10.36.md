**练习10.36：使用 `find` 在一个 `int` 的 `list` 中查找最后一个值为 `0` 的元素。**

解答：练习反向迭代器和算法的结合。

借助反向迭代期可以扩展算法的能力。例如，使用普通迭代器，`find` 能查找给定值，在容器中第一次出现的位置。如果要查找最后一次出现的位置，还使用普通迭代器的话，代码会很复杂。但借助反向迭代器，`find` 可以逆序遍历容器中的元素，从而 “第一次出现位置” 实际上也就是正常顺序的最后一次出现位置了。

注意：
1. 由于 `list` 是链表数据结构，元素不连续存储，其迭代器不支持算术运算。因此，程序中用一个循环来计数位置编号。
2. 由于程序技术的是正向位置编号，因此需要将 `find` 找到的反向迭代器 `last_z` 转换为普通迭代器（使用`base` 成员函数）。但要注意，反向迭代器与普通迭代器的转换是左闭合区间的转换，而非精确位置的转换。`last_z.base()` 指向的并非最后一个 `0`，而是它靠近容器尾方向的邻居。因此首先要将 `last_z` 向容器首方向推进一个位置（`++`），然后再调用 `base`，得到的就是指向最后一个 `0` 的普通迭代器了。

```c++
#include <iostream>
#include <list>
#include <algorithm>

using namespace std;

int main(int argc, char *argv[])
{
    list<int> li = { 0, 1, 2, 0, 3, 4, 5, 0, 6};
    //利用反向迭代器查找最后一个0
    auto last_z = find(li.rbegin(), li.rcend(), 0);
    //将迭代器向链表头方向推进一个位置
    //转换为普通迭代器时，将回到最后一个 0 的位置
    last_z ++;
    int p = 1;
    //用 base 将 last_z 转换为普通迭代器
    //从连表头开始遍历，计数最后一个 0 的编号
    for (auto iter = li.begin(); iter != last_z.base(); iter++, p++);
    if (p >= li.size()) // 未找到 0
        cout << "容器中没有 0" << endl;
    else cout << "最后一个 0 在第" << p << "个位置" << endl;
    
    return 0;
}
```
