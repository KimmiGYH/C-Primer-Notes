**练习12.9：解释下面代码执行的结果：**

```cpp
int *q = new int(42), *r = new int(100);
r = q;
auto q2 = make_shared<int>(42), r2 = make_shared<int>(100);
r2 = q2;
```

解答：理解直接管理内存和智能指针的差别。

这段代码非常好地展示了智能指针在管理内存上的优点。
对于普通指针部分，首先分配了两个 `int` 型对象，指针分别保存在 `p` 和 `r` 中。接下来，将指针 `q` 的值赋予了 `r`，这带来了两个非常严重的内存管理问题：

1. 首先是一个直接的内存泄漏问题，`r` 和 `q` 一样都指向 `42` 的内存地址，而 `r` 中原来保存的地址——`100` 的内存再无指针管理，变成了“孤儿内存”，从而造成内存泄漏。
2. 其次是一个“空悬指针”问题。由于 `r` 和 `q` 指向同一个动态对象，如果程序编写不当，很容易产生释放了其中一个指针，而继续使用另一个指针的问题。继续使用的指针只想的是一块已经释放的内存，是一个空悬指针，继续读写它指向的内存可能导致程序崩溃甚至系统崩溃的严重问题。

而 `shared_ptr` 则可很好地解决这些问题。
首先，分配了两个共享的对象，分别由共享指针 `p2` 和 `q2` 指向，因此它们的引用计数均为 `1`。
接下来，将 `q2` 赋予 `r2`。 赋值操作会将 `q2` 指向的对象地址赋予 `r2`，并将 `r2` 原来指向的对象的引用计数减 `1`, 将 `q2` 指向的对象的引用计数加 `1`。这样，前者的引用计数变为 `0`，其占用的内存空间会被释放，不会造成内存泄漏。而后者的引用计数变为 `2`，也不会因为 `r2` 和 `q2` 之一的销毁而释放它的内存空间，因此也不会造成空悬指针的问题。
