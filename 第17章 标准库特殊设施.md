# 第17章 标准库特殊设施

## 17.1 tuple类型

### 17.1.1 定义和初始化tuple

### 17.1.2 使用tuple返回多个值

## 17.2 BITSET类型

标准库定义了 `bitset` 类，使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合。`bitset` 类定义在头文件 `bitset` 中。

### 17.2.1 定义和初始化bitset

`bitset` 类是一个类模板，它类似 `array` 类，具有固定的大小。当我们定义一个 `bitset` 时，需要声明它包含多少个二进制位：

```cpp
bitset<32> bitvec(1U); // 32 位；低位为 1，其他位为 0
```

这条语句定义`bitvec`为一个包含 32 位的`bitset`。就像`vector`包含未命名的元素一样，`bitset`中的二进制位也是未命名的，我们通过为止访问它们。二进制位的位置是从 `0` 开始编号的。因此，`bitvec` 包含编号从 `0` 到 `31` 的 32个二进制位。编号从 `0` 开始的二进制位被称为 **低位(low-order)**，编号到 `31` 结束的二进制位被称为 **高位(high-orderer)**。

#### 表17.2：初始化 `bitset` 的方法

- `bitset<n> b;`
  
  `b` 有 `n` 位；每一位均为 `0`。此构造函数是一个 `constexpr`。

- `bitset<n> b(u);`
  
  `b` 是 `unsigned logn long` 值 `u` 的低 `n` 位的拷贝。如果 `n` 大于 `unsigned long long` 的大小，则 `b` 中超出 `unsigned long long` 的高位被置位 `0`。此构造函数是一个 `constexpr`。
  
- `bitset<n> b(s, pos, m, zero, one);`
  
  `b` 是 `string s` 从位置 `pos` 开始 `m` 个字符的拷贝。`s` 只能包含字符 zero 或 one；如果 `s` 包含任何其他字符，构造函数会抛出 `invalid_argument` 异常。字符在 `b` 中分别保存为 zero 和 one。`pos` 默认为 `0`，`m` 默认为 `string::npos`，zero 默认为 `'0'`，one 默认为 `'1'`。
  
- `bitset<n> b(cp, pos, m, zeor, one);`
  
  与上一个构造函数相同，但从 `cp` 指向的字符数组中拷贝字符。如果未提供 `m`，则 `cp` 必须指向一个 C 风格字符串。如果提供了 `m`，则从 `cp` 开始必须至少有 `m` 个 zero 或 one 字符。

#### 用 `unsigned` 值初始化 `bitset`

- 当使用一个整型值来初始化 `bitset` 时，此值将被转换为 `unsigned long long` 类型并被当做位模式来处理。`bitset` 中的二进制位将是此模式的一个副本。
- 如果 `bitset` 的大小大于一个 `unsigned long long` 中的二进制位数，则剩余的高位被置为 `0`。
- 如果 `bitset` 的大小小于一个 `unsigned long long` 中的二进制位数，则只使用给定值中的低位，超出 `bitset` 大小的 高位被丢弃。

```cpp
// bitvec1 比初始值小；初始值中的高位被丢弃
bitset<13> bitvec1(0xbeef);  
    // 原本的二进制位序列为           1011111011101111
    // 高位被丢弃后的二进制位序列         1111011101111

// bitvec2 比初始值小；它的高位被置为 0
bitset<20> bitvec2(0xbeef);
    // 原本的二进制位序列为           1011111011101111
    // 高位被置为0后的二进制位序列 00001011111011101111

// 在 64 位机器中，long long 0ULL 是 64 个 0 比特，因此 ~0ULL 是 64 个 1
bitset<128> bitvec3(~0ULL); // 0~63位为 1；63~127位为 0
```

#### 从一个 `string` 初始化 `bitset`

我们可以从一个 `string` 或一个`字符数组指针`来初始化 `bitset`。
两种情况下，字符都直接表示位模式。
当我们使用字符串表示数时，字符串中下标最小的字符对应高位，反之亦然：

```cpp
bitset<32> bitvec4("1100"); // 2、3 两位为 1，剩余两位为 0
```

如果 `string` 包含的字符数比 `bitset` 少，则 `bitset` 的高位被置为 `0`。

Note: `string` 的下标编号习惯于 `bitset` 恰好相反：`string` 中下标最大的字符（最右字符）用来初始化 `bitset` 中的低位（下标为 `0` 的二进制位）。当使用一个 `string` 初始化一个 `bitset` 时，要记住这个差别。

我们不必使用整个 `string` 来作为 `bitset` 的初始值，可以只用一个子串作为初始值；

```cpp
string str("1111111000000011001101");
bitset<32> bitvec5(str, 5, 4);      // 从 str[5] 开始的四个二进制位，1100
bitset<32> bitvec6(str, str.size() - 4); // 使用最后四个字符（字符数组指针）
```

分析：

1. `bitvec5` 用 `str` 中从 `str[5]` 开始的长度为 `4` 的子串进行初始化。与往常一样，子串的最右字符表示最低位。因此，`bitvec5` 中第 `3` 位到第 `0` 位被设置为 `1100`，剩余位被设置为 `0`。
   
2. 传递给 `bitvec6` 的初始值是一个 `string` 和一个开始位置，因此 `bitvec6` 用 `str` 中倒数第四个字符开始的子串进行初始化。`bitvec6` 中剩余二进制位被初始化为 `0`。

![从一个string初始化bitset]()



### 17.2.2 bitset操作

## 17.3 正则表达式

### 17.3.1 使用正则表达式库

### 17.3.2 匹配与Regex迭代器类型

### 17.3.3 使用子表达式

### 17.3.4 使用regex_replace

## 17.4 随机数

### 17.4.2 其他随机数分布

## bernoulli_distribution类

## 17.5 IO库再探

### 17.5.1 格式化输入与输出

### 17.5.2 未格式化的输入/输出操作

### 17.5.3 流随机访问
