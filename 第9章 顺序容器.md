<!-- TOC -->

- [第9章 顺序容器 (sequential container)](#第9章-顺序容器-sequential-container)
  - [9.1 顺序容器概述](#91-顺序容器概述)
    - [确定使用哪种顺序容器](#确定使用哪种顺序容器)
  - [9.2 容器库概览](#92-容器库概览)
    - [对容器可以保存的元素类型的限制](#对容器可以保存的元素类型的限制)
      - [表9.2：容器操作](#表92容器操作)
    - [9.2.1 迭代器](#921-迭代器)
      - [迭代器范围](#迭代器范围)
      - [使用左闭合范围蕴含的变成假定](#使用左闭合范围蕴含的变成假定)
    - [9.2.2 容器类型成员](#922-容器类型成员)
    - [9.2.3 `begin`和`end`成员](#923-begin和end成员)
    - [9.2.4 容器定义和初始化](#924-容器定义和初始化)
      - [将一个容器初始化为另一个容器的拷贝](#将一个容器初始化为另一个容器的拷贝)
      - [列表初始化](#列表初始化)
      - [与顺序容器大小相关的构造函数](#与顺序容器大小相关的构造函数)
      - [标准库`array`具有固定大小](#标准库array具有固定大小)
    - [9.2.5 赋值和swap](#925-赋值和swap)
    - [9.2.6 容器大小操作](#926-容器大小操作)
    - [9.2.7 关系运算符](#927-关系运算符)
  - [9.3 顺序容器操作](#93-顺序容器操作)
    - [9.3.1 向顺序容器添加元素](#931-向顺序容器添加元素)
    - [9.3.2 访问元素](#932-访问元素)
    - [9.3.3 删除元素](#933-删除元素)
    - [9.3.4 特殊的forward_list操作](#934-特殊的forward_list操作)
    - [9.3.5 改变容器大小](#935-改变容器大小)
    - [9.3.6 容器操作可能使迭代器失效](#936-容器操作可能使迭代器失效)
  - [9.4 vector对象是如何增长的](#94-vector对象是如何增长的)
  - [9.5 额外的string操作](#95-额外的string操作)
    - [9.5.1 构造string的其他方法](#951-构造string的其他方法)
    - [9.5.2 改变string的其他方法](#952-改变string的其他方法)
    - [9.5.3 string搜索操作](#953-string搜索操作)
    - [9.5.4 compare函数](#954-compare函数)
    - [9.5.5 数值转换](#955-数值转换)
  - [9.6 容器适配器](#96-容器适配器)

<!-- /TOC -->

# 第9章 顺序容器 (sequential container)

**顺序容器**为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。
关联容器中元素的位置由元素相关联的关键字值决定。

## 9.1 顺序容器概述

| 表9.1：        | 顺序容器类型                                                 |
| -------------- | ------------------------------------------------------------ |
| `vector`       | 可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢 |
| `deque`        | 双端队列，支持快速随机访问，在头尾位置插入 / 删除速度很快    |
| `list`         | 双向链表，只支持双向顺序访问，在`list`中任何位置进行插入 / 删除操作速度都很快 |
| `forward_list` | 单向链表，只支持单向顺序访问，在链表任何位置进行插入 / 删除操作速度都很快 |
| `array`        | 固定大小数组，支持快速随机访问，不能添加或删除元素           |
| `string`       | 与`vector`相似的容器，但专门用于保存字符，随机访问快，在尾部插入 / 删除速度快 |

`string` 和 `vector`将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。

但是，在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入或删除操作后，需要移动插入 / 删除位置之后的所有元素，来保持连续存储。而且添加一个元素有时还需要分配额外的存储空间。在这种情况下，每个元素都必须移动到新的存储空间中。

`list` 和 `forward_list` 两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。

作为代价，这两个容器不支持元素的随机访问：为了访问一个元素，我们只能遍历整个容器。而且，与`vector`、`deque`和`array`相比，这两个容器的额外内存开销也很大。

`deque` 是一个更为复杂的数据结构，与`string`和`vector`类似，`deque`支持快速的随机访问。与`string`和`vector`一样，在`deque`的中间位置添加或删除元素的代价（可能）很高。但是，在`deque`的两段添加或删除元素都是很快的，与`list`或`forward_list`添加删除元素的速度相当。

`array`对象的大小是固定的，因此，`array`不支持添加和删除元素以及改变容器大小的操作。

`forward_list`的设计目标是达到与最好的手写的单向链表数据结构相当的性能，因此`forward_list`没有`size`操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，`size`保证是一个快速的常量时间的操作。

### 确定使用哪种顺序容器

Tip: 通常，使用`vector`是最好的选择，除非你有很好的理由选择其他容器。

- 除非你有很好的理由选择其他容器，否则应使用`vector`。
- 如果你的程序又很多小的元素，且空间的额外开销很重要，则不要使用`list`或`forward_list`。
- 如果程序要求随机访问元素，应使用`vector`或`deque`。
- 如果程序要求在容器的中间插入或删除元素，应使用`list`或`forward_list`。
- 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用`deque`。
- 如果程序只有在读取输入时才需要在容器中检位置插入元素，随后需要随机访问元素，则
  - 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向`vector`追加数据，然后再调用标准库的`sort`函数来重排容器中的元素，从而避免在中间位置添加元素。
  - 如果必须在中间位置插入元素，考虑在输入阶段使用`list`，一旦输入完成，将`list`中的内容拷贝到一个`vector`中。

注意：如果不确定应该使用哪种容器，那么可以再程序中只使用`vector`和`list`公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用`vector`或`list`都很方便。

**练习9.1：对于下面的程序任务，`vector`、 `deque`和`list`哪种容器最为适合？解释你的选择的理由。如果没有哪一种容器优于其他容器，也请解释理山。**

(a)读取固定数量的单词，将它们按字典序插入到容器中。我们将在下一章中看到， 关联容器更适合这个问题。

(a)“按字典序插入到容器中”意味着进行插入排序操作，从而需要在容器内部频繁进行插入操作，`vector`在尾部之外的位置插入和删除元素很慢，`deque`在头尾之外的位置插入和删除元素很慢，而`list`在任何位置插入、删除速度都很决。
因此，这个任务选择`list`更为适合。
当然，如果不是必须边读取单词边插入到容器中， 可以使用`vector`，将读入的单词依次追加到尾部，读取完毕后，调用标准库到排序算法将单词重排为字典序。

(b)读取未知数量的单词，总是将新单词插入到末尾。删除操作在头部进行。

(b)由于需要在头、尾分别进行插入、删除操作，因此将 `vector` 排除在外，`deque` 和 `list` 都可以达到很好的性能。如果还需要频繁进行随机访问。则 `deque` 更好。

(c)从一个文件读取未知数量的整数。将这些数排序，然后将它们打印到标准输出。

(c) 由于整数占用空间很小，且快速的排序算法需频繁随机访问元素，将`list`排除在外。由于无须在头部进行插入、删除操作，因此使用`vector`即可，无须使用`deque`。

## 9.2 容器库概览

每个容器都定义在一个头文件中，文件名与类型名相同。
即，`deque`定义在头文件`deque`中，`list`定义在头文件`list`中。
容器均定义为模板类。
例如对`vector`，我们必须提供额外信息来生成特定的容器类型。
对大多数，但不是所有容器，我们还需要额外提供元素类型信息：

```cpp
list<Sales_data>    // 保存 Sales_data 对象的 list
deque<double>       // 保存 double 的 deque
```

### 对容器可以保存的元素类型的限制

顺序容器几乎可以保存任意类型的元素。

```cpp
vector<vector<string>> lines;   // vector 的 vector
// 此处 lines 是一个 vector，其元素类型是 string 的 vector
```

顺序容器构造函数的一个版本，接受容器大小参数，它使用了元素类型的默认构造函数。

但某些类没有默认构造函数，我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数：

```cpp
// 假定 noDefault 是一个没有默认构造函数的类型
vector<noDefault> v1(10, init); // 正确：提供了元素初始化器
vector<noDefault> v2(10);       // 错误：必须提供一个元素初始化器
```

#### 表9.2：容器操作

| 类型别名          |                                                        |
| ----------------- | ------------------------------------------------------ |
| `iterator`        | 此容器类型的迭代器类型                                 |
| `const_iterator`  | 可以读取元素，但不能修改元素的迭代器类型               |
| `size_type`       | 无符号整数类型，足够保存此种容器类型最大可能容器的大小 |
| `difference_type` | 带符号整数类型，足够保存两个迭代器之间的距离           |
| `value_type`      | 元素类型                                               |
| `reference`       | 元素的左值类型：与`value_type&`含义相同                |
| `const_reference` | 元素的`const`左值类型（即，`const value_type&`）       |

| 构造函数           |                                                              |
| ------------------ | ------------------------------------------------------------ |
| `C c`              | 默认构造函数，构造空容器                                     |
| `C c1(c2);`        | 构造 `c2` 的拷贝 `c1`                                        |
| `C c(b, e);`       | 构造 `c`，将迭代器 `b` 和 `e` 指定的范围内的元素拷贝到 `c`（`array`不支持） |
| `C c{a, b, c...};` | 列表初始化 `c`                                               |

| 赋值与`swap`        |                                                     |
| ------------------- | --------------------------------------------------- |
| `c1 = c2`           | 将 `c1` 中的元素替换为 `c2` 中元素                  |
| `c1 = {a, b, c...}` | 将 `c1` 中的元素替换为列表中元素（不适用于`array`） |
| `a.swap(b)`         | 交换 `a` 和 `b` 的元素                              |
| `swap(a, b)`        | 与 `a.swap(b)`等价                                  |

| 大小           |                                                    |
| -------------- | -------------------------------------------------- |
| `c.size()`     | `c` 中元素的数目（不支持 `forward_list`）          |
| `c.max_size()` | `c` 可保存的最大元素数目                           |
| `c.empty()`    | 若 `c` 中存储了元素，返回 `false`，否则返回 `true` |

| 添加 / 删除元素（不适用于 `array`） |                                    |
| ----------------------------------- | ---------------------------------- |
| `c.insert(args)`                    | 将`args`中的元素拷贝进 `c`         |
| `c.emplace(inits)`                  | 使用 `inits` 构造 `c` 中的一个元素 |
| `c.erase(args)`                     | 删除 `args`指定的元素              |
| `c.clear()`                         | 删除 `c` 中的所有元素，返回 `void` |
| 关系运算符                          |                                    |
| `==`，`!=`                          | 所有容器都支持相等（不等）运算符   |
| `<`，`<=`，`>`，`>=`                | 关系运算符（无序关联容器不支持）   |

| 获取迭代器               |                                               |
| ------------------------ | --------------------------------------------- |
| `c.begin()`, `c.end()`   | 返回指向 `c` 的首元素和尾元素之后位置的迭代器 |
| `c.cbegin()`, `c.cend()` | 返回 `const_iterator`                         |

| 反向容器的额外成员（不支持`forward_list`） |                                               |
| ------------------------------------------ | --------------------------------------------- |
| `reverse_iterator`                         | 按逆序寻址元素的迭代器                        |
| `const_reverse_iterator`                   | 不能修改元素的逆序迭代器                      |
| `c.rbegin()`, `c.rend()`                   | 返回指向 `c` 的尾元素和首元素之前位置的迭代器 |
| `c.crbegin()`, `c.crend()`                 | 返回 `const_reverse_iterator`                 |

**练习9.2：定义一个`list`对象，其元素类型是 `int` 的 `deque`。**

list<deque<int>> a;

### 9.2.1 迭代器

#### 迭代器范围

迭代器范围(iterator range)：`begin` 到 `end`(one past the last element)，它们标记了容器中元素的一个范围。

这种元素范围被称为**左闭合区间**(left-inclusive interval)，其标准数学描述为 `[begin, end)`，`end`可以与`begin`指向相同的位置。

#### 使用左闭合范围蕴含的变成假定

假定`begin`和`end`构成一个合法的迭代器范围，则

- 如果`begin`与`end`相等，则范围为空
- 如果`begin`与`end`不等，则范围至少包含一个元素，且`begin`指向该范围中的第一个元素
- 我们可以对`begin`递增若干次，使得`begin==end`

```cpp
while (begin != end)
    *begin = val;   // 正确：范围非空，因此 begin 指向一个元素
    ++begin;        // 移动迭代器，获取下一个元素
```

**练习9.3：构成迭代器范围的迭代器有何限制？**

两个迭代器`begin`和`end`必须指向同一个容器中的元素，或者是容器最后一个元素之后的位置；
而且，对`begin`反复进行递增操作，可保证到达`end`，即`end`不在`begin`之前。

**练习9.4：编写函数，接受一对指向 `vector<int>` 的迭代器和一个 `int` 值。在两个迭代器指定的范围中查找给定的值，返回一个布尔值来指出是否找到。**

```cpp
/* 练习9.4：编写函数，接受一对指向 vector<int> 的迭代器和一个 int 值。
在两个迭代器指定的范围中查找给定的值，返回一个布尔值来指出是否找到。 */

#include <iostream>
#include <vector>

using namespace std;

bool search_vec(vector<int>::iterator beg, vector<int>::iterator end, int val)
{
    for (; beg != end; beg++)   // 遍历范围
        if (*beg == val)        // 检查是否与给定值相等
            return true;
    return false;
}

int main()
{
    vector<int> ilist = {1, 2, 3, 4, 5, 6, 7};

    cout << search_vec(ilist.begin(), ilist.end(), 3) << endl;
    cout << search_vec(ilist.begin(), ilist.end(), 8) << endl;

    return 0;
}
```

**练习9.5：重写上一题的函数，返回一个迭代器指向找到的元素。注意，程序必须处理未找到给定值的情况。**

```cpp
/* 练习9.5：重写上一题的函数，返回一个迭代器指向找到的元素。
注意，程序必须处理未找到给定值的情况。*/

#include <iostream>
#include <vector>

using namespace std;

vector<int>::iterator search_vec(vector<int>::iterator beg, vector<int>::iterator end, int val)
{
    for (; beg != end; beg++)   // 遍历范围
        if (*beg == val)        // 检查是否与给定值相等
            return beg;         // 搜索成功，返回元素对应迭代器
    return end;                 // 搜索失败，返回尾后迭代器
}

int main()
{
    vector<int> ilist = {1, 2, 3, 4, 5, 6, 7};

    cout << search_vec(ilist.begin(), ilist.end(), 3) - ilist.begin() << endl;
    cout << search_vec(ilist.begin(), ilist.end(), 8) - ilist.begin() << endl;

    return 0;
}
```

**练习9.6：下面程序有何错误？你应该如何修改它？**

```cpp
list<int> lst1;
list<int>::iterator iter1 = lst1.begin(), iter2 = lst1.end();
while (iter1 < iter2) /* ...*/
```

【出题思路】
理解不同类型容器的迭代器之间的差别，更深层次的，理解数据结构的实现如何导致迭代器的差别。 

【解答】
与`vector`和`deque`不同，`list`的迭代器不支持`＜`运算，只支持递增、递减、 `==`以及`!=`运算。

原因在于这几种数据结构实现上的不同。`vector`和`deque`将元素在内存中连续保存，而`list`则是将元素以链表方式存储，因此前者可以方便地实现迭代器的大小比较（类似指针的大小比较）来体现元素的前后关系。而在`list`中，两个指针的大小关系与它们指向的元素的前后关系并不一定是吻合的，实现`<`运算将会非常困难和低效。

### 9.2.2 容器类型成员

每个容器都定义了多个**类型**，如 `size_type`、`iterator` 和 `const_iterator`。

除了已经使用过的**迭代器类型**，大多数容器还提供反向迭代器。反向迭代器就是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义也都发生了颠倒。例如，对一个反向迭代器执行`++`操作，会得到上一个元素。

类型别名，我们可以在不了解容器中元素类型的情况下使用它。如果需要元素类型，可以使用容器的`value_type`。如果需要元素类型的一个引用，可以使用`reference`或`const_reference`。

```cpp
// 为了使用这些类型，我们必须显式使用其类名：
// iter 是通过 list<string> 定义的一个迭代器类型
list<string>::iterator iter;
// count 是通过 vector<int> 定义的一个 difference_type 类型
vector<int>::difference_type count;
```

**练习9.7：为了索引 `int` 的 `vector` 中的元素，应该使用什么类型？**

【出题思路】标准库容器定义了若干类型成员，对应容器使用中可能涉及的类型，如迭代器、元素引用等。

【解答】使用迭代器类型 `vector<int>::iterator` 来索引`int`的`vector`中的元素。

**练习9.8：为了读取`string`的`list`中的元素，应该使用什么类型？如果写入`list`，又该使用什么类型？**

【解答】
为了读取`string`的`list`中的元素，应使用`list<string>::value_type`，因为`value_type`表示元素类型。

为了写入数据，需要（非常量）引用类型，因此应使用`list<string>::reference`。

### 9.2.3 `begin`和`end`成员

`begin`和`enc`有多个版本：带`r`的版本返回反向迭代器；以`c`开头的版本则返回`const`迭代器：

```cpp
list<string> a = {"Milton", "Shakespeare", "Austen"};
auto it1 = a.begin();   // list<string>::iterator
auto it2 = a.rbegin();  // list<string>::reverse_iterator
auto it3 = a.cbegin();  // list<string>::const_iterator
auto it4 = a.crbegin(); // list<string>::const_reverse_iterator
```

不以 `c` 开头的函数都是被重载过的。也就是说，实际上有两个名为`begin`的成员。
一个是`const`成员，返回容器的`const_iterator`类型。另一个是非常量成员，返回容器的`iterator`类型。`rbegin`、`en`和`rend`的情况类似。当我们对一个非常量对象调用这些成员时，得到的是返回 `iterator`的版本。只有在对一个`const`对象调用这些函数时，才会得到一个`const`版本。

```cpp
// 显式指定类型
list<string>::iterator it5 = a.begin();
list<string>::const_iterator it6 = a.begin();
// 是 iterator 还是 const_iterator 依赖于 a 的类型
auto it7 = a.begin();   // 仅当 a 是 const 时，it7 是 const_iterator
auto it8 = a.cbegin();  // it8 是 const_iterator
```

**练习9.9：`begin`和`cbegin`两个函数有什么不同？**

`cbegin` 是C++新标准引入的，用来与 `auto` 结合使用。
它返回指向容器第一个元素的 `const` 代器，可以用来只读地访问容器元素，但不能对容器元素进行修改。因此，当不需要写访问时，应该使用 `cbegin`。

`begin` 则是被重载过的，有两个版本：其中一个是 `const` 成员函数，也返回 `const` 迭代器：另一个则返回普通迭代器，可以对容器元索进行修改。

### 9.2.4 容器定义和初始化

| 表9.3：                                                 | 容器定义和初始化                                             |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| `C c`                                                   | 默认构造函数，如果`C`是一个`array`，则`c`中元素按默认方式初始化，否则`c`为空 |
| `C c1(c2)`<br />`C c1=c2`                               | `c1`初始化为`c2`的拷贝，`c1`和`c2`必须是相同类型（即，它们必须是相同的容器类型，且保存的是相同的元素类型；对于`array`类型，两者还必须具有相同大小） |
| `C c{a, b, c...}`<br />`C c={a, b, c...}`               | `c`初始化为初始化列表中元素的拷贝，列表中元素的类型必须与`c`的元素类型相容。<br />对于`array`类型，列表中元素数目必须等于或小于`array`的大小，任何遗漏的元素都进行值初始化 |
| `C c(b, e)`                                             | `c`初始化为迭代器`b`和`e`指定范围中的元素的拷贝。范围中元素的类型必须与`c`的元素类型相容。 |
| 只有顺序容器（不包括`array`）的构造函数才能接受大小参数 |                                                              |
| `C seq(n)`                                              | `seq`包含`n`个元素，这些元素进行了值初始化；此构造函数是`explicit`的 |
| `C seq(n, t)`                                           | `seq`包含`n`个初始化为值`t`的元素                            |

#### 将一个容器初始化为另一个容器的拷贝

将一个新容器创建为另一个容器的拷贝的方法有两种：

- 可以直接拷贝整个容器
- 拷贝由一个迭代器对指定的元素范围

为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。
不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。
而且，新容器和元容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。

**练习9.12：对于接受一个容器创建其拷贝的构造函数，和接受两个迭代器创建拷贝的构造函数，解释它们的不同。**

接受一个已有容器的构造函数会拷贝此容器中的所有元素，这样，初始化完成后，我们得到此容器的一个一模一样的拷贝。当我们确实需要一个**容器的完整拷贝**时，这种初始化方式非常方便。

但当我们不需要已有容器中的全部元素，而只是想拷贝其中一部分元素时，可使用接受**两个迭代器**的构造函数。传递给它要拷贝的范围的起始和尾后位置的迭代器，即可令新容器对象包含所需范围中元素的拷贝。

```cpp
// 每个容器有三个元素，用给定的初始化器进行初始化
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};

list<string> list2(authors);        // 正确：类型匹配
deque<string> authList(authors);    // 错误：容器类型不匹配
vector<string> words(articles);     // 错误：元素类型必须匹配
// 正确：可以将 const char* 元素转换为 string
forward_list<string> words(articles.begin(), articles.end());
```

Note: 当将一个容器**初始化**为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。

由于两个迭代器表示一个范围，因此可以使用这种构造函数来拷贝一个容器中的子序列。
例如，假定迭代器`it`表示`authors`中的一个元素，我们可以编写如下代码：

```cpp
// 拷贝元素，直到（但不包括）it 指向的元素
deque<string> authList(authors.begin(), it);
```

**练习9.11：对 6 种创建和初始化 vector 对象的方法，每一种都给出一个实例。解释每个 vector 包含什么值。**

```cpp
/* 练习9.11：对 6 种创建和初始化 vector 对象的方法，每一种都给出一个实例。解释每个 vector 包含什么值。*/

(1) vector<int> ilist1; // 默认初始化

(2) vector<int> ilist2(ilist); // ilist2 初始化为 ilist 的拷贝

    vector<int> ilist2_1 = ilist;   // 等价方式

(3) vector<int> ilist = {1, 2, 3.0, 4, 5, 6, 7}; // ilist 初始化为列表中元素的拷贝
    vector<int> ilist{1, 2, 3.0, 4, 5, 6, 7};   // 等价方式

(4) vector<int> ilist(ilist.begin() + 2, ilist.end() - 1);

/* ilist3 初始化为两个迭代器指定范围中的元素的拷贝，范围中的元素类型必须与 ilist3 的元素类型相容，在本例中 ilist3 被初始化为 {3, 4, 5, 6}。

注意，由于只要求范围中元素类型鱼待初始化的容器的元素类型相容，因此，迭代器来自于不同类型的容器是可能的，例如，用一个 double 的 list 的范围来初始化 ilist3 是可行的。

另外，由于构造函数只是读取范围中的元素并进行拷贝，因此使用普通迭代器还是 const 迭代器来指出范围并无区别。

这种初始化方法特别适合于获取一个序列的子序列。*/

(5) vector<int> ilist4(7); // 默认值初始化

(6) vector<int> ilist5(7, 3); // 指定值初始化
```

#### 列表初始化

我们可以对一个容器进行列表初始化：

```cpp
// 每个容器有三个元素，用给定的初始化器进行初始化
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};
```

#### 与顺序容器大小相关的构造函数

顺序容器接受一个容器大小和一个（可选的）元素初始值。
如果我们不提供元素初始值，则标准库会创建一个值初始化器：

```cpp
vector<int> ivec(10, -1);       // 10 个 int 元素，每个都初始化为 -1
list<string> svec(10, "hi!");   // 10 个 strings; 每个都初始化为 "hi!"
forward_list<int> ivec(10);     // 10 个元素，每个都初始化为 0
deque<string> svec(10);         // 10 个元素，每个都是空 string
```

Note: 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。

#### 标准库`array`具有固定大小

当定义一个`array`时，除了制定元素类型，还要指定容器大小：

```cpp
array<int, 42>      // 类型为：保存 42 个 int 的数组
array<string, 10>   // 类型为：保存 10 个 string 的数组
```

为了使用`array`类型，我们必须同时指定元素类型和大小，大小是`array`类型的一部分：

```cpp
array<int, 10>::size_type i;    // 数组类型包括元素类型和大小
array<int>::size_type j;        // 错误：array<int> 不是一个类型
```

如果元素类型是一个类类型，那么该类必须有一个默认构造函数，以使值初始化能够进行：

```cpp
array<int, 10> ia1;         // 10 个默认初始化的 int
array<int, 10> ia2 = {0,1,2,3,4,5,6,7,8,9}; // 列表初始化
array<int, 10> ia3 = {42};  // ia3[0] 为 42，剩余元素为 0
```

值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但`array`并无此限制：

```cpp
int digs[10] = {0,1,2,3,4,5,6,7,8,9};
int cpy[10] = digs;             // 错误：内置数组不支持拷贝或赋值
array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> copy = digits;   // 正确：只要数组类型匹配即合法
```

### 9.2.5 赋值和swap



### 9.2.6 容器大小操作

### 9.2.7 关系运算符

## 9.3 顺序容器操作

### 9.3.1 向顺序容器添加元素

### 9.3.2 访问元素

### 9.3.3 删除元素

### 9.3.4 特殊的forward_list操作

### 9.3.5 改变容器大小

### 9.3.6 容器操作可能使迭代器失效

## 9.4 vector对象是如何增长的

## 9.5 额外的string操作

### 9.5.1 构造string的其他方法

### 9.5.2 改变string的其他方法

### 9.5.3 string搜索操作

### 9.5.4 compare函数

### 9.5.5 数值转换

## 9.6 容器适配器
