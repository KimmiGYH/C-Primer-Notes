# 第7章 类

类的基本思想是**数据抽象**(data abstraction)和**封装**(encapsulation)。

数据抽象是一种依赖于**接口**(interface)和**实现**(implementation)分离的编程（以及设计）技术。
类的借口包括用户所能执行的操作：类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

**封装**实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。

类要想实现数据抽象和封装，需要首先定义一个**抽象数据类型**(abstract data type)。

## 7.1 定义抽象数据类型

### 7.1.1 设计Sales_data类

令`Sales_data`支持`Sales_item`类完全一样的操作集合。
`Sales_item`类有一个名为`isbn`的**成员函数**(member function)，并且支持`+`、`=`、`+=`、`<<` 和 `>>`运算符。(p20)

#### 使用改进的`Sales_data`类

(p21)使用 `Sales_item`类：

```cpp
#include <iostream>
#include "Sales_item.h"
int main()
{
    Sales_item total;   //保存下一条交易记录的变量
    // 读入第一条交易记录，并确保有书可以处理
    if (std::cin >> total) {
        Sales_item trans;   // 保存和的变量
        // 读入并处理剩余交易记录
        while (std::cin >> trans) {
            // 如果我们仍在处理相同的书
            if (total.isbn() == trans.isbn())
                total += trans; // 更新total值即总销售额
            else {
                // 打印前一天本书的结果
                std::cout << total << std::endl;
                total = trans; // total 现在表示下一本书的销售额
            }
        }
    } else {
        // 没有输入！警告读者
        std::cerr << "No data?!" << std::endl;
        return -1;  // 表示失败
    }
    return 0;
}
```

不再使用`Sales_item`对象，而是使用`Sales_data`对象：

```cpp
Sales_data total;                   // 保存当前求和结果的变量
if (read(cin, total)) {             // 读入第一笔交易
    Sales_data trans;               // 保存下一条交易数据的变量
    while(read(cin, trans)) {       // 读入剩余的交易
        if (total.isbn() == trans.isbn())   // 检查 isbn
            total.combine(trans);   // 更新变量 total 当前的值
        else {
            print(cout, total) << endl; // 输出结果
            total = trans;          // 把trans赋给total，处理下一本书
        }
    }
    print(cout, total) << endl;     // 输出最后一条交易
} else {                            // 没有输入任何信息
    cerr << "No data?!" << endl;    // 通知用户
}

/* 因为 print 返回的是它的流参数的引用，所以我们可以把 print 的返回值作为 << 运算符的左侧运算对象。通过这种方式，我们输出 print 函数的处理结果，然后转到下一行。*/
```

**练习7.1：使用2.6.1节练习定义的 Sales_data类为 1.6节的交易处理程序编写一个新版本。只要ISBN相同，就不断累积啊销量并重新计算平均售价，直至输入新的书籍为止。**

```cpp
/* 练习7.1：使用2.6.1节练习定义的 Sales_data类为 1.6节的交易处理程序编写一个新版本。

程序的思路是：只要ISBN相同，就不断累积啊销量并重新计算平均售价，直至输入新的书籍为止。*/

#include <iostream>
#include "Sales_data.h"
using namespace std;

int main()
{
    cout << "请输入交易记录(ISBN、销售量、原价、实际售价)：" << endl;
    Sales_data total;

    if (cin >> total)       // 读入第一条交易记录，并确保有数据可以处理
    {
        Sales_data trans;       // 保存和的变量
        while (cin >> trans)    // 读入并处理剩余交易记录
        {
            // 如果我们仍在处理相同的书
            if (total.isbn() == trans.isbn())
                total += trans; // 更新总销售额
            else
            {
                cout << total << endl;  // 打印前一本书的结果
                total = trans;  // total 现在表示下一本书的销售额
            }
        }
        cout << total << endl;  // 打印最后一本书的结果
    }
    else
    {
        // 没有输入！警告读者
        cerr << "No data?!" << endl;
        return -1;              // 表示失败
    }
    return 0;
}
```

### 7.1.2 定义改进的Sales_data类



### 7.1.3 定义类相关的非成员函数

### 7.1.4 构造函数

### 7.1.5 拷贝、赋值和析构

## 7.2 访问控制与封装

### 7.2.1 友元

## 7.3 类的其他特性

### 7.3.1 类成员再探

### 7.3.2 返回*this的成员函数

### 7.3.3 类类型

### 7.3.4 友元再探

## 7.4 类的作用域

### 7.4.1 名字查找与类的作用域

## 7.5 构造函数再探

### 7.5.1 构造函数初始值列表

### 7.5.2 委托构造函数

### 7.5.3 默认构造函数的作用

### 7.5.4 隐式的类类型转换

### 7.5.5 聚合类

### 7.5.6 字面值常量类

## 7.6 类的静态成员
