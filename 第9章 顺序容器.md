<!-- TOC -->

- [第9章 顺序容器 (sequential container)](#第9章-顺序容器-sequential-container)
  - [9.1 顺序容器概述](#91-顺序容器概述)
    - [确定使用哪种顺序容器](#确定使用哪种顺序容器)
  - [9.2 容器库概览](#92-容器库概览)
    - [对容器可以保存的元素类型的限制](#对容器可以保存的元素类型的限制)
      - [表9.2：容器操作](#表92容器操作)
    - [9.2.1 迭代器](#921-迭代器)
      - [迭代器范围](#迭代器范围)
      - [使用左闭合范围蕴含的变成假定](#使用左闭合范围蕴含的变成假定)
    - [9.2.2 容器类型成员](#922-容器类型成员)
    - [9.2.3 `begin`和`end`成员](#923-begin和end成员)
    - [9.2.4 容器定义和初始化](#924-容器定义和初始化)
      - [将一个容器初始化为另一个容器的拷贝](#将一个容器初始化为另一个容器的拷贝)
      - [列表初始化](#列表初始化)
      - [与顺序容器大小相关的构造函数](#与顺序容器大小相关的构造函数)
      - [标准库`array`具有固定大小](#标准库array具有固定大小)
    - [9.2.5 赋值和swap](#925-赋值和swap)
      - [使用 `assign`（仅顺序容器）](#使用-assign仅顺序容器)
      - [使用 `swap`](#使用-swap)
    - [9.2.6 容器大小操作](#926-容器大小操作)
    - [9.2.7 关系运算符](#927-关系运算符)
      - [容器的关系运算符使用元素的关系运算符完成比较](#容器的关系运算符使用元素的关系运算符完成比较)
  - [9.3 顺序容器操作](#93-顺序容器操作)
    - [9.3.1 向顺序容器添加元素](#931-向顺序容器添加元素)
      - [使用`push_back`](#使用push_back)
      - [使用`push_front`](#使用push_front)
      - [在容器中的特定位置添加元素](#在容器中的特定位置添加元素)
      - [插入范围内元素](#插入范围内元素)
      - [使用`insert`的返回值](#使用insert的返回值)
      - [使用`emplace`操作](#使用emplace操作)
    - [9.3.2 访问元素](#932-访问元素)
    - [9.3.3 删除元素](#933-删除元素)
    - [9.3.4 特殊的forward_list操作](#934-特殊的forward_list操作)
    - [9.3.5 改变容器大小](#935-改变容器大小)
    - [9.3.6 容器操作可能使迭代器失效](#936-容器操作可能使迭代器失效)
  - [9.4 vector对象是如何增长的](#94-vector对象是如何增长的)
  - [9.5 额外的string操作](#95-额外的string操作)
    - [9.5.1 构造string的其他方法](#951-构造string的其他方法)
    - [9.5.2 改变string的其他方法](#952-改变string的其他方法)
    - [9.5.3 string搜索操作](#953-string搜索操作)
    - [9.5.4 compare函数](#954-compare函数)
    - [9.5.5 数值转换](#955-数值转换)
  - [9.6 容器适配器](#96-容器适配器)

<!-- /TOC -->

# 第9章 顺序容器 (sequential container)

**顺序容器**为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。
关联容器中元素的位置由元素相关联的关键字值决定。

## 9.1 顺序容器概述

| 表9.1：        | 顺序容器类型                                                 |
| -------------- | ------------------------------------------------------------ |
| `vector`       | 可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢 |
| `deque`        | 双端队列，支持快速随机访问，在头尾位置插入 / 删除速度很快    |
| `list`         | 双向链表，只支持双向顺序访问，在`list`中任何位置进行插入 / 删除操作速度都很快 |
| `forward_list` | 单向链表，只支持单向顺序访问，在链表任何位置进行插入 / 删除操作速度都很快 |
| `array`        | 固定大小数组，支持快速随机访问，不能添加或删除元素           |
| `string`       | 与`vector`相似的容器，但专门用于保存字符，随机访问快，在尾部插入 / 删除速度快 |

`string` 和 `vector`将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。

但是，在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入或删除操作后，需要移动插入 / 删除位置之后的所有元素，来保持连续存储。而且添加一个元素有时还需要分配额外的存储空间。在这种情况下，每个元素都必须移动到新的存储空间中。

`list` 和 `forward_list` 两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。

作为代价，这两个容器不支持元素的随机访问：为了访问一个元素，我们只能遍历整个容器。而且，与`vector`、`deque`和`array`相比，这两个容器的额外内存开销也很大。

`deque` 是一个更为复杂的数据结构，与`string`和`vector`类似，`deque`支持快速的随机访问。与`string`和`vector`一样，在`deque`的中间位置添加或删除元素的代价（可能）很高。但是，在`deque`的两段添加或删除元素都是很快的，与`list`或`forward_list`添加删除元素的速度相当。

`array`对象的大小是固定的，因此，`array`不支持添加和删除元素以及改变容器大小的操作。

`forward_list`的设计目标是达到与最好的手写的单向链表数据结构相当的性能，因此`forward_list`没有`size`操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，`size`保证是一个快速的常量时间的操作。

### 确定使用哪种顺序容器

Tip: 通常，使用`vector`是最好的选择，除非你有很好的理由选择其他容器。

- 除非你有很好的理由选择其他容器，否则应使用`vector`。
- 如果你的程序又很多小的元素，且空间的额外开销很重要，则不要使用`list`或`forward_list`。
- 如果程序要求随机访问元素，应使用`vector`或`deque`。
- 如果程序要求在容器的中间插入或删除元素，应使用`list`或`forward_list`。
- 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用`deque`。
- 如果程序只有在读取输入时才需要在容器中检位置插入元素，随后需要随机访问元素，则
  - 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向`vector`追加数据，然后再调用标准库的`sort`函数来重排容器中的元素，从而避免在中间位置添加元素。
  - 如果必须在中间位置插入元素，考虑在输入阶段使用`list`，一旦输入完成，将`list`中的内容拷贝到一个`vector`中。

注意：如果不确定应该使用哪种容器，那么可以再程序中只使用`vector`和`list`公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用`vector`或`list`都很方便。

**练习9.1：对于下面的程序任务，`vector`、 `deque`和`list`哪种容器最为适合？解释你的选择的理由。如果没有哪一种容器优于其他容器，也请解释理山。**

(a)读取固定数量的单词，将它们按字典序插入到容器中。我们将在下一章中看到， 关联容器更适合这个问题。

(a)“按字典序插入到容器中”意味着进行插入排序操作，从而需要在容器内部频繁进行插入操作，`vector`在尾部之外的位置插入和删除元素很慢，`deque`在头尾之外的位置插入和删除元素很慢，而`list`在任何位置插入、删除速度都很决。
因此，这个任务选择`list`更为适合。
当然，如果不是必须边读取单词边插入到容器中， 可以使用`vector`，将读入的单词依次追加到尾部，读取完毕后，调用标准库到排序算法将单词重排为字典序。

(b)读取未知数量的单词，总是将新单词插入到末尾。删除操作在头部进行。

(b)由于需要在头、尾分别进行插入、删除操作，因此将 `vector` 排除在外，`deque` 和 `list` 都可以达到很好的性能。如果还需要频繁进行随机访问。则 `deque` 更好。

(c)从一个文件读取未知数量的整数。将这些数排序，然后将它们打印到标准输出。

(c) 由于整数占用空间很小，且快速的排序算法需频繁随机访问元素，将`list`排除在外。由于无须在头部进行插入、删除操作，因此使用`vector`即可，无须使用`deque`。

## 9.2 容器库概览

每个容器都定义在一个头文件中，文件名与类型名相同。
即，`deque`定义在头文件`deque`中，`list`定义在头文件`list`中。
容器均定义为模板类。
例如对`vector`，我们必须提供额外信息来生成特定的容器类型。
对大多数，但不是所有容器，我们还需要额外提供元素类型信息：

```cpp
list<Sales_data>    // 保存 Sales_data 对象的 list
deque<double>       // 保存 double 的 deque
```

### 对容器可以保存的元素类型的限制

顺序容器几乎可以保存任意类型的元素。

```cpp
vector<vector<string>> lines;   // vector 的 vector
// 此处 lines 是一个 vector，其元素类型是 string 的 vector
```

顺序容器构造函数的一个版本，接受容器大小参数，它使用了元素类型的默认构造函数。

但某些类没有默认构造函数，我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数：

```cpp
// 假定 noDefault 是一个没有默认构造函数的类型
vector<noDefault> v1(10, init); // 正确：提供了元素初始化器
vector<noDefault> v2(10);       // 错误：必须提供一个元素初始化器
```

#### 表9.2：容器操作

| 类型别名          |                                                        |
| ----------------- | ------------------------------------------------------ |
| `iterator`        | 此容器类型的迭代器类型                                 |
| `const_iterator`  | 可以读取元素，但不能修改元素的迭代器类型               |
| `size_type`       | 无符号整数类型，足够保存此种容器类型最大可能容器的大小 |
| `difference_type` | 带符号整数类型，足够保存两个迭代器之间的距离           |
| `value_type`      | 元素类型                                               |
| `reference`       | 元素的左值类型：与`value_type&`含义相同                |
| `const_reference` | 元素的`const`左值类型（即，`const value_type&`）       |

| 构造函数           |                                                              |
| ------------------ | ------------------------------------------------------------ |
| `C c`              | 默认构造函数，构造空容器                                     |
| `C c1(c2);`        | 构造 `c2` 的拷贝 `c1`                                        |
| `C c(b, e);`       | 构造 `c`，将迭代器 `b` 和 `e` 指定的范围内的元素拷贝到 `c`（`array`不支持） |
| `C c{a, b, c...};` | 列表初始化 `c`                                               |

| 赋值与`swap`        |                                                     |
| ------------------- | --------------------------------------------------- |
| `c1 = c2`           | 将 `c1` 中的元素替换为 `c2` 中元素                  |
| `c1 = {a, b, c...}` | 将 `c1` 中的元素替换为列表中元素（不适用于`array`） |
| `a.swap(b)`         | 交换 `a` 和 `b` 的元素                              |
| `swap(a, b)`        | 与 `a.swap(b)`等价                                  |

| 大小           |                                                    |
| -------------- | -------------------------------------------------- |
| `c.size()`     | `c` 中元素的数目（不支持 `forward_list`）          |
| `c.max_size()` | `c` 可保存的最大元素数目                           |
| `c.empty()`    | 若 `c` 中存储了元素，返回 `false`，否则返回 `true` |

| 添加 / 删除元素（不适用于 `array`） |                                    |
| ----------------------------------- | ---------------------------------- |
| `c.insert(args)`                    | 将`args`中的元素拷贝进 `c`         |
| `c.emplace(inits)`                  | 使用 `inits` 构造 `c` 中的一个元素 |
| `c.erase(args)`                     | 删除 `args`指定的元素              |
| `c.clear()`                         | 删除 `c` 中的所有元素，返回 `void` |
| 关系运算符                          |                                    |
| `==`，`!=`                          | 所有容器都支持相等（不等）运算符   |
| `<`，`<=`，`>`，`>=`                | 关系运算符（无序关联容器不支持）   |

| 获取迭代器               |                                               |
| ------------------------ | --------------------------------------------- |
| `c.begin()`, `c.end()`   | 返回指向 `c` 的首元素和尾元素之后位置的迭代器 |
| `c.cbegin()`, `c.cend()` | 返回 `const_iterator`                         |

| 反向容器的额外成员（不支持`forward_list`） |                                               |
| ------------------------------------------ | --------------------------------------------- |
| `reverse_iterator`                         | 按逆序寻址元素的迭代器                        |
| `const_reverse_iterator`                   | 不能修改元素的逆序迭代器                      |
| `c.rbegin()`, `c.rend()`                   | 返回指向 `c` 的尾元素和首元素之前位置的迭代器 |
| `c.crbegin()`, `c.crend()`                 | 返回 `const_reverse_iterator`                 |

**练习9.2：定义一个`list`对象，其元素类型是 `int` 的 `deque`。**

list<deque<int>> a;

### 9.2.1 迭代器

#### 迭代器范围

迭代器范围(iterator range)：`begin` 到 `end`(one past the last element)，它们标记了容器中元素的一个范围。

这种元素范围被称为**左闭合区间**(left-inclusive interval)，其标准数学描述为 `[begin, end)`，`end`可以与`begin`指向相同的位置。

#### 使用左闭合范围蕴含的变成假定

假定`begin`和`end`构成一个合法的迭代器范围，则

- 如果`begin`与`end`相等，则范围为空
- 如果`begin`与`end`不等，则范围至少包含一个元素，且`begin`指向该范围中的第一个元素
- 我们可以对`begin`递增若干次，使得`begin==end`

```cpp
while (begin != end)
    *begin = val;   // 正确：范围非空，因此 begin 指向一个元素
    ++begin;        // 移动迭代器，获取下一个元素
```

**练习9.3：构成迭代器范围的迭代器有何限制？**

两个迭代器`begin`和`end`必须指向同一个容器中的元素，或者是容器最后一个元素之后的位置；
而且，对`begin`反复进行递增操作，可保证到达`end`，即`end`不在`begin`之前。

**练习9.4：编写函数，接受一对指向 `vector<int>` 的迭代器和一个 `int` 值。在两个迭代器指定的范围中查找给定的值，返回一个布尔值来指出是否找到。**

```cpp
/* 练习9.4：编写函数，接受一对指向 vector<int> 的迭代器和一个 int 值。
在两个迭代器指定的范围中查找给定的值，返回一个布尔值来指出是否找到。 */

#include <iostream>
#include <vector>

using namespace std;

bool search_vec(vector<int>::iterator beg, vector<int>::iterator end, int val)
{
    for (; beg != end; beg++)   // 遍历范围
        if (*beg == val)        // 检查是否与给定值相等
            return true;
    return false;
}

int main()
{
    vector<int> ilist = {1, 2, 3, 4, 5, 6, 7};

    cout << search_vec(ilist.begin(), ilist.end(), 3) << endl;
    cout << search_vec(ilist.begin(), ilist.end(), 8) << endl;

    return 0;
}
```

**练习9.5：重写上一题的函数，返回一个迭代器指向找到的元素。注意，程序必须处理未找到给定值的情况。**

```cpp
/* 练习9.5：重写上一题的函数，返回一个迭代器指向找到的元素。
注意，程序必须处理未找到给定值的情况。*/

#include <iostream>
#include <vector>

using namespace std;

vector<int>::iterator search_vec(vector<int>::iterator beg, vector<int>::iterator end, int val)
{
    for (; beg != end; beg++)   // 遍历范围
        if (*beg == val)        // 检查是否与给定值相等
            return beg;         // 搜索成功，返回元素对应迭代器
    return end;                 // 搜索失败，返回尾后迭代器
}

int main()
{
    vector<int> ilist = {1, 2, 3, 4, 5, 6, 7};

    cout << search_vec(ilist.begin(), ilist.end(), 3) - ilist.begin() << endl;
    cout << search_vec(ilist.begin(), ilist.end(), 8) - ilist.begin() << endl;

    return 0;
}
```

**练习9.6：下面程序有何错误？你应该如何修改它？**

```cpp
list<int> lst1;
list<int>::iterator iter1 = lst1.begin(), iter2 = lst1.end();
while (iter1 < iter2) /* ...*/
```

【出题思路】
理解不同类型容器的迭代器之间的差别，更深层次的，理解数据结构的实现如何导致迭代器的差别。 

【解答】
与`vector`和`deque`不同，`list`的迭代器不支持`＜`运算，只支持递增、递减、 `==`以及`!=`运算。

原因在于这几种数据结构实现上的不同。`vector`和`deque`将元素在内存中连续保存，而`list`则是将元素以链表方式存储，因此前者可以方便地实现迭代器的大小比较（类似指针的大小比较）来体现元素的前后关系。而在`list`中，两个指针的大小关系与它们指向的元素的前后关系并不一定是吻合的，实现`<`运算将会非常困难和低效。

### 9.2.2 容器类型成员

每个容器都定义了多个**类型**，如 `size_type`、`iterator` 和 `const_iterator`。

除了已经使用过的**迭代器类型**，大多数容器还提供反向迭代器。反向迭代器就是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义也都发生了颠倒。例如，对一个反向迭代器执行`++`操作，会得到上一个元素。

类型别名，我们可以在不了解容器中元素类型的情况下使用它。如果需要元素类型，可以使用容器的`value_type`。如果需要元素类型的一个引用，可以使用`reference`或`const_reference`。

```cpp
// 为了使用这些类型，我们必须显式使用其类名：
// iter 是通过 list<string> 定义的一个迭代器类型
list<string>::iterator iter;
// count 是通过 vector<int> 定义的一个 difference_type 类型
vector<int>::difference_type count;
```

**练习9.7：为了索引 `int` 的 `vector` 中的元素，应该使用什么类型？**

【出题思路】标准库容器定义了若干类型成员，对应容器使用中可能涉及的类型，如迭代器、元素引用等。

【解答】使用迭代器类型 `vector<int>::iterator` 来索引`int`的`vector`中的元素。

**练习9.8：为了读取`string`的`list`中的元素，应该使用什么类型？如果写入`list`，又该使用什么类型？**

【解答】
为了读取`string`的`list`中的元素，应使用`list<string>::value_type`，因为`value_type`表示元素类型。

为了写入数据，需要（非常量）引用类型，因此应使用`list<string>::reference`。

### 9.2.3 `begin`和`end`成员

`begin`和`enc`有多个版本：带`r`的版本返回反向迭代器；以`c`开头的版本则返回`const`迭代器：

```cpp
list<string> a = {"Milton", "Shakespeare", "Austen"};
auto it1 = a.begin();   // list<string>::iterator
auto it2 = a.rbegin();  // list<string>::reverse_iterator
auto it3 = a.cbegin();  // list<string>::const_iterator
auto it4 = a.crbegin(); // list<string>::const_reverse_iterator
```

不以 `c` 开头的函数都是被重载过的。也就是说，实际上有两个名为`begin`的成员。
一个是`const`成员，返回容器的`const_iterator`类型。另一个是非常量成员，返回容器的`iterator`类型。`rbegin`、`en`和`rend`的情况类似。当我们对一个非常量对象调用这些成员时，得到的是返回 `iterator`的版本。只有在对一个`const`对象调用这些函数时，才会得到一个`const`版本。

```cpp
// 显式指定类型
list<string>::iterator it5 = a.begin();
list<string>::const_iterator it6 = a.begin();
// 是 iterator 还是 const_iterator 依赖于 a 的类型
auto it7 = a.begin();   // 仅当 a 是 const 时，it7 是 const_iterator
auto it8 = a.cbegin();  // it8 是 const_iterator
```

**练习9.9：`begin`和`cbegin`两个函数有什么不同？**

`cbegin` 是C++新标准引入的，用来与 `auto` 结合使用。
它返回指向容器第一个元素的 `const` 代器，可以用来只读地访问容器元素，但不能对容器元素进行修改。因此，当不需要写访问时，应该使用 `cbegin`。

`begin` 则是被重载过的，有两个版本：其中一个是 `const` 成员函数，也返回 `const` 迭代器：另一个则返回普通迭代器，可以对容器元索进行修改。

### 9.2.4 容器定义和初始化

| 表9.3：                                                 | 容器定义和初始化                                             |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| `C c`                                                   | 默认构造函数，如果`C`是一个`array`，则`c`中元素按默认方式初始化，否则`c`为空 |
| `C c1(c2)`<br />`C c1=c2`                               | `c1`初始化为`c2`的拷贝，`c1`和`c2`必须是相同类型（即，它们必须是相同的容器类型，且保存的是相同的元素类型；对于`array`类型，两者还必须具有相同大小） |
| `C c{a, b, c...}`<br />`C c={a, b, c...}`               | `c`初始化为初始化列表中元素的拷贝，列表中元素的类型必须与`c`的元素类型相容。<br />对于`array`类型，列表中元素数目必须等于或小于`array`的大小，任何遗漏的元素都进行值初始化 |
| `C c(b, e)`                                             | `c`初始化为迭代器`b`和`e`指定范围中的元素的拷贝。范围中元素的类型必须与`c`的元素类型相容。 |
| 只有顺序容器（不包括`array`）的构造函数才能接受大小参数 |                                                              |
| `C seq(n)`                                              | `seq`包含`n`个元素，这些元素进行了值初始化；此构造函数是`explicit`的 |
| `C seq(n, t)`                                           | `seq`包含`n`个初始化为值`t`的元素                            |

#### 将一个容器初始化为另一个容器的拷贝

将一个新容器创建为另一个容器的拷贝的方法有两种：

- 可以直接拷贝整个容器
- 拷贝由一个迭代器对指定的元素范围

为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。
**不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。**
**而且，新容器和元容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。**

**练习9.12：对于接受一个容器创建其拷贝的构造函数，和接受两个迭代器创建拷贝的构造函数，解释它们的不同。**

接受一个已有容器的构造函数会拷贝此容器中的所有元素，这样，初始化完成后，我们得到此容器的一个一模一样的拷贝。当我们确实需要一个**容器的完整拷贝**时，这种初始化方式非常方便。

但当我们不需要已有容器中的全部元素，而只是想拷贝其中一部分元素时，可使用接受**两个迭代器**的构造函数。传递给它要拷贝的范围的起始和尾后位置的迭代器，即可令新容器对象包含所需范围中元素的拷贝。

```cpp
// 每个容器有三个元素，用给定的初始化器进行初始化
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};

list<string> list2(authors);        // 正确：类型匹配
deque<string> authList(authors);    // 错误：容器类型不匹配
vector<string> words(articles);     // 错误：元素类型必须匹配
// 正确：可以将 const char* 元素转换为 string
forward_list<string> words(articles.begin(), articles.end());
```

Note: 当将一个容器**初始化**为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。

由于两个迭代器表示一个范围，因此可以使用这种构造函数来拷贝一个容器中的子序列。
例如，假定迭代器`it`表示`authors`中的一个元素，我们可以编写如下代码：

```cpp
// 拷贝元素，直到（但不包括）it 指向的元素
deque<string> authList(authors.begin(), it);
```

**练习9.11：对 6 种创建和初始化 vector 对象的方法，每一种都给出一个实例。解释每个 vector 包含什么值。**

```cpp
/* 练习9.11：对 6 种创建和初始化 vector 对象的方法，每一种都给出一个实例。解释每个 vector 包含什么值。*/

(1) vector<int> ilist1; // 默认初始化

(2) vector<int> ilist2(ilist); // ilist2 初始化为 ilist 的拷贝

    vector<int> ilist2_1 = ilist;   // 等价方式

(3) vector<int> ilist = {1, 2, 3.0, 4, 5, 6, 7}; // ilist 初始化为列表中元素的拷贝
    vector<int> ilist{1, 2, 3.0, 4, 5, 6, 7};   // 等价方式

(4) vector<int> ilist(ilist.begin() + 2, ilist.end() - 1);

/* ilist3 初始化为两个迭代器指定范围中的元素的拷贝，范围中的元素类型必须与 ilist3 的元素类型相容，在本例中 ilist3 被初始化为 {3, 4, 5, 6}。

注意，由于只要求范围中元素类型鱼待初始化的容器的元素类型相容，因此，迭代器来自于不同类型的容器是可能的，例如，用一个 double 的 list 的范围来初始化 ilist3 是可行的。

另外，由于构造函数只是读取范围中的元素并进行拷贝，因此使用普通迭代器还是 const 迭代器来指出范围并无区别。

这种初始化方法特别适合于获取一个序列的子序列。*/

(5) vector<int> ilist4(7); // 默认值初始化

(6) vector<int> ilist5(7, 3); // 指定值初始化
```

**练习9.13：如何从一个 `list<int>` 初始化一个 `vector<double>`？从一个 `vector<int>` 又该如何创建？编写代码验证你的答案。**

```cpp
/* 练习9.13：如何从一个 `list<int>` 初始化一个 `vector<double>`？
从一个 `vector<int>` 又该如何创建？编写代码验证你的答案。

【出题思路】更深入地理解容器拷贝初始化和范围初始化两种方式的差异。

【解答】
由于 `list<int>` 与 `vector<double>` 是不同的容器类型，因此无法采用容器拷贝初始化方式。
但前者的元素类型是 `int`，与后者的元素类型 `double` 是相容的，因此可以采用范围初始化方式来构造一个 `vector<double>`，令它的元素值与 `list<int>`完全相同。*/

#include <iostream>
#include <vector>
#include <list>

using namespace std;

int main()
{
    list<int> ilist = {1, 2, 3, 4, 5, 6, 7};
    vector<int> ivec = {7, 6, 5, 4, 3, 2, 1};

    // 容器类型不同，不能使用拷贝初始化
    // vector<double> ivec(ilist);

    /* 元素类型相容，因此可采用范围初始化 */
    vector<double> dvec(ilist.begin(), ilist.end());

    // 元素类型不同，不能使用拷贝初始化
    // vector<double> dvec1(ivec);

    /* 元素类型相容，因此可采用范围初始化 */
    vector<double> dvec1(ivec.begin(), ivec.end());

    cout << dvec.capacity() << " " << dvec.size() << " " << dvec[0] << " " << dvec[dvec.size() - 1] << endl;

    cout << dvec1.capacity() << " " << dvec1.size() << " " << dvec1[0] << " " << dvec1[dvec1.size() - 1] << endl;

    return 0;
}

/*Output:
7 7 1 7
7 7 7 1
*/
```

#### 列表初始化

我们可以对一个容器进行列表初始化：

```cpp
// 每个容器有三个元素，用给定的初始化器进行初始化
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};
```

#### 与顺序容器大小相关的构造函数

顺序容器接受一个容器大小和一个（可选的）元素初始值。
如果我们不提供元素初始值，则标准库会创建一个值初始化器：

```cpp
vector<int> ivec(10, -1);       // 10 个 int 元素，每个都初始化为 -1
list<string> svec(10, "hi!");   // 10 个 strings; 每个都初始化为 "hi!"
forward_list<int> ivec(10);     // 10 个元素，每个都初始化为 0
deque<string> svec(10);         // 10 个元素，每个都是空 string
```

Note: 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。

#### 标准库`array`具有固定大小

当定义一个`array`时，除了制定元素类型，还要指定容器大小：

```cpp
array<int, 42>      // 类型为：保存 42 个 int 的数组
array<string, 10>   // 类型为：保存 10 个 string 的数组
```

为了使用`array`类型，我们必须同时指定元素类型和大小，大小是`array`类型的一部分：

```cpp
array<int, 10>::size_type i;    // 数组类型包括元素类型和大小
array<int>::size_type j;        // 错误：array<int> 不是一个类型
```

如果元素类型是一个类类型，那么该类必须有一个默认构造函数，以使值初始化能够进行：

```cpp
array<int, 10> ia1;         // 10 个默认初始化的 int
array<int, 10> ia2 = {0,1,2,3,4,5,6,7,8,9}; // 列表初始化
array<int, 10> ia3 = {42};  // ia3[0] 为 42，剩余元素为 0
```

值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但`array`并无此限制：

```cpp
int digs[10] = {0,1,2,3,4,5,6,7,8,9};
int cpy[10] = digs;             // 错误：内置数组不支持拷贝或赋值
array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> copy = digits;   // 正确：只要数组类型匹配即合法
```

### 9.2.5 赋值和swap

与内置数组不同，标准库`array`类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型：

```cpp
array<int, 10> a1 = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> a2 = {0};    // 所有元素值均为 0
a1 = a2;    // 替换 a1 中的元素
a2 = {0};   // 错误：不能讲一个花括号列表赋予数组
```

由于右边运算对象的大小可能与左边运算对象的大小不同，因此`array`类型不支持`assign`，也不允许用花括号包围的值列表进行复制。

| 表9.4：                               | 容器赋值运算                                                 |
| ------------------------------------- | ------------------------------------------------------------ |
| `c1=c2`                               | 将`c1`中的元素替换为`c2`中元素的拷贝，`c1`和`c2`必须具有相同的类型 |
| `c={a,b,c...}`                        | 将`c1`中元素替换为初始化列表中元素的拷贝（`array`不适用）    |
| `swap(c1,c2)`                         | 交换`c1`和`c2`中的元素，`c1`和`c2`必须具有相同的类型         |
| `c1.swap(c2)`                         | `swap`通常比从`c2`向`c1`拷贝元素快得多                       |
| `assign`操作不适用于关联容器和`array` |                                                              |
| `seq.assign(b,e)`                     | 将`seq`中的元素替换为迭代器`b`和`e`所表示的范围中的元素，迭代器`b`和`e`不能指向`seq`中的元素 |
| `seq.assign(il)`                      | 将`seq`中的元素替换为初始化列表`il`中的元素                  |
| `seq.assign(n, t)`                    | 将`seq`中的元素替换为`n`个值为`t`的元素                      |

**WARNING**: 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而`swap`操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效（容器类型为`array`和`string`的情况除外）。

#### 使用 `assign`（仅顺序容器）

我们可以用`assign`实现将一个`vector`中的一段`char*`值赋予一个`list`中的`string`：

```cpp
list<string> names;
vector<const char*> oldstyle;
names = oldstyle;   // 错误：容器类型不匹配
// 正确：可以将 const char* 转换为 string
names.assign(oldstyle.cbegin(), oldstyle.cend());
```

这段代码中对`assign`的调用将`names`中的元素替换为迭代器指定的范围中的元素的拷贝。`assign`的参数决定了容器中将有多少个元素以及它们的值都是什么。

`assign`的第二个版本，用指定书目且具有相同给定值的元素替换容器中原有的元素：

```cpp
// 等价于 slist1.clear();
// 后跟 slist1.insert(slist1.begin(), 10, "Hiya!");
list<string> slist1(1);     // 1 个元素，为空 string
slist1.assign(10, "Hiya!"); // 10 个元素，每个都是 "Hiya!"
```

**练习9.14：编写程序，将一个`list`中的`char*`指针（指向C风格字符串）元素赋值给一个`vector`中的`string`。**

```cpp
/* 练习9.14：编写程序，将一个`list`中的`char*`指针（指向C风格字符串）元素赋值给一个`vector`中的`string`。

【出题思路】
容器有多种赋值操作，本题帮助读者理解不同赋值方式的差异。

【解答】
由于 list<char*> 与 vector<string> 是不同类型的容器，因此无法采用赋值运算符 `=` 来进行元素赋值。
但 char* 可以转换为 string，因此可以采用范围赋值方式来实现本题要求。*/

#include <iostream>
#include <vector>
#include <list>

using namespace std;

int main()
{
    list<char *> slist = {"hello", "world", "!"};
    vector<string> svec;

    // 容器类型不同，不能直接赋值
    // svec = slist;

    /*元素类型相容，可以采用范围赋值*/
    svec.assign(slist.begin(), slist.end());

    cout << svec.capacity() << " " << svec.size() << " " << svec[0] << " " << svec[svec.size()-1] << endl;

    return 0;
}

// Output: 3 3 hello !
```

#### 使用 `swap`

```cpp
vector<string> svec1(10);   // 10 个元素的 vector
vector<string> svec2(24);   // 24 个元素的 vector
swap(svec1, svec2);
```

调用`swap`后，`svec1`将包含`24`个`string`元素，`svec2`将包含`10`个`string`。除`array`外，交换两个容器内容的操作保证会很快——元素本身并未交换 / 元素不会被移动，`swap`只是交换了两个容器的内部数据结构。

Note: 除`array`外，`swap`不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。

元素不会被移动的事实意味着，除`string`外，指向容器的迭代器、引用和指针在`swap`操作之后都不会失效。

对一个`string`调用`swap`会导致迭代器、引用和指针失效。

`swap`两个`array`会真正交换它们的元素。因此，交换两个`array`所需的时间与`array`中元素的数目成正比。

因此，对于`array`，在`swap`操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素已经与另一个`array`中对应元素的值进行了交换。

### 9.2.6 容器大小操作

- 成员函数`size`返回容器中元素的数目；
- `empty`当`size`为`0`时返回布尔值`true`，否则返回`false`；
- `max_size`返回一个大于或等于该类型容器所能容纳的最大元素数的值。
- `forward_list`支持`max_size`和`empty`，但不支持`size`。

### 9.2.7 关系运算符

每个容器类型都支持相等运算符（`==`和`!=`）；
除了无序关联容器外的所有容器都支持关系运算符（`>`、`>=`、`<`、`<=`）。

#### 容器的关系运算符使用元素的关系运算符完成比较

Note: 只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。

如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算。
例如，我们在第7章中定义的`Sales_data`类型并未定义`==`和`<`运算。因此，就不能比较两个保存`Sales_data`元素的容器：

```cpp
vector<Sales_data> storeA, storeB;
if (storeA < storeB)    // 错误：Sales_data 没有 < 运算符
```

**练习9.17：假定`c1`和`c2`是两个容器，下面的比较操作有何限制（如果有的话）？**
`if (c1 < c2)`

【解答】
首先，容器类型必须相同，元素类型也必须相同。
其次，元素类型必须支持 `<` 运算符。

**练习9.16：重写上一题的程序，比较一个 `list<int>` 中的元素和一个`vector<int>`中的元素。**

```cpp
/* 练习9.16：重写上一题的程序，比较一个 list<int> 中的元素和一个 vector<int> 中的元素。*/

/* 练习9.15：编写程序，判定两个 vector<int> 是否相等。

【解答】标准库容器支持关系运算符，比较两个 vector 是否相等使用 == 运算符即可。
当两个vector包含相同个数的元素，且对位元素都相等时，判定两个 vector 相等，否则不等。
两个 vector 的 capacity 不会影响相等性判定，因此，当下面程序中 ivec1 在添加、删除元素导致扩容后，仍然与 ivec 相等。*/

#include <iostream>
#include <vector>
#include <list>

using namespace std;

bool l_v_equal(vector<int> &ivec, list<int> &ilist) {
    // 比较 list 和 vector 元素个数
    if (ilist.size() != ivec.size())
        return false;

    auto lb = ilist.cbegin();       // list 首元素
    auto le = ilist.cend();         // list 尾后位置
    auto vb = ivec.cbegin();        // vector 首元素
    for ( ; lb != le; lb++, vb++)
        if (*lb != *vb)             // 元素不等，容器不等
            return false;
    return true;                    // 容器相等
}

int main()
{
    vector<int> ivec = {1, 2, 3, 4, 5, 6, 7};
    list<int> ilist = {1, 2, 3, 4, 5, 6, 7};
    list<int> ilist1 = {1, 2, 3, 4, 5};
    list<int> ilist2 = {1, 2, 3, 4, 5, 6, 8};
    list<int> ilist3 = {1, 2, 3, 4, 5, 7, 6};

    cout << l_v_equal(ivec, ilist) << endl;
    cout << l_v_equal(ivec, ilist1) << endl;
    cout << l_v_equal(ivec, ilist2) << endl;
    cout << l_v_equal(ivec, ilist3) << endl;

    return 0;
}
```

## 9.3 顺序容器操作

### 9.3.1 向顺序容器添加元素

| 表9.5：                                        | 向顺序容器添加元素的操作                                     |
| ---------------------------------------------- | ------------------------------------------------------------ |
|                                                | 这些操作会改变容器的大小；`array`不支持这些操作。            |
|                                                | `forward_list`有自己专有版本的`insert`和`emplace`；          |
|                                                | `forward_list`不支持`push_back`和`emplace_back`。            |
|                                                | `vector`和`string`不支持`push_front`和`emplace_front`。      |
| `c.push_back(t)`<br />`c.emplace_back(args)`   | 在`c`的尾部创建一个值为`t`或由`args`创建的元素，返回`void`   |
| `c.push_front(t)`<br />`c.emplace_front(args)` | 在`c`的头部创建一个值为`t`或由`args`创建的元素，返回`void`   |
| `c.insert(p, t)`<br />`c.emplace(p, args)`     | 在迭代器`p`指向的元素之前创建一个值为`t`或由`args`创建的元素。返回指向新添加的元素的迭代器 |
| `c.insert(p, n, t)`                            | 在迭代器`p`指向的元素之前插入`n`个值为`t`的元素。返回指向新添加的第一个元素的迭代器；若`n`为`0`，则返回`p` |
| `c.insert(p, b, e)`                            | 将迭代器`b`和`e`指定的范围内的元素插入到迭代器`p`指向的元素之前。`b`和`e`不能指向`c`中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，则返回`p` |
| `c.insert(p, il)`                              | `il`是一个花括号包围的元素值列表。将这些给定值插入到迭代器`p`指向的元素之前。返回指向新添加的第一个元素的迭代器；若列表为空，则返回`p` |

WARNING: 向一个`vector`、`string`或`deque`插入元素会使所有指向容器的迭代器、引用和指针失效。

在一个`vector`或`string`的尾部之外的任何位置，或是一个`deque`的首尾之外的任何位置添加元素，都需要移动元素。
而且，向一个`vector`或`string`添加元素可能引起整个对象存储空间的重新分配。
重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间中。

#### 使用`push_back`

除`array`和`forward_list`之外，每个顺序容器（包括`string`类型）都支持`push_back`。

```cpp
// 从标准输入读取数据，将每个单词放到容器末尾
string word;
while (cin >> word)
    container.push_back(word);
```

`container`的类型可以是`list`、`vector`或`deque`。

由于`string`是一个字符容器，我们也可以用`push_back`在`string`末尾添加字符：

```cpp
void pluralize (size_t cnt, string &word)
{
    if (cnt > 1)
        word.push_back('s');    // 等价于 word += 's'
}
```

**练习9.20：编写程序，从一个 `list<int>` 拷贝元素到两个 `deque` 中。值为偶数的所有元素都拷贝到一个 `deque` 中，而奇数值元素都拷贝到另一个 `deque` 中。**

```cpp
/* 练习9.20：编写程序，从一个 `list<int>` 拷贝元素到两个 `deque` 中。
值为偶数的所有元素都拷贝到一个 `deque` 中，而奇数值元素都拷贝到另一个 `deque` 中。

【出题思路】练习多个容器间数据的处理、拷贝。*/

#include <iostream>
#include <list>
#include <deque>

using namespace std;

int main()
{
    list<int> ilist = {1, 2, 3, 4, 5, 6, 7, 8}; // 初始化整数 list
    deque<int> odd_d, even_d;

    // 遍历整数 list
    for (auto iter = ilist.cbegin(); iter != ilist.cend(); iter++)
        if (*iter & 1)      // 查看最低位，1：奇数， 0：偶数
            odd_d.push_back(*iter);
        else even_d.push_back(*iter);

    cout << "The odd numbers are: ";
    for (auto iter = odd_d.cbegin(); iter != odd_d.cend(); iter++)
        cout << *iter << " ";
    cout << endl;

    cout << "The even numbers are: ";
    for (auto iter = even_d.cbegin(); iter != even_d.cend(); iter++)
        cout << *iter << " ";
    cout << endl;

    return 0;
}

/*Output:
The odd numbers are: 1 3 5 7
The even numbers are: 2 4 6 8

【其他解题思路】对于奇偶性判定，可用模2运算“%2”代替位与运算，两者是等价的。*/
```

**关键概念：容器元素是拷贝：**

当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。
就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。
随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。

#### 使用`push_front`

`list`、`forward_list`和`deque`还支持`push_front`的类似操作，将元素插入到容器头部：

```cpp
list<int> ilist;
// 将元素添加到 ilist 开头
for (size_t ix = 0; ix != 4; ++ix)
    ilist.push_front(ix);
```

此循环将元素0、1、2、3添加到`ilist`头部。在循环执行完毕后，`ilist`保存序列3、2、1、0。

**练习9.18：编写程序，从标准输入读取 `string` 序列，存入一个 `deque` 中。编写一个循环，用迭代器打印 `deque` 中的元素。**

```cpp
/* 练习9.18：编写程序，从标准输入读取 `string` 序列，存入一个 `deque` 中。编写一个循环，用迭代器打印 `deque` 中的元素。

【解答】对 `deque` 来说，在首尾位置添加新元素性能最佳，在中间位置插入新元素性能会很差。对遍历操作，可高效完成。*/

#include <iostream>
#include <deque>

using namespace std;

int main()
{
    deque<string> sd;   // string 的 deque

    string word;
    while (cin >> word) // 读取字符串，直至遇到文件结束符
        sd.push_back(word);

    // 用 cbegin() 获取 deque 首元素迭代器，遍历 deque 中所有元素
    for (auto si = sd.cbegin(); si != sd.cend(); si++)
        cout << *si << endl;

    return 0;
}

/*【其他解题思路】
由于在 `deque` 的首尾位置添加新元素性能很好，因此可以用 `push_front` 替换 `push_back`，性能不变，但元素在 `deque` 中的顺序将与输入顺序相反。
若需保持相同顺序，应使用 `push_back`。*/
```

#### 在容器中的特定位置添加元素

`vector`、`deque`、`list`和`string`都支持`insert`成员。

`insert`函数将元素插入到迭代器所指定的位置之前：

```cpp
slist.insert(iter, "Hello!");   // 将 "Hello!" 添加到 iter 之前的位置
// 将一个值为"Hello"的string插入到iter指向的元素之前的位置
```

虽然某些容器不支持`push_front`，但它们对于`insert`操作并无类似的限制（插入开始位置）。因此，我们可以将元素插入到容器的开始位置，而不必担心容器是否支持`push_front`：

```cpp
vector<string> svec;
list<string> slist;

// 等价于调用 slist.push_front("Hello!");
slist.insert(slist.begin(), "Hello!");

// vector 不支持 push_front，但我们可以插入到 begin() 之前
// 警告：插入到 vector 末尾之外的任何位置都可能很慢
svec.insert(svec.begin(), "Hello!");
```

WARNING: 将元素插入到`vector`、`deque`和`string`中的任何位置都是合法的。然而，这样做可能很耗时。

#### 插入范围内元素

接受一对迭代器或一个初始化列表的 insert 版本将给定范围中的元素插入到指定位置之前：

```cpp
// 接受一对迭代器或一个初始化列表的 insert 版本将给定范围中的元素插入到指定位置之前：
vector<string> v = {"quasi", "simba", "frollo", "scar"};
// 将 v 的最后两个元素添加到 slist 的开始位置
slist.insert(slist.begin(), v.end() - 2, v.end());
slist.insert(slist.end(), {"these", "words", "will", "go", "at", "the", "end"});
```

如果我们传递给`insert`一对迭代器，它们不能指向添加元素的目标容器：

```cpp
// 运行时错误：迭代器表示要拷贝的范围，不能指向与目的位置相同的容器
slist.insert(slist.begin(), slist.begin(), slist.end());
```

#### 使用`insert`的返回值

通过使用`insert`的返回值，可以再容器中一个特定位置反复插入元素：

```cpp
list<string> lst;
auto iter = lst.begin();
while (cin >> word)
    iter = lst.insert(iter, word);  // 等价于调用 push_front
```

**练习：假定`iv`是一个`int`的`vector`，下面的程序存在什么错误？你将如何修改？**

```cpp
vector<int>::iterator iter = iv.begin(),
                       mid = iv.begin() + iv.size()/2;
while (iter != mid)
    if (*iter == some_val)
        iv.insert(iter, 2 * some_val);
```

【出题思路】
首先，理解容器插入操作的副作用 —— 向一个`vector`、 `string`或`deque`插入元素会使现有指向容器的迭代器、引用和指针失效。
其次，练习如何利用`insert`返回的迭代器，使得在向容器插入元素后，仍能正确在容器中进行遍历。

【解答】
循环中未对`iter`进行递增操作，`iter`无法向中点推进。其次，即使加入了`iter++`语句，由于向`iv`插入元素后，`iter`己经失效，`iter++`也不能起到将迭代器向前推进一个元素的作用。修改方法如下：

首先，将`insert`返回的迭代器赋予`iter`，这样，`iter`将指向新插入的元素`y`。我们知道，`insert`将`y`插入到`iter`原来指向的元素`x`之前的位置，因此，接下来我们需要进行两次`iter++`才能将`iter`推进到`x`之后的位置。

其次，`insert()`也会使`mid`失效，因此，只正确设置`iter`仍不能令循环在正确的时候结束，我们还需设置`mid`使之指向`iv`原来的中央元素。在未插入任何新元素之前，此位置是`iv.begin() + iv.size()/2`，我们将此时的`iv.size()`的值记录在变量`org_size`中。然后在循环过程中统计新插入的元素的个数`new_ele`，则在任何时候，`iv.begin() + org_size/2 + new_ele` 都能正确指向 `iv` 原来的中央元素。

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    vector<int> iv = {1, 1, 2, 1};  // int 的 vector
    int some_val = 1;

    vector<int>::iterator iter = iv.begin();
    int org_size = iv.size(), new_ele = 0;  // 原大小和新元素个数

    // 每个循环步都重新计算 "mid"，保证正确指向 iv 原中央元素
    while (iter != (iv.begin() + org_size / 2 + new_ele))
        if (*iter == some_val) {
            iter = iv.insert(iter, 2 * some_val);
            new_ele++;
            iter++; iter++; // 将 iter 推进到旧元素的下一个位置
        } else iter++;      // 简单推进 iter

    // 用 begin() 获取 vector 首元素迭代器，遍历 vector 中的所有元素
    for (iter iv.begin(); iter != iv.end(); iter++)
        cout << *iter << endl;

    return 0;
}
```

#### 使用`emplace`操作

当我们调用`emplace`成员函数时，是将参数传递给元素类型的构造函数。
`emplace`成员使用这些参数在容器管理的内存空间中直接构造元素。

例如：假定`c`保存`Sales_data`元素：

```cpp
// 在 c 的末尾构造一个 Sales_data 对象
// 使用三个参数的 Sales_data 构造函数
c.emplace_back("978-0590353403", 25, 15.99);
// 错误：没有接受三个参数的 push_back 版本
c.push_back("978-0590353403", 25, 15.99);
// 正确：创建一个临时的 Sales_data 对象传递给 push_back
c.push_back(Sales_data("978-0590353403", 25, 15.99));
```

在调用`emplace_back`时，会在容器管理的内存空间中直接创建对象。而调用`push_back`则会创建一个局部临时对象，并将其压入容器中。

`emplace`函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配：

```cpp
// iter 指向 c 中一个元素，其中保存了 Sales_data 元素
c.emplace_back();   // 使用 Sales_data 的默认构造函数
c.emplace(iter, "999-999999999");   // 使用 Sales_data(string)
// 使用 Sales_data 的接受一个 ISBN、一个 count 和一个 price 的构造函数
c.emplace_front("978-0590353403", 25, 15.99");
```

Note: `emplace`函数在容器中直接构造元素。传递给`emplace`函数的参数必须与元素类型的构造函数相匹配。

### 9.3.2 访问元素

### 9.3.3 删除元素

### 9.3.4 特殊的forward_list操作

### 9.3.5 改变容器大小

### 9.3.6 容器操作可能使迭代器失效

## 9.4 vector对象是如何增长的

## 9.5 额外的string操作

### 9.5.1 构造string的其他方法

### 9.5.2 改变string的其他方法

### 9.5.3 string搜索操作

### 9.5.4 compare函数

### 9.5.5 数值转换

## 9.6 容器适配器
