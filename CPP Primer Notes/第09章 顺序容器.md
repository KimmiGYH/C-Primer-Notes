<!-- TOC -->

- [第9章 顺序容器 (sequential container)](#第9章-顺序容器-sequential-container)
  - [9.1 顺序容器概述](#91-顺序容器概述)
    - [确定使用哪种顺序容器](#确定使用哪种顺序容器)
  - [9.2 容器库概览](#92-容器库概览)
    - [对容器可以保存的元素类型的限制](#对容器可以保存的元素类型的限制)
      - [表9.2：容器操作](#表92容器操作)
    - [9.2.1 迭代器](#921-迭代器)
      - [迭代器范围](#迭代器范围)
      - [使用左闭合范围蕴含的变成假定](#使用左闭合范围蕴含的变成假定)
    - [9.2.2 容器类型成员](#922-容器类型成员)
    - [9.2.3 `begin`和`end`成员](#923-begin和end成员)
    - [9.2.4 容器定义和初始化](#924-容器定义和初始化)
      - [将一个容器初始化为另一个容器的拷贝](#将一个容器初始化为另一个容器的拷贝)
      - [列表初始化](#列表初始化)
      - [与顺序容器大小相关的构造函数](#与顺序容器大小相关的构造函数)
      - [标准库`array`具有固定大小](#标准库array具有固定大小)
    - [9.2.5 赋值和swap](#925-赋值和swap)
      - [使用 `assign`（仅顺序容器）](#使用-assign仅顺序容器)
      - [使用 `swap`](#使用-swap)
    - [9.2.6 容器大小操作](#926-容器大小操作)
    - [9.2.7 关系运算符](#927-关系运算符)
      - [容器的关系运算符使用元素的关系运算符完成比较](#容器的关系运算符使用元素的关系运算符完成比较)
  - [9.3 顺序容器操作](#93-顺序容器操作)
    - [9.3.1 向顺序容器添加元素](#931-向顺序容器添加元素)
      - [使用`push_back`](#使用push_back)
      - [使用`push_front`](#使用push_front)
      - [在容器中的特定位置添加元素](#在容器中的特定位置添加元素)
      - [插入范围内元素](#插入范围内元素)
      - [使用`insert`的返回值](#使用insert的返回值)
      - [使用`emplace`操作](#使用emplace操作)
    - [9.3.2 访问元素](#932-访问元素)
      - [访问成员函数返回的是引用](#访问成员函数返回的是引用)
      - [下标操作和安全的随机访问](#下标操作和安全的随机访问)
    - [9.3.3 删除元素](#933-删除元素)
      - [`pop_front`和`pop_back`成员函数](#pop_front和pop_back成员函数)
      - [从容器内部删除一个元素](#从容器内部删除一个元素)
      - [删除多个元素](#删除多个元素)
    - [9.3.4 特殊的`forward_list`操作](#934-特殊的forward_list操作)
    - [9.3.5 改变容器大小](#935-改变容器大小)
    - [9.3.6 容器操作可能使迭代器失效](#936-容器操作可能使迭代器失效)
      - [编写改变容器的循环程序](#编写改变容器的循环程序)
      - [不要保存`end`返回的迭代器](#不要保存end返回的迭代器)
  - [9.4 vector对象是如何增长的 (倍增)](#94-vector对象是如何增长的-倍增)
    - [管理容量的成员函数](#管理容量的成员函数)
    - [`capacity`和`size`](#capacity和size)
  - [9.5 额外的string操作](#95-额外的string操作)
    - [9.5.1 构造string的其他方法](#951-构造string的其他方法)
      - [`substr`操作](#substr操作)
    - [9.5.2 改变string的其他方法](#952-改变string的其他方法)
      - [`append`和`replace`函数](#append和replace函数)
      - [改变`string`的多种重载函数](#改变string的多种重载函数)
    - [9.5.3 `string` 搜索操作](#953-string-搜索操作)
      - [指定在哪里开始搜索](#指定在哪里开始搜索)
      - [逆向搜素 `rfind`](#逆向搜素-rfind)
    - [9.5.4 compare函数](#954-compare函数)
    - [9.5.5 数值转换](#955-数值转换)
  - [9.6 容器适配器 (adapter)](#96-容器适配器-adapter)
    - [定义一个适配器](#定义一个适配器)
    - [栈适配器](#栈适配器)
    - [队列适配器](#队列适配器)

<!-- /TOC -->

# 第9章 顺序容器 (sequential container)

**顺序容器**为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。
关联容器中元素的位置由元素相关联的关键字值决定。

## 9.1 顺序容器概述

| 表9.1：        | 顺序容器类型                                                 |
| -------------- | ------------------------------------------------------------ |
| `vector`       | 可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢 |
| `deque`        | 双端队列，支持快速随机访问，在头尾位置插入 / 删除速度很快    |
| `list`         | 双向链表，只支持双向顺序访问，在`list`中任何位置进行插入 / 删除操作速度都很快 |
| `forward_list` | 单向链表，只支持单向顺序访问，在链表任何位置进行插入 / 删除操作速度都很快 |
| `array`        | 固定大小数组，支持快速随机访问，不能添加或删除元素           |
| `string`       | 与`vector`相似的容器，但专门用于保存字符，随机访问快，在尾部插入 / 删除速度快 |

`string` 和 `vector`将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。

但是，在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入或删除操作后，需要移动插入 / 删除位置之后的所有元素，来保持连续存储。而且添加一个元素有时还需要分配额外的存储空间。在这种情况下，每个元素都必须移动到新的存储空间中。

`list` 和 `forward_list` 两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。

作为代价，这两个容器不支持元素的随机访问：为了访问一个元素，我们只能遍历整个容器。而且，与`vector`、`deque`和`array`相比，这两个容器的额外内存开销也很大。

`deque` 是一个更为复杂的数据结构，与`string`和`vector`类似，`deque`支持快速的随机访问。与`string`和`vector`一样，在`deque`的中间位置添加或删除元素的代价（可能）很高。但是，在`deque`的两段添加或删除元素都是很快的，与`list`或`forward_list`添加删除元素的速度相当。

`array`对象的大小是固定的，因此，`array`不支持添加和删除元素以及改变容器大小的操作。

`forward_list`的设计目标是达到与最好的手写的单向链表数据结构相当的性能，因此`forward_list`没有`size`操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，`size`保证是一个快速的常量时间的操作。

### 确定使用哪种顺序容器

Tip: 通常，使用`vector`是最好的选择，除非你有很好的理由选择其他容器。

- 除非你有很好的理由选择其他容器，否则应使用`vector`。
- 如果你的程序又很多小的元素，且空间的额外开销很重要，则不要使用`list`或`forward_list`。
- 如果程序要求随机访问元素，应使用`vector`或`deque`。
- 如果程序要求在容器的中间插入或删除元素，应使用`list`或`forward_list`。
- 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用`deque`。
- 如果程序只有在读取输入时才需要在容器中检位置插入元素，随后需要随机访问元素，则
  - 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向`vector`追加数据，然后再调用标准库的`sort`函数来重排容器中的元素，从而避免在中间位置添加元素。
  - 如果必须在中间位置插入元素，考虑在输入阶段使用`list`，一旦输入完成，将`list`中的内容拷贝到一个`vector`中。

注意：如果不确定应该使用哪种容器，那么可以再程序中只使用`vector`和`list`公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用`vector`或`list`都很方便。

**练习9.1：对于下面的程序任务，`vector`、 `deque`和`list`哪种容器最为适合？解释你的选择的理由。如果没有哪一种容器优于其他容器，也请解释理由。**

(a)读取固定数量的单词，将它们按字典序插入到容器中。我们将在下一章中看到， 关联容器更适合这个问题。

(a)“按字典序插入到容器中”意味着进行插入排序操作，从而需要在容器内部频繁进行插入操作，`vector`在尾部之外的位置插入和删除元素很慢，`deque`在头尾之外的位置插入和删除元素很慢，而`list`在任何位置插入、删除速度都很决。
因此，这个任务选择`list`更为适合。
当然，如果不是必须边读取单词边插入到容器中， 可以使用`vector`，将读入的单词依次追加到尾部，读取完毕后，调用标准库到排序算法将单词重排为字典序。

(b)读取未知数量的单词，总是将新单词插入到末尾。删除操作在头部进行。

(b)由于需要在头、尾分别进行插入、删除操作，因此将 `vector` 排除在外，`deque` 和 `list` 都可以达到很好的性能。如果还需要频繁进行随机访问。则 `deque` 更好。

(c)从一个文件读取未知数量的整数。将这些数排序，然后将它们打印到标准输出。

(c) 由于整数占用空间很小，且快速的排序算法需频繁随机访问元素，将`list`排除在外。由于无须在头部进行插入、删除操作，因此使用`vector`即可，无须使用`deque`。

## 9.2 容器库概览

每个容器都定义在一个头文件中，文件名与类型名相同。
即，`deque`定义在头文件`deque`中，`list`定义在头文件`list`中。
容器均定义为模板类。
例如对`vector`，我们必须提供额外信息来生成特定的容器类型。
对大多数，但不是所有容器，我们还需要额外提供元素类型信息：

```cpp
list<Sales_data>    // 保存 Sales_data 对象的 list
deque<double>       // 保存 double 的 deque
```

### 对容器可以保存的元素类型的限制

顺序容器几乎可以保存任意类型的元素。

```cpp
vector<vector<string>> lines;   // vector 的 vector
// 此处 lines 是一个 vector，其元素类型是 string 的 vector
```

顺序容器构造函数的一个版本，接受容器大小参数，它使用了元素类型的默认构造函数。

但某些类没有默认构造函数，我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数：

```cpp
// 假定 noDefault 是一个没有默认构造函数的类型
vector<noDefault> v1(10, init); // 正确：提供了元素初始化器
vector<noDefault> v2(10);       // 错误：必须提供一个元素初始化器
```

#### 表9.2：容器操作

| 类型别名          |                                                        |
| ----------------- | ------------------------------------------------------ |
| `iterator`        | 此容器类型的迭代器类型                                 |
| `const_iterator`  | 可以读取元素，但不能修改元素的迭代器类型               |
| `size_type`       | 无符号整数类型，足够保存此种容器类型最大可能容器的大小 |
| `difference_type` | 带符号整数类型，足够保存两个迭代器之间的距离           |
| `value_type`      | 元素类型                                               |
| `reference`       | 元素的左值类型：与`value_type&`含义相同                |
| `const_reference` | 元素的`const`左值类型（即，`const value_type&`）       |

| 构造函数           |                                                              |
| ------------------ | ------------------------------------------------------------ |
| `C c`              | 默认构造函数，构造空容器                                     |
| `C c1(c2);`        | 构造 `c2` 的拷贝 `c1`                                        |
| `C c(b, e);`       | 构造 `c`，将迭代器 `b` 和 `e` 指定的范围内的元素拷贝到 `c`（`array`不支持） |
| `C c{a, b, c...};` | 列表初始化 `c`                                               |

| 赋值与`swap`        |                                                     |
| ------------------- | --------------------------------------------------- |
| `c1 = c2`           | 将 `c1` 中的元素替换为 `c2` 中元素                  |
| `c1 = {a, b, c...}` | 将 `c1` 中的元素替换为列表中元素（不适用于`array`） |
| `a.swap(b)`         | 交换 `a` 和 `b` 的元素                              |
| `swap(a, b)`        | 与 `a.swap(b)`等价                                  |

| 大小           |                                                    |
| -------------- | -------------------------------------------------- |
| `c.size()`     | `c` 中元素的数目（不支持 `forward_list`）          |
| `c.max_size()` | `c` 可保存的最大元素数目                           |
| `c.empty()`    | 若 `c` 中存储了元素，返回 `false`，否则返回 `true` |

| 添加 / 删除元素（不适用于 `array`） |                                    |
| ----------------------------------- | ---------------------------------- |
| `c.insert(args)`                    | 将`args`中的元素拷贝进 `c`         |
| `c.emplace(inits)`                  | 使用 `inits` 构造 `c` 中的一个元素 |
| `c.erase(args)`                     | 删除 `args`指定的元素              |
| `c.clear()`                         | 删除 `c` 中的所有元素，返回 `void` |
| 关系运算符                          |                                    |
| `==`，`!=`                          | 所有容器都支持相等（不等）运算符   |
| `<`，`<=`，`>`，`>=`                | 关系运算符（无序关联容器不支持）   |

| 获取迭代器               |                                               |
| ------------------------ | --------------------------------------------- |
| `c.begin()`, `c.end()`   | 返回指向 `c` 的首元素和尾元素之后位置的迭代器 |
| `c.cbegin()`, `c.cend()` | 返回 `const_iterator`                         |

| 反向容器的额外成员（不支持`forward_list`） |                                               |
| ------------------------------------------ | --------------------------------------------- |
| `reverse_iterator`                         | 按逆序寻址元素的迭代器                        |
| `const_reverse_iterator`                   | 不能修改元素的逆序迭代器                      |
| `c.rbegin()`, `c.rend()`                   | 返回指向 `c` 的尾元素和首元素之前位置的迭代器 |
| `c.crbegin()`, `c.crend()`                 | 返回 `const_reverse_iterator`                 |

**练习9.2：定义一个`list`对象，其元素类型是 `int` 的 `deque`。**

list<deque<int>> a;

### 9.2.1 迭代器

#### 迭代器范围

迭代器范围(iterator range)：`begin` 到 `end`(one past the last element)，它们标记了容器中元素的一个范围。

这种元素范围被称为**左闭合区间**(left-inclusive interval)，其标准数学描述为 `[begin, end)`，`end`可以与`begin`指向相同的位置。

#### 使用左闭合范围蕴含的变成假定

假定`begin`和`end`构成一个合法的迭代器范围，则

- 如果`begin`与`end`相等，则范围为空
- 如果`begin`与`end`不等，则范围至少包含一个元素，且`begin`指向该范围中的第一个元素
- 我们可以对`begin`递增若干次，使得`begin==end`

```cpp
while (begin != end)
    *begin = val;   // 正确：范围非空，因此 begin 指向一个元素
    ++begin;        // 移动迭代器，获取下一个元素
```

**练习9.3：构成迭代器范围的迭代器有何限制？**

两个迭代器`begin`和`end`必须指向同一个容器中的元素，或者是容器最后一个元素之后的位置；
而且，对`begin`反复进行递增操作，可保证到达`end`，即`end`不在`begin`之前。

**练习9.4：编写函数，接受一对指向 `vector<int>` 的迭代器和一个 `int` 值。在两个迭代器指定的范围中查找给定的值，返回一个布尔值来指出是否找到。**

```cpp
/* 练习9.4：编写函数，接受一对指向 vector<int> 的迭代器和一个 int 值。
在两个迭代器指定的范围中查找给定的值，返回一个布尔值来指出是否找到。 */

#include <iostream>
#include <vector>

using namespace std;

bool search_vec(vector<int>::iterator beg, vector<int>::iterator end, int val)
{
    for (; beg != end; beg++)   // 遍历范围
        if (*beg == val)        // 检查是否与给定值相等
            return true;
    return false;
}

int main()
{
    vector<int> ilist = {1, 2, 3, 4, 5, 6, 7};

    cout << search_vec(ilist.begin(), ilist.end(), 3) << endl;
    cout << search_vec(ilist.begin(), ilist.end(), 8) << endl;

    return 0;
}
```

**练习9.5：重写上一题的函数，返回一个迭代器指向找到的元素。注意，程序必须处理未找到给定值的情况。**

```cpp
/* 练习9.5：重写上一题的函数，返回一个迭代器指向找到的元素。
注意，程序必须处理未找到给定值的情况。*/

#include <iostream>
#include <vector>

using namespace std;

vector<int>::iterator search_vec(vector<int>::iterator beg, vector<int>::iterator end, int val)
{
    for (; beg != end; beg++)   // 遍历范围
        if (*beg == val)        // 检查是否与给定值相等
            return beg;         // 搜索成功，返回元素对应迭代器
    return end;                 // 搜索失败，返回尾后迭代器
}

int main()
{
    vector<int> ilist = {1, 2, 3, 4, 5, 6, 7};

    cout << search_vec(ilist.begin(), ilist.end(), 3) - ilist.begin() << endl;
    cout << search_vec(ilist.begin(), ilist.end(), 8) - ilist.begin() << endl;

    return 0;
}
```

**练习9.6：下面程序有何错误？你应该如何修改它？**

```cpp
list<int> lst1;
list<int>::iterator iter1 = lst1.begin(), iter2 = lst1.end();
while (iter1 < iter2) /* ...*/
```

【出题思路】
理解不同类型容器的迭代器之间的差别，更深层次的，理解数据结构的实现如何导致迭代器的差别。 

【解答】
与`vector`和`deque`不同，`list`的迭代器不支持`＜`运算，只支持递增、递减、 `==`以及`!=`运算。

原因在于这几种数据结构实现上的不同。`vector`和`deque`将元素在内存中连续保存，而`list`则是将元素以链表方式存储，因此前者可以方便地实现迭代器的大小比较（类似指针的大小比较）来体现元素的前后关系。而在`list`中，两个指针的大小关系与它们指向的元素的前后关系并不一定是吻合的，实现`<`运算将会非常困难和低效。

### 9.2.2 容器类型成员

每个容器都定义了多个**类型**，如 `size_type`、`iterator` 和 `const_iterator`。

除了已经使用过的**迭代器类型**，大多数容器还提供反向迭代器。反向迭代器就是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义也都发生了颠倒。例如，对一个反向迭代器执行`++`操作，会得到上一个元素。

类型别名，我们可以在不了解容器中元素类型的情况下使用它。如果需要元素类型，可以使用容器的`value_type`。如果需要元素类型的一个引用，可以使用`reference`或`const_reference`。

```cpp
// 为了使用这些类型，我们必须显式使用其类名：
// iter 是通过 list<string> 定义的一个迭代器类型
list<string>::iterator iter;
// count 是通过 vector<int> 定义的一个 difference_type 类型
vector<int>::difference_type count;
```

**练习9.7：为了索引 `int` 的 `vector` 中的元素，应该使用什么类型？**

【出题思路】标准库容器定义了若干类型成员，对应容器使用中可能涉及的类型，如迭代器、元素引用等。

【解答】使用迭代器类型 `vector<int>::iterator` 来索引`int`的`vector`中的元素。

**练习9.8：为了读取`string`的`list`中的元素，应该使用什么类型？如果写入`list`，又该使用什么类型？**

【解答】
为了读取`string`的`list`中的元素，应使用`list<string>::value_type`，因为`value_type`表示元素类型。

为了写入数据，需要（非常量）引用类型，因此应使用`list<string>::reference`。

### 9.2.3 `begin`和`end`成员

`begin`和`enc`有多个版本：带`r`的版本返回反向迭代器；以`c`开头的版本则返回`const`迭代器：

```cpp
list<string> a = {"Milton", "Shakespeare", "Austen"};
auto it1 = a.begin();   // list<string>::iterator
auto it2 = a.rbegin();  // list<string>::reverse_iterator
auto it3 = a.cbegin();  // list<string>::const_iterator
auto it4 = a.crbegin(); // list<string>::const_reverse_iterator
```

不以 `c` 开头的函数都是被重载过的。也就是说，实际上有两个名为`begin`的成员。
一个是`const`成员，返回容器的`const_iterator`类型。另一个是非常量成员，返回容器的`iterator`类型。`rbegin`、`en`和`rend`的情况类似。当我们对一个非常量对象调用这些成员时，得到的是返回 `iterator`的版本。只有在对一个`const`对象调用这些函数时，才会得到一个`const`版本。

```cpp
// 显式指定类型
list<string>::iterator it5 = a.begin();
list<string>::const_iterator it6 = a.begin();
// 是 iterator 还是 const_iterator 依赖于 a 的类型
auto it7 = a.begin();   // 仅当 a 是 const 时，it7 是 const_iterator
auto it8 = a.cbegin();  // it8 是 const_iterator
```

**练习9.9：`begin`和`cbegin`两个函数有什么不同？**

`cbegin` 是C++新标准引入的，用来与 `auto` 结合使用。
它返回指向容器第一个元素的 `const` 迭代器，可以用来只读地访问容器元素，但不能对容器元素进行修改。因此，当不需要写访问时，应该使用 `cbegin`。

`begin` 则是被重载过的，有两个版本：其中一个是 `const` 成员函数，也返回 `const` 迭代器：另一个则返回普通迭代器，可以对容器元索进行修改。

### 9.2.4 容器定义和初始化

| 表9.3：                                                 | 容器定义和初始化                                             |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| `C c`                                                   | 默认构造函数，如果`C`是一个`array`，则`c`中元素按默认方式初始化，否则`c`为空 |
| `C c1(c2)`<br />`C c1=c2`                               | `c1`初始化为`c2`的拷贝，`c1`和`c2`必须是相同类型（即，它们必须是相同的容器类型，且保存的是相同的元素类型；对于`array`类型，两者还必须具有相同大小） |
| `C c{a, b, c...}`<br />`C c={a, b, c...}`               | `c`初始化为初始化列表中元素的拷贝，列表中元素的类型必须与`c`的元素类型相容。<br />对于`array`类型，列表中元素数目必须等于或小于`array`的大小，任何遗漏的元素都进行值初始化 |
| `C c(b, e)`                                             | `c`初始化为迭代器`b`和`e`指定范围中的元素的拷贝。范围中元素的类型必须与`c`的元素类型相容。 |
| 只有顺序容器（不包括`array`）的构造函数才能接受大小参数 |                                                              |
| `C seq(n)`                                              | `seq`包含`n`个元素，这些元素进行了值初始化；此构造函数是`explicit`的 |
| `C seq(n, t)`                                           | `seq`包含`n`个初始化为值`t`的元素                            |

#### 将一个容器初始化为另一个容器的拷贝

将一个新容器创建为另一个容器的拷贝的方法有两种：

- 可以直接拷贝整个容器
- 拷贝由一个迭代器对指定的元素范围

为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。
**不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。**
**而且，新容器和元容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。**

**练习9.12：对于接受一个容器创建其拷贝的构造函数，和接受两个迭代器创建拷贝的构造函数，解释它们的不同。**

接受一个已有容器的构造函数会拷贝此容器中的所有元素，这样，初始化完成后，我们得到此容器的一个一模一样的拷贝。当我们确实需要一个**容器的完整拷贝**时，这种初始化方式非常方便。

但当我们不需要已有容器中的全部元素，而只是想拷贝其中一部分元素时，可使用接受**两个迭代器**的构造函数。传递给它要拷贝的范围的起始和尾后位置的迭代器，即可令新容器对象包含所需范围中元素的拷贝。

```cpp
// 每个容器有三个元素，用给定的初始化器进行初始化
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};

list<string> list2(authors);        // 正确：类型匹配
deque<string> authList(authors);    // 错误：容器类型不匹配
vector<string> words(articles);     // 错误：元素类型必须匹配
// 正确：可以将 const char* 元素转换为 string
forward_list<string> words(articles.begin(), articles.end());
```

Note: 当将一个容器**初始化**为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。

由于两个迭代器表示一个范围，因此可以使用这种构造函数来拷贝一个容器中的子序列。
例如，假定迭代器`it`表示`authors`中的一个元素，我们可以编写如下代码：

```cpp
// 拷贝元素，直到（但不包括）it 指向的元素
deque<string> authList(authors.begin(), it);
```

**练习9.11：对 6 种创建和初始化 vector 对象的方法，每一种都给出一个实例。解释每个 vector 包含什么值。**

```cpp
/* 练习9.11：对 6 种创建和初始化 vector 对象的方法，每一种都给出一个实例。解释每个 vector 包含什么值。*/

(1) vector<int> ilist1; // 默认初始化

(2) vector<int> ilist2(ilist); // ilist2 初始化为 ilist 的拷贝

    vector<int> ilist2_1 = ilist;   // 等价方式

(3) vector<int> ilist = {1, 2, 3.0, 4, 5, 6, 7}; // ilist 初始化为列表中元素的拷贝
    vector<int> ilist{1, 2, 3.0, 4, 5, 6, 7};   // 等价方式

(4) vector<int> ilist(ilist.begin() + 2, ilist.end() - 1);

/* ilist3 初始化为两个迭代器指定范围中的元素的拷贝，范围中的元素类型必须与 ilist3 的元素类型相容，在本例中 ilist3 被初始化为 {3, 4, 5, 6}。

注意，由于只要求范围中元素类型鱼待初始化的容器的元素类型相容，因此，迭代器来自于不同类型的容器是可能的，例如，用一个 double 的 list 的范围来初始化 ilist3 是可行的。

另外，由于构造函数只是读取范围中的元素并进行拷贝，因此使用普通迭代器还是 const 迭代器来指出范围并无区别。

这种初始化方法特别适合于获取一个序列的子序列。*/

(5) vector<int> ilist4(7); // 默认值初始化

(6) vector<int> ilist5(7, 3); // 指定值初始化
```

**练习9.13：如何从一个 `list<int>` 初始化一个 `vector<double>`？从一个 `vector<int>` 又该如何创建？编写代码验证你的答案。**

```cpp
/* 练习9.13：如何从一个 `list<int>` 初始化一个 `vector<double>`？
从一个 `vector<int>` 又该如何创建？编写代码验证你的答案。

【出题思路】更深入地理解容器拷贝初始化和范围初始化两种方式的差异。

【解答】
由于 `list<int>` 与 `vector<double>` 是不同的容器类型，因此无法采用容器拷贝初始化方式。
但前者的元素类型是 `int`，与后者的元素类型 `double` 是相容的，因此可以采用范围初始化方式来构造一个 `vector<double>`，令它的元素值与 `list<int>`完全相同。*/

#include <iostream>
#include <vector>
#include <list>

using namespace std;

int main()
{
    list<int> ilist = {1, 2, 3, 4, 5, 6, 7};
    vector<int> ivec = {7, 6, 5, 4, 3, 2, 1};

    // 容器类型不同，不能使用拷贝初始化
    // vector<double> ivec(ilist);

    /* 元素类型相容，因此可采用范围初始化 */
    vector<double> dvec(ilist.begin(), ilist.end());

    // 元素类型不同，不能使用拷贝初始化
    // vector<double> dvec1(ivec);

    /* 元素类型相容，因此可采用范围初始化 */
    vector<double> dvec1(ivec.begin(), ivec.end());

    cout << dvec.capacity() << " " << dvec.size() << " " << dvec[0] << " " << dvec[dvec.size() - 1] << endl;

    cout << dvec1.capacity() << " " << dvec1.size() << " " << dvec1[0] << " " << dvec1[dvec1.size() - 1] << endl;

    return 0;
}

/*Output:
7 7 1 7
7 7 7 1
*/
```

#### 列表初始化

我们可以对一个容器进行列表初始化：

```cpp
// 每个容器有三个元素，用给定的初始化器进行初始化
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};
```

#### 与顺序容器大小相关的构造函数

顺序容器接受一个容器大小和一个（可选的）元素初始值。
如果我们不提供元素初始值，则标准库会创建一个值初始化器：

```cpp
vector<int> ivec(10, -1);       // 10 个 int 元素，每个都初始化为 -1
list<string> svec(10, "hi!");   // 10 个 strings; 每个都初始化为 "hi!"
forward_list<int> ivec(10);     // 10 个元素，每个都初始化为 0
deque<string> svec(10);         // 10 个元素，每个都是空 string
```

Note: 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。

#### 标准库`array`具有固定大小

当定义一个`array`时，除了制定元素类型，还要指定容器大小：

```cpp
array<int, 42>      // 类型为：保存 42 个 int 的数组
array<string, 10>   // 类型为：保存 10 个 string 的数组
```

为了使用`array`类型，我们必须同时指定元素类型和大小，大小是`array`类型的一部分：

```cpp
array<int, 10>::size_type i;    // 数组类型包括元素类型和大小
array<int>::size_type j;        // 错误：array<int> 不是一个类型
```

如果元素类型是一个类类型，那么该类必须有一个默认构造函数，以使值初始化能够进行：

```cpp
array<int, 10> ia1;         // 10 个默认初始化的 int
array<int, 10> ia2 = {0,1,2,3,4,5,6,7,8,9}; // 列表初始化
array<int, 10> ia3 = {42};  // ia3[0] 为 42，剩余元素为 0
```

值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但`array`并无此限制：

```cpp
int digs[10] = {0,1,2,3,4,5,6,7,8,9};
int cpy[10] = digs;             // 错误：内置数组不支持拷贝或赋值
array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> copy = digits;   // 正确：只要数组类型匹配即合法
```

### 9.2.5 赋值和swap

与内置数组不同，标准库`array`类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型：

```cpp
array<int, 10> a1 = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> a2 = {0};    // 所有元素值均为 0
a1 = a2;    // 替换 a1 中的元素
a2 = {0};   // 错误：不能讲一个花括号列表赋予数组
```

由于右边运算对象的大小可能与左边运算对象的大小不同，因此`array`类型不支持`assign`，也不允许用花括号包围的值列表进行复制。

| 表9.4：                               | 容器赋值运算                                                 |
| ------------------------------------- | ------------------------------------------------------------ |
| `c1=c2`                               | 将`c1`中的元素替换为`c2`中元素的拷贝，`c1`和`c2`必须具有相同的类型 |
| `c={a,b,c...}`                        | 将`c1`中元素替换为初始化列表中元素的拷贝（`array`不适用）    |
| `swap(c1,c2)`                         | 交换`c1`和`c2`中的元素，`c1`和`c2`必须具有相同的类型         |
| `c1.swap(c2)`                         | `swap`通常比从`c2`向`c1`拷贝元素快得多                       |
| `assign`操作不适用于关联容器和`array` |                                                              |
| `seq.assign(b,e)`                     | 将`seq`中的元素替换为迭代器`b`和`e`所表示的范围中的元素，迭代器`b`和`e`不能指向`seq`中的元素 |
| `seq.assign(il)`                      | 将`seq`中的元素替换为初始化列表`il`中的元素                  |
| `seq.assign(n, t)`                    | 将`seq`中的元素替换为`n`个值为`t`的元素                      |

**WARNING**: 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而`swap`操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效（容器类型为`array`和`string`的情况除外）。

#### 使用 `assign`（仅顺序容器）

我们可以用`assign`实现将一个`vector`中的一段`char*`值赋予一个`list`中的`string`：

```cpp
list<string> names;
vector<const char*> oldstyle;
names = oldstyle;   // 错误：容器类型不匹配
// 正确：可以将 const char* 转换为 string
names.assign(oldstyle.cbegin(), oldstyle.cend());
```

这段代码中对`assign`的调用将`names`中的元素替换为迭代器指定的范围中的元素的拷贝。`assign`的参数决定了容器中将有多少个元素以及它们的值都是什么。

`assign`的第二个版本，用指定书目且具有相同给定值的元素替换容器中原有的元素：

```cpp
// 等价于 slist1.clear();
// 后跟 slist1.insert(slist1.begin(), 10, "Hiya!");
list<string> slist1(1);     // 1 个元素，为空 string
slist1.assign(10, "Hiya!"); // 10 个元素，每个都是 "Hiya!"
```

**练习9.14：编写程序，将一个`list`中的`char*`指针（指向C风格字符串）元素赋值给一个`vector`中的`string`。**

```cpp
/* 练习9.14：编写程序，将一个`list`中的`char*`指针（指向C风格字符串）元素赋值给一个`vector`中的`string`。

【出题思路】
容器有多种赋值操作，本题帮助读者理解不同赋值方式的差异。

【解答】
由于 list<char*> 与 vector<string> 是不同类型的容器，因此无法采用赋值运算符 `=` 来进行元素赋值。
但 char* 可以转换为 string，因此可以采用范围赋值方式来实现本题要求。*/

#include <iostream>
#include <vector>
#include <list>

using namespace std;

int main()
{
    list<char *> slist = {"hello", "world", "!"};
    vector<string> svec;

    // 容器类型不同，不能直接赋值
    // svec = slist;

    /*元素类型相容，可以采用范围赋值*/
    svec.assign(slist.begin(), slist.end());

    cout << svec.capacity() << " " << svec.size() << " " << svec[0] << " " << svec[svec.size()-1] << endl;

    return 0;
}

// Output: 3 3 hello !
```

#### 使用 `swap`

```cpp
vector<string> svec1(10);   // 10 个元素的 vector
vector<string> svec2(24);   // 24 个元素的 vector
swap(svec1, svec2);
```

调用`swap`后，`svec1`将包含`24`个`string`元素，`svec2`将包含`10`个`string`。除`array`外，交换两个容器内容的操作保证会很快——元素本身并未交换 / 元素不会被移动，`swap`只是交换了两个容器的内部数据结构。

Note: 除`array`外，`swap`不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。

元素不会被移动的事实意味着，除`string`外，指向容器的迭代器、引用和指针在`swap`操作之后都不会失效。

对一个`string`调用`swap`会导致迭代器、引用和指针失效。

`swap`两个`array`会真正交换它们的元素。因此，交换两个`array`所需的时间与`array`中元素的数目成正比。

因此，对于`array`，在`swap`操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素已经与另一个`array`中对应元素的值进行了交换。

### 9.2.6 容器大小操作

- 成员函数`size`返回容器中元素的数目；
- `empty`当`size`为`0`时返回布尔值`true`，否则返回`false`；
- `max_size`返回一个大于或等于该类型容器所能容纳的最大元素数的值。
- `forward_list`支持`max_size`和`empty`，但不支持`size`。

### 9.2.7 关系运算符

每个容器类型都支持相等运算符（`==`和`!=`）；
除了无序关联容器外的所有容器都支持关系运算符（`>`、`>=`、`<`、`<=`）。

#### 容器的关系运算符使用元素的关系运算符完成比较

Note: 只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。

如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算。
例如，我们在第7章中定义的`Sales_data`类型并未定义`==`和`<`运算。因此，就不能比较两个保存`Sales_data`元素的容器：

```cpp
vector<Sales_data> storeA, storeB;
if (storeA < storeB)    // 错误：Sales_data 没有 < 运算符
```

**练习9.17：假定`c1`和`c2`是两个容器，下面的比较操作有何限制（如果有的话）？**
`if (c1 < c2)`

【解答】
首先，容器类型必须相同，元素类型也必须相同。
其次，元素类型必须支持 `<` 运算符。

**练习9.16：重写上一题的程序，比较一个 `list<int>` 中的元素和一个`vector<int>`中的元素。**

```cpp
/* 练习9.16：重写上一题的程序，比较一个 list<int> 中的元素和一个 vector<int> 中的元素。*/

/* 练习9.15：编写程序，判定两个 vector<int> 是否相等。

【解答】标准库容器支持关系运算符，比较两个 vector 是否相等使用 == 运算符即可。
当两个vector包含相同个数的元素，且对位元素都相等时，判定两个 vector 相等，否则不等。
两个 vector 的 capacity 不会影响相等性判定，因此，当下面程序中 ivec1 在添加、删除元素导致扩容后，仍然与 ivec 相等。*/

#include <iostream>
#include <vector>
#include <list>

using namespace std;

bool l_v_equal(vector<int> &ivec, list<int> &ilist) {
    // 比较 list 和 vector 元素个数
    if (ilist.size() != ivec.size())
        return false;

    auto lb = ilist.cbegin();       // list 首元素
    auto le = ilist.cend();         // list 尾后位置
    auto vb = ivec.cbegin();        // vector 首元素
    for ( ; lb != le; lb++, vb++)
        if (*lb != *vb)             // 元素不等，容器不等
            return false;
    return true;                    // 容器相等
}

int main()
{
    vector<int> ivec = {1, 2, 3, 4, 5, 6, 7};
    list<int> ilist = {1, 2, 3, 4, 5, 6, 7};
    list<int> ilist1 = {1, 2, 3, 4, 5};
    list<int> ilist2 = {1, 2, 3, 4, 5, 6, 8};
    list<int> ilist3 = {1, 2, 3, 4, 5, 7, 6};

    cout << l_v_equal(ivec, ilist) << endl;
    cout << l_v_equal(ivec, ilist1) << endl;
    cout << l_v_equal(ivec, ilist2) << endl;
    cout << l_v_equal(ivec, ilist3) << endl;

    return 0;
}
```

## 9.3 顺序容器操作

### 9.3.1 向顺序容器添加元素

| 表9.5：                                        | 向顺序容器添加元素的操作                                     |
| ---------------------------------------------- | ------------------------------------------------------------ |
|                                                | 这些操作会改变容器的大小；`array`不支持这些操作。            |
|                                                | `forward_list`有自己专有版本的`insert`和`emplace`；          |
|                                                | `forward_list`不支持`push_back`和`emplace_back`。            |
|                                                | `vector`和`string`不支持`push_front`和`emplace_front`。      |
| `c.push_back(t)`<br />`c.emplace_back(args)`   | 在`c`的尾部创建一个值为`t`或由`args`创建的元素，返回`void`   |
| `c.push_front(t)`<br />`c.emplace_front(args)` | 在`c`的头部创建一个值为`t`或由`args`创建的元素，返回`void`   |
| `c.insert(p, t)`<br />`c.emplace(p, args)`     | 在迭代器`p`指向的元素之前创建一个值为`t`或由`args`创建的元素。返回指向新添加的元素的迭代器 |
| `c.insert(p, n, t)`                            | 在迭代器`p`指向的元素之前插入`n`个值为`t`的元素。返回指向新添加的第一个元素的迭代器；若`n`为`0`，则返回`p` |
| `c.insert(p, b, e)`                            | 将迭代器`b`和`e`指定的范围内的元素插入到迭代器`p`指向的元素之前。`b`和`e`不能指向`c`中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，则返回`p` |
| `c.insert(p, il)`                              | `il`是一个花括号包围的元素值列表。将这些给定值插入到迭代器`p`指向的元素之前。返回指向新添加的第一个元素的迭代器；若列表为空，则返回`p` |

WARNING: 向一个`vector`、`string`或`deque`插入元素会使所有指向容器的迭代器、引用和指针失效。

在一个`vector`或`string`的尾部之外的任何位置，或是一个`deque`的首尾之外的任何位置添加元素，都需要移动元素。
而且，向一个`vector`或`string`添加元素可能引起整个对象存储空间的重新分配。
重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间中。

#### 使用`push_back`

除`array`和`forward_list`之外，每个顺序容器（包括`string`类型）都支持`push_back`。

```cpp
// 从标准输入读取数据，将每个单词放到容器末尾
string word;
while (cin >> word)
    container.push_back(word);
```

`container`的类型可以是`list`、`vector`或`deque`。

由于`string`是一个字符容器，我们也可以用`push_back`在`string`末尾添加字符：

```cpp
void pluralize (size_t cnt, string &word)
{
    if (cnt > 1)
        word.push_back('s');    // 等价于 word += 's'
}
```

**练习9.20：编写程序，从一个 `list<int>` 拷贝元素到两个 `deque` 中。值为偶数的所有元素都拷贝到一个 `deque` 中，而奇数值元素都拷贝到另一个 `deque` 中。**

```cpp
/* 练习9.20：编写程序，从一个 `list<int>` 拷贝元素到两个 `deque` 中。
值为偶数的所有元素都拷贝到一个 `deque` 中，而奇数值元素都拷贝到另一个 `deque` 中。

【出题思路】练习多个容器间数据的处理、拷贝。*/

#include <iostream>
#include <list>
#include <deque>

using namespace std;

int main()
{
    list<int> ilist = {1, 2, 3, 4, 5, 6, 7, 8}; // 初始化整数 list
    deque<int> odd_d, even_d;

    // 遍历整数 list
    for (auto iter = ilist.cbegin(); iter != ilist.cend(); iter++)
        if (*iter & 1)      // 查看最低位，1：奇数， 0：偶数
            odd_d.push_back(*iter);
        else even_d.push_back(*iter);

    cout << "The odd numbers are: ";
    for (auto iter = odd_d.cbegin(); iter != odd_d.cend(); iter++)
        cout << *iter << " ";
    cout << endl;

    cout << "The even numbers are: ";
    for (auto iter = even_d.cbegin(); iter != even_d.cend(); iter++)
        cout << *iter << " ";
    cout << endl;

    return 0;
}

/*Output:
The odd numbers are: 1 3 5 7
The even numbers are: 2 4 6 8

【其他解题思路】对于奇偶性判定，可用模2运算“%2”代替位与运算，两者是等价的。*/
```

**关键概念：容器元素是拷贝：**

当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。
就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。
随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。

#### 使用`push_front`

`list`、`forward_list`和`deque`还支持`push_front`的类似操作，将元素插入到容器头部：

```cpp
list<int> ilist;
// 将元素添加到 ilist 开头
for (size_t ix = 0; ix != 4; ++ix)
    ilist.push_front(ix);
```

此循环将元素0、1、2、3添加到`ilist`头部。在循环执行完毕后，`ilist`保存序列3、2、1、0。

**练习9.18：编写程序，从标准输入读取 `string` 序列，存入一个 `deque` 中。编写一个循环，用迭代器打印 `deque` 中的元素。**

```cpp
/* 练习9.18：编写程序，从标准输入读取 `string` 序列，存入一个 `deque` 中。编写一个循环，用迭代器打印 `deque` 中的元素。

【解答】对 `deque` 来说，在首尾位置添加新元素性能最佳，在中间位置插入新元素性能会很差。对遍历操作，可高效完成。*/

#include <iostream>
#include <deque>

using namespace std;

int main()
{
    deque<string> sd;   // string 的 deque

    string word;
    while (cin >> word) // 读取字符串，直至遇到文件结束符
        sd.push_back(word);

    // 用 cbegin() 获取 deque 首元素迭代器，遍历 deque 中所有元素
    for (auto si = sd.cbegin(); si != sd.cend(); si++)
        cout << *si << endl;

    return 0;
}

/*【其他解题思路】
由于在 `deque` 的首尾位置添加新元素性能很好，因此可以用 `push_front` 替换 `push_back`，性能不变，但元素在 `deque` 中的顺序将与输入顺序相反。
若需保持相同顺序，应使用 `push_back`。*/
```

#### 在容器中的特定位置添加元素

`vector`、`deque`、`list`和`string`都支持`insert`成员。

`insert`函数将元素插入到迭代器所指定的位置之前：

```cpp
slist.insert(iter, "Hello!");   // 将 "Hello!" 添加到 iter 之前的位置
// 将一个值为"Hello"的string插入到iter指向的元素之前的位置
```

虽然某些容器不支持`push_front`，但它们对于`insert`操作并无类似的限制（插入开始位置）。因此，我们可以将元素插入到容器的开始位置，而不必担心容器是否支持`push_front`：

```cpp
vector<string> svec;
list<string> slist;

// 等价于调用 slist.push_front("Hello!");
slist.insert(slist.begin(), "Hello!");

// vector 不支持 push_front，但我们可以插入到 begin() 之前
// 警告：插入到 vector 末尾之外的任何位置都可能很慢
svec.insert(svec.begin(), "Hello!");
```

WARNING: 将元素插入到`vector`、`deque`和`string`中的任何位置都是合法的。然而，这样做可能很耗时。

#### 插入范围内元素

接受一对迭代器或一个初始化列表的 insert 版本将给定范围中的元素插入到指定位置之前：

```cpp
// 接受一对迭代器或一个初始化列表的 insert 版本将给定范围中的元素插入到指定位置之前：
vector<string> v = {"quasi", "simba", "frollo", "scar"};
// 将 v 的最后两个元素添加到 slist 的开始位置
slist.insert(slist.begin(), v.end() - 2, v.end());
slist.insert(slist.end(), {"these", "words", "will", "go", "at", "the", "end"});
```

如果我们传递给`insert`一对迭代器，它们不能指向添加元素的目标容器：

```cpp
// 运行时错误：迭代器表示要拷贝的范围，不能指向与目的位置相同的容器
slist.insert(slist.begin(), slist.begin(), slist.end());
```

#### 使用`insert`的返回值

通过使用`insert`的返回值，可以再容器中一个特定位置反复插入元素：

```cpp
list<string> lst;
auto iter = lst.begin();
while (cin >> word)
    iter = lst.insert(iter, word);  // 等价于调用 push_front
```

**练习：假定`iv`是一个`int`的`vector`，下面的程序存在什么错误？你将如何修改？**

```cpp
vector<int>::iterator iter = iv.begin(),
                       mid = iv.begin() + iv.size()/2;
while (iter != mid)
    if (*iter == some_val)
        iv.insert(iter, 2 * some_val);
```

【出题思路】
首先，理解容器插入操作的副作用 —— 向一个`vector`、 `string`或`deque`插入元素会使现有指向容器的迭代器、引用和指针失效。
其次，练习如何利用`insert`返回的迭代器，使得在向容器插入元素后，仍能正确在容器中进行遍历。

【解答】
循环中未对`iter`进行递增操作，`iter`无法向中点推进。其次，即使加入了`iter++`语句，由于向`iv`插入元素后，`iter`己经失效，`iter++`也不能起到将迭代器向前推进一个元素的作用。修改方法如下：

首先，将`insert`返回的迭代器赋予`iter`，这样，`iter`将指向新插入的元素`y`。我们知道，`insert`将`y`插入到`iter`原来指向的元素`x`之前的位置，因此，接下来我们需要进行两次`iter++`才能将`iter`推进到`x`之后的位置。

其次，`insert()`也会使`mid`失效，因此，只正确设置`iter`仍不能令循环在正确的时候结束，我们还需设置`mid`使之指向`iv`原来的中央元素。在未插入任何新元素之前，此位置是`iv.begin() + iv.size()/2`，我们将此时的`iv.size()`的值记录在变量`org_size`中。然后在循环过程中统计新插入的元素的个数`new_ele`，则在任何时候，`iv.begin() + org_size/2 + new_ele` 都能正确指向 `iv` 原来的中央元素。

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    vector<int> iv = {1, 1, 2, 1};  // int 的 vector
    int some_val = 1;

    vector<int>::iterator iter = iv.begin();
    int org_size = iv.size(), new_ele = 0;  // 原大小和新元素个数

    // 每个循环步都重新计算 "mid"，保证正确指向 iv 原中央元素
    while (iter != (iv.begin() + org_size / 2 + new_ele))
        if (*iter == some_val) {
            iter = iv.insert(iter, 2 * some_val);
            new_ele++;
            iter++; iter++; // 将 iter 推进到旧元素的下一个位置
        } else iter++;      // 简单推进 iter

    // 用 begin() 获取 vector 首元素迭代器，遍历 vector 中的所有元素
    for (iter iv.begin(); iter != iv.end(); iter++)
        cout << *iter << endl;

    return 0;
}
```

#### 使用`emplace`操作

当我们调用`emplace`成员函数时，是将参数传递给元素类型的构造函数。
`emplace`成员使用这些参数在容器管理的内存空间中直接构造元素。

例如：假定`c`保存`Sales_data`元素：

```cpp
// 在 c 的末尾构造一个 Sales_data 对象
// 使用三个参数的 Sales_data 构造函数
c.emplace_back("978-0590353403", 25, 15.99);
// 错误：没有接受三个参数的 push_back 版本
c.push_back("978-0590353403", 25, 15.99);
// 正确：创建一个临时的 Sales_data 对象传递给 push_back
c.push_back(Sales_data("978-0590353403", 25, 15.99));
```

在调用`emplace_back`时，会在容器管理的内存空间中直接创建对象。而调用`push_back`则会创建一个局部临时对象，并将其压入容器中。

`emplace`函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配：

```cpp
// iter 指向 c 中一个元素，其中保存了 Sales_data 元素
c.emplace_back();   // 使用 Sales_data 的默认构造函数
c.emplace(iter, "999-999999999");   // 使用 Sales_data(string)
// 使用 Sales_data 的接受一个 ISBN、一个 count 和一个 price 的构造函数
c.emplace_front("978-0590353403", 25, 15.99");
```

Note: `emplace`函数在容器中直接构造元素。传递给`emplace`函数的参数必须与元素类型的构造函数相匹配。

### 9.3.2 访问元素

```cpp
// 在解引用一个迭代器或调用 front 或 back 之前检查是否有元素
if (!c.empty()) {
    // val 和 val2 是 c 中第一个元素值的拷贝
    auto val = *c.begin(), val2 = c.front();
    // val3 和 val4 是 c 中最后一个元素值的拷贝
    auto last = c.end();
    auto val3 = *(--last);  // 不能递减 forward_list 迭代器
    auto val4 = c.back();   // forward_list 不支持
}
```

此程序用两种方式来获取`c`中的首元素和尾元素的引用。

直接的方法是调用`front`和`back`。
而间接的方法是通过解引用`begin`返回的迭代器来获得首元素的引用，以及通过递减然后解引用`end`返回的迭代器来获得尾元素的引用。

迭代器`end`指向的是容器尾元素之后的（不存在）的元素。为了获取尾元素，必须首先递减此迭代器。

在调用`front`和`back`（或解引用`begin`和`end`返回的迭代器）之前，要确保`c`非空。如果容器为空，`if`中操作的行为将是未定义的。

| 表9.6：                                                      | 在顺序容器中访问元素的操作                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `at`和下标操作只适用于`string`、`vector`、`deque`和`array`。 |                                                              |
| `back`不适用于 `forward_list`。                              |                                                              |
| `c.back()`                                                   | 返回`c`中尾元素的引用。若`c`为空，函数行为未定义。           |
| `c.front()`                                                  | 返回`c`中首元素的引用。若`c`为空，函数行为未定义。           |
| `c[n]`                                                       | 返回`c`中下标为`n`的元素的引用，`n`是一个无符号整数。若`n >= s.size()`，则函数行为未定义 |
| `c.at(n)`                                                    | 返回下标为`n`的元素的引用。如果下标越界，则抛出 `out_of_range`异常 |

#### 访问成员函数返回的是引用

```cpp
if (!c.empty()) {
    c.front() = 42;       // 将 42 赋予 c 中的第一个元素
    auto &v = c.back();   // 获得指向最后一个元素的引用
    v = 1024;             // 改变 c 中的元素
    auto v2 = c.back();   // v2 不是一个引用，它是 c.back() 的一个拷贝
    v2 = 0;               // 未改变 c 中的元素
}
```

在容器中访问元素的成员函数（即，`front`、`back`、下标和`at`）返回的都是引用。

如果我们使用`auto`变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。

#### 下标操作和安全的随机访问

如果希望确保下标是合法的，可以使用`at`成员函数。`at`成员函数类似下标运算符，但如果下标越界，`at`会抛出一个`out_of_range`异常：

```cpp
vector<string> svec;    // 空 vector
cout << svec[0];        // 运行时错误：svec 中没有元素！
cout << svec.at(0);     // 抛出一个 out_of_range 异常
```

**练习9.24：编写程序，分别使用`at`、`下标运算符`、`front`和`begin`提取一个 `vector`中的第一个元素。在一个空`vector`上测试你的程序。**

 【出题思路】
 练习获取容器首元素的不同方法，以及如何安全访问容器元素。

 【解答】
 下面的程序会异常终止。因为`vector`为空，此时用`at`访问容器的第一个元素会抛出一个`out_of_range`异常，而此程序未捕获异常，因此程序会因异常退出。正确的编程方式是，捕获可能的`out of range`异常，进行相应的处理。

但对于后三种获取容器首元素的方法，当容器为空时，不会抛出`out_of_range`异常，而是导致程序直接退出（注释掉前几条语句即可看到后面语句的执行效果）。
因此，正确的编程方式是，在采用这几种获取容器的方法时，检查下标的合法性（对`front`和`begin`只需检查容器是否为空），确定没有问题后再获取元素。当然这种方法对`at`也适用。

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    vector<int> iv;

    cout << iv.at(0) << endl;
    cout << iv[0] << endl;
    cout << iv.front() << endl;
    cout << *(iv.begin()) << endl;

    return 0;
}

/* 报错：
terminate called after throwing an instance of 'std::out_of_range'
  what():  vector::_M_range_check: __n (which is 0) >= this->size() (which is 0)
*/
```

### 9.3.3 删除元素

| 表9.7：         | 顺序容器的删除操作                                           |
| --------------- | ------------------------------------------------------------ |
|                 | 这些操作会改变容器的大小，所以不适用于`array`                |
|                 | `forward_list`有特殊版本的`erase`                            |
|                 | `forward_list`不支持`pop_back`；`vector`和`string`不支持`pop_front`。 |
| `c.pop_back()`  | 删除`c`中尾元素。若`c`为空，则函数行为未定义。函数返回`void` |
| `c.pop_front()` | 删除`c`中首元素。若`c`为空，则函数行为未定义。函数返回`void` |
| `c.erase(p)`    | 删除迭代器`p`所指定的元素，返回一个指向被删元素之后元素的迭代器，若`p`指向尾元素，则返回尾后(`off-the-end`)迭代器。若`p`是尾后迭代器，则函数行为未定义。 |
| `c.erase(b, e)` | 删除迭代器`b`和`e`所指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器，若`e`本身就是尾后迭代器，则函数也返回尾后迭代器 |
| `c.clear()`     | 删除`c`中的所有元素。返回`void`                              |

WARNING: 删除`deque`中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。指向`vector`或`string`中删除点之后位置的迭代器、引用和指针都会失效。

#### `pop_front`和`pop_back`成员函数

与`vector`和`string`不支持`push_front`一样，这些类型也不支持`pop_front`。
类似的，`forward_list`不支持`pop_back`。

#### 从容器内部删除一个元素

成员函数`erase`从容器中指定位置删除元素。我们可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。两种形式的`erase`都返回指向删除的（最后一个）元素之后位置的迭代器。

```cpp
// 下面的循环删除一个 list 中的所有奇数元素：

list<int> lst = {0,1,2,3,4,5,6,7,8,9};
auto it = lst.begin();
while (it != lst.end())
    if (*it % 2)            // 若元素为奇数
        it = lst.erase(it); // 删除此元素
    else
        ++it;
```

每个循环步中，首先检查当前元素是否是奇数。
如果是，就删除该元素，并将`it`设置为我们所删除的元素之后的元素。
如果`*it`为偶数，我们将`it`递增，从而在下一步循环检查下一个元素。

#### 删除多个元素

接受一对迭代器的`erase`版本允许我们删除一个范围内的元素：

```cpp
// 删除两个迭代器表示的范国内的元素
// 返回指向最后一个被删元素之后位置的迭代器
elem1 = slist.erase(elem1, elem2);  // 调用后，elem1 == elem2
```

迭代器`elem1`指向我们要删除的第一个元素，`elem2`指向我们要删除的**最后一个元素之后的**位置。

**练习25：对于第312页中删除一个范围内的元素的程序，如果`elem1`与`elem2`相等会发生什么，如果`elem2`是尾后迭代器，或者`elem1`和`elem2`皆为尾后迭代器，又会发生什么？**

【出题思路】
理解范围删除操作的两个迭代器参数如何决定删除操作的结果。

【解答】如果两个迭代器`eleml`和`elem2`相等，则什么也不会发生，容器保持不变．哪怕两个迭代器是指向尾后位置（例如`end()+1`），也是如此，程序也不会出错。

因此`elem1`和`elem2`都是尾后迭代器时，容器保持不变。
如果`elem2`为尾后迭代器，`elem1`指向之前的合法位置，则会删除从`elem1`开始直至容器末尾的所有元素。

----------

为了删除一个容器中的所有元素，我们既可以调用`clear`，也可以用`begin`和`end`获得的迭代器作为参数调用`erase`:

```cpp
slist.clear();  // 删除容器中所有元素
slist.erase(slist.begin(), slist.end());    // 等价调用
```

**练习9.26：使用下面代码定义的 `ia`，将 `ia` 拷贝到一个 `vector` 和一个 `list` 中。使用单迭代器版本的 `erase` 从 `list` 中删除奇数元素，从 `vector` 中删除偶数元素。**

```cpp
/* 练习9.26：使用下面代码定义的 ia，将 ia 拷贝到一个 vector 和一个 list 中。使用单迭代器版本的 erase 从 list 中删除奇数元素，从 vector 中删除偶数元素。
int ia[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 55, 89 };   */

/*【解答】
当从 vector 中删除元素时，会导致删除点之后位置的迭代器、引用和指针失效。
而 erase 返回的迭代器指向删除元素之后的位置。因此，将 erase 返回的迭器赋予 iiv，使其正确向前推进。且尾后位置每个循环步中都用 end 重新获得，保证其有效。

对于 list 删除操作并不会令迭代器失效，但上述方法仍然是适用的． */

#include <iostream>
#include <vector>
#include <list>

using namespace std;

int main()
{
    int ia[] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 55, 89};
    vector<int> iv;
    list<int> il;

    iv.assign(ia, ia + 11);         // 将数据拷贝到 vector
    il.assign(ia, ia + 11);         // 将数据拷贝到 list

    vector<int>::iterator iiv = iv.begin();
    while (iiv != iv.end())
        if (!(*iiv & 1))            // 偶数
            iiv = iv.erase(iiv);    // 删除偶数，返回下一位置迭代器
        else iiv++;                 // 推进到下一位置

    list<int>::iterator iil = il.begin();
    while (iil != il.end())
        if (*iil & 1)               // 奇数
            iil = il.erase(iil);    // 删除奇数，返回下一位置迭代器
        else iil++;                 // 推进到下一位置

    for (iiv = iv.begin(); iiv != iv.end(); iiv++)
        cout << *iiv << " ";
    cout << endl;

    for (iil = il.begin(); iil != il.end(); iil++)
        cout << *iil << " ";
    cout << endl;

    return 0;
}

/*Output:
1 1 3 5 13 21 55 89
0 2 8
*/
```

### 9.3.4 特殊的`forward_list`操作

| 表9.8：                   | 在`forward_list`中插入或删除元素的操作                       |
| ------------------------- | ------------------------------------------------------------ |
| `lst.before_begin()`      | 返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用。 |
| `lst.cbefore_begin()`     | `cbefore_begin()`返回一个`const_iterator`                    |
| `lst.insert_after(p,t)`   | 在迭代器`p`之后的位置插入元素。`t`是一个对象。               |
| `lst.insert_after(p,n,t)` | `t`是一个对象，`n`是数量                                     |
| `lst.insert_after(p,b,e)` | `b`和`e`是表示范围的一对迭代器（`b`和`e`不能指向`lst`内）    |
| `lst.insert_after(p,il)`  | `il`是一个花括号列表。返回一个指向最后一个插入元素的迭代器。如果范围为空，则返回`p`。若`p`为尾后迭代器，则函数行为未定义 |
| `emplace_after(p,args)`   | 使用`args`在`p`指定的位置之后创建一个元素。返回一个指向这个新元素的迭代器。若`p`为尾后迭代器，则函数行为未定义 |
| `lst.erase_after(p)`      | 删除`p`指向的位置之后的元素                                  |
| `lst.erase_after(b,e)`    | 或删除从`b`之后直到（但不包含）`e`之间的元素。返回一个指向被删元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器。如果`p`指向`lst`的尾元素或者是一个尾后迭代器，则函数行为未定义 |

改写 p312 中从`list`中删除奇数元素的循环程序，将其改为从`forward_list`中删除元素：

```cpp
forward_list<int> flst = {0,1,2,3,4,5,6,7,8,9};
auto prev = flst.before_begin();        // 表示 flst 的“前首元素”
auto curr = flst.begin();               // 表示 flst 中的第一个元素
while (curr != flst.end()) {            // 仍有元素要处理
    if (*curr % 2)                      // 若元素为奇数
        curr = flst.erase_after(prev);  // 删除它并移动 curr
    else {
        prev = curr;    // 移动迭代器 curr，指向下一个元素，prev
        ++curr;
    }
}
```

分析：当找到奇数元素后，我们将`prev`传递给`erase_after`。此调用将`prev`之后的元素删除，即，删除`curr`指向的元素。然后我们将`curr`重置为`erase_after`的返回值，使得`curr`指向序列中下一个元素，`prev`保持不变，仍指向（新）`curr`之前的元素。如果`curr`指向的元素不是奇数，在`else`中我们将两个迭代器都向前移动。

**练习9.27：编写程序，查找并删除 `forward_list<int>` 中的奇数元素。**

```cpp
/* 练习9.27：编写程序，查找并删除 forward_list<int> 中的奇数元素。*/

#include <iostream>
#include <forward_list>

using namespace std;

int main()
{
    forward_list<int> iflst = {1, 2, 3, 4, 5, 6, 7, 8};

    auto prev = iflst.before_begin();   // 前驱元素
    auto curr = iflst.begin();          // 当前元素

    while (curr != iflst.end())
        if (*curr & 1)                  // 奇数
            curr = iflst.erase_after(prev); // 删除，移动到下一元素
        else {
            prev = curr;                // 前驱和当前迭代器都向前推进
            curr++;
        }

    for (curr = iflst.begin(); curr != iflst.end(); curr++)
        cout << *curr << " ";
    cout << endl;

    return 0;
}
// Output: 2 4 6 8
```

**练习9.28：编写函数，接受一个 `forward list<string>` 和两个 `string` 共三个参数。函数应在链表中查找第一个 `string`，并将第二个`string` 插入到紧接着第一个 `string` 之后的位置。若第一个 `string` 未在链表中，则将第二个 `string` 插入到链表末尾。**

```cpp
/* 练习9.28：编写函数，接受一个 `forward list<string>` 和两个 `string` 共三个参数。
函数应在链表中查找第一个 `string`，并将第二个`string` 插入到紧接着第一个 `string` 之后的位置。
若第一个 `string` 未在链表中，则将第二个 `string` 插入到链表末尾。 */

#include <iostream>
#include <forward_list>

using namespace std;

void test_and_insert(forward_list<string> &sflst, const string &s1, const string &s2)
{
    auto prev = sflst.before_begin();               // 前驱元素
    auto curr = sflst.begin();                      // 当前元素
    bool inserted = false;

    while (curr != sflst.end()) {
        if (*curr == s1) {                          // 找到给定字符串
            curr = sflst.insert_after(curr, s2);    // 插入新字符串，curr 指向它
            inserted = true;
        }
        prev = curr;                                // 前驱迭代器向前推进
        curr++;                                     // 当前迭代器向前推进
    }

    if (!inserted)
        sflst.insert_after(prev, s2);               // 未找到给定字符串，插入尾后
}

int main()
{
    forward_list<string> sflst = {"Hello", "!", "world", "!"};

    test_and_insert(sflst, "Hello", "nihao");
    for (auto curr = sflst.cbegin(); curr != sflst.cend(); curr++)
        cout << *curr << " ";
    cout << endl;   // Hello nihao ! world !

    test_and_insert(sflst, "!", "?");
    for (auto curr = sflst.cbegin(); curr != sflst.cend(); curr++)
        cout << *curr << " ";
    cout << endl;   // Hello ! ? world ! ?

    test_and_insert(sflst, "Bye", "Zaijian");
    for (auto curr = sflst.cbegin(); curr != sflst.cend(); curr++)
        cout << *curr << " ";
    cout << endl;   // Hello ! world ! Zaijian

    return 0;
}
```

### 9.3.5 改变容器大小

用`resize`来增大或缩小容器

```cpp
list<int> ilist(10, 42);    // 10 个 int：每个的值都是42
ilist.resize(15);           // 将 5 个值为 0 的元素添加到 ilist 的末尾
ilist.resize(25, -1);       // 将 10个 值为 -1 的元素添加列 ilist 的末尾
ilist.resize(5);            // 从 ilist 末尾删除 20 个元素
```

| 表9.9：                 | 顺序容器大小操作                                             |
| ----------------------- | ------------------------------------------------------------ |
| `resize`不适用于`array` |                                                              |
| `c.resize(n)`           | 调整`c`的大小为`n`个元素。若 `n<c.size()` 则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化 |
| `c.resize(n,t)`         | 调整`c`的大小为`n`个元素。任何新添加的元素都初始化为值`t`    |

WARNNG: 如果`resize`缩小容器，则指向被删除元素的迭代器、引用和指针都会失效：对`vector`、`string`或`deque`进行`resize`可能导致迭代器、指针 和引用失效。

**练习9.30:接受单个参数的`resize`版本对元素类型有什么限制（如果有的话）？**

 【出题思路】 更深入理解改变容器大小的操作。
 【解答】对于元素是类类型，则单参数`resize`版本要求该类型必须提供一个**默认构造函数**。

### 9.3.6 容器操作可能使迭代器失效

**在向容器添加元素后：**

- 如果容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。

- 对于`deque`，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。

- 对于`list`和`forward_list`，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。

**当我们删除一个元素后：**

- 对于`list`和`forward_list`,指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。

- 对于`deque`，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代群、引用或指针也会失效。如果是删除`deque`的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。

- 对于`vector`和`string`，指向被删元素之前元素的迭代器、引用和指针仍有效。 注意：当我们删除元素时，尾后迭代器总是会失效。

**建议：管理迭代器：**

必须保证每次改变容器的操作之后都正确地重新定位迭代器。这个建议对`vector`、`string`和`deque`尤为重要。

#### 编写改变容器的循环程序

程序比须保证每个循环步中都更新迭代器、引用和指针。如果循环中调用的是`insert`或`erase`，那么更新迭代器很容易。这些操作都返回迭代器，我们可以用来更新：

```cpp
// 此程序删除 vector 中的偶数值元素，并复制每个奇数值元素
// 我们在调用 insert 和 erase 后都更新迭代器，因为两者都会使迭代器失效
vector<int> vi = {0,1,2,3,4,5,6,7,8,9};
auto iter = vi.begin();
while (iter != vi.end()) {
    if (*iter % 2) {
        iter = vi.insert(iter, *iter);  // 复制当前元素
        iter += 2;  // 当前移动迭代器，跳过当前元素以及插入到它之前的元素
    } else
        iter = vi.erase(iter);          // 删除偶数元素
        // 不应向前移动迭代器，iter 指向我们删除的元素之后的元素
}
```

在调用`erase`后，不必递增迭代器，因为`erase`返回的迭代器已经指向序列中下一个元素。
调用`insert`后，需要递增迭代器两次。记住，`insert`在给定位置之前插入新元素，然后返回指向新插入元素的迭代器。因此，在调用`insert`后，`iter`指向新插入元素，位于我们正在处理的元素之前。我们将迭代器递增两次，恰好越过了新添加的元素和正在处理的元素，指向下一个未处理的元素。

**练习9.32：在第316页的程序中，像下面语句这样调用`insert`是否合法？如果不合法，为什么？**

```cpp
iter = vi.insert(iter, *iter++);
```

【出题思路】
本题复习实参与形参的关系，进一步熟悉迭代器的处理对容器操作的关键作用。

[在一条语句中混用解引用和递增运算符](https://github.com/KimmiGYH/CPP_Primer_Notes_Public/blob/master/%E7%AC%AC4%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#%E5%9C%A8%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%B7%B7%E7%94%A8%E8%A7%A3%E5%BC%95%E7%94%A8%E5%92%8C%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6)

【解答】 很多编译器对实参求值、向形参传递的处理顺序是**由右至左**的。
这意味着，编译器在编译上述代码时，首先对`*iter++*`求值，传递给`insert`第二个形参，此时`iter`已指向当前奇数的下一个元素，因此传递给`insert`的第一个参数的迭代器指向的是错误位置，程序执行会发生混乱，最终崩溃。

**练习9.31：第316页中删除偶数值元素并复制奇数值元素的程序不能用于`list` 或`forward_list`。为什么，修改程序，使之也能用于这些类型。**

【出题思路】
本题继续练习`list`和`forward_list`的插入、删除操作，理解与其他容器的 不同，理解对迭代器的影响。

【解答】`list`和`forward_list`与其他容器的一个不同是，迭代器不支持加减运算，究其原因，**链表中元素并非在内存中连续存储**，因此无法通过地址的加减在元素间远距离移动。因此，应多次调用`++`来实现与迭代器加法相同的效果。

```cpp
#include <iostream>
#include <list>

using namespace std;

int main()
{
    // 删除偶数元素，复制每个奇数元素
    list<int> ilst = {0,1,2,3,4,5,6,7,8,9};
    auto curr = ilst.begin();                   // 首节点

    while (curr != ilst.end()) {
        if (*curr & 1) {                        // 奇数
            curr = ilst.insert(curr, *curr);    // 插入到当前元素之前
            curr++; curr++;                     // 移动到下一元素
        } else                                  // 偶数
            curr = ilst.erase(curr);            // 删除，指向下一元素
    }

    for (curr = ilst.begin(); curr != ilst.end(); curr++)
        cout << *curr << " ";
    cout << endl;

    return 0;
}
```

对于 `forward_list`，由于是单项链表结构，删除元素时，需将前驱指针调整为指向下一个节点，因此需维护“前驱”、“后继”两个迭代器。

```cpp
#include <iostream>
#include <forward_list>

using namespace std;

int main()
{
    forward_list<int> iflst = {0,1,2,3,4,5,6,7,8,9};
    auto prev = iflst.before_begin();               // 前驱节点
    auto curr = iflst.begin();                      // 首节点

    while (curr != iflst.end()) {
        if (*curr & 1) {                            // 奇数
            curr = iflst.insert_after(curr, *curr); // 插入到当前元素之后
            prev = curr;                            // prev 移动到新插入元素
            curr++;                                 // curr 移动到下一元素
        } else                                      // 偶数
            curr = iflst.erase_after(prev);         // 删除，curr 指向下一元素
    }

    for (curr = iflst.begin(); curr != iflst.end(); curr++)
        cout << *curr << " ";
    cout << endl;

    return 0;
}
```

#### 不要保存`end`返回的迭代器

保存尾迭代器的值是一个坏主意，不能在循环之前保存`end`返回的迭代器一直当做容器末尾使用。

Tip: 如果在一个循环体中插入/删除 `deque`、`string` 或 `vector` 中的元素，不要缓存 `end` 返回的迭代器。

```cpp
// 更安全的方法：在每个循环步添加/删除元素后都重新计算 end
while (begin != v.end()) {
    // 做一些处理
    ++begin;    // 向前移动 begin，因为我们想在此元素之后插入元素
    begin = v.insert(begin, 42);    // 插入新值
    ++begin;    // 向前移动 begin，跳过我们刚刚加入的元素
}
```

## 9.4 vector对象是如何增长的 (倍增)

假定容器中元素是连续存储的，且容器的大小是可变的，考虑向`vector`或`string`中添加元素会发生什么：
如果没有空间容纳新元素，容器不可能简单地将它添加到内存中其他位置——因为元素必须连续存储。容器必须分配新的内存空间来保存己有元素和新元素，将已有元素从旧位置移动到新空间中，然后添加新元素，释放旧存储空间。如果我们每添加一个新元素，`vector`就执行一次这样的内存分配和释放操作，性能会慢到不可接受。

为了避免这种代价，标准库实现者采用了可以减少容器空间重新分配次数的策略。当不得不获取新的内存空间时，`vector`和`string`的实现通常会分配比新的空间需求更大的内存空问。容器预留这些空间作为备用，可用来保存更多的新元素。
这样，就不需要每次添加新元素都重新分配容器的内存空间了。这种分配策略比每次添加新元素时都重新分配容器内存空间的策略要高效得多。其实际性能也表现得足够好——虽然`vector`在每次重新分配内存空间时都要移动所有元素，但使用此策略后，其扩张操作通常比`list`和`deque`还要快。

### 管理容量的成员函数

| 表9.10：            | 容器大小管理操作                                     |
| ------------------- | ---------------------------------------------------- |
| `shrink_to_fit`     | 只适用于`vector`、`string`和`deque`。 |
|`capacity`和`reserve`| 只适用于`vector`和`string`。    |
| `c.shrink_to_fit()` | 请将`capacity()`减少为与`size()`相同大小             |
| `c.capacity()`      | 不重新分配内存空间的话，`c`可以保存多少元素          |
| `c.reserve(n)`      | 分配至少能容纳`n`个元素的内存空间                    |

Note: `reserve`并不改变容器中元素的数量，它仅影响`vector`预先分配多大的内存空间。

在新标准库中，我们可以调用`shrink_to_fit`来要求`deque`、`vector`或`string`退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用`shrink_to_fit`也并不保证一定退回内存空间。

### `capacity`和`size`

**练习9.39：解释下面程序片段做了什么：**

```cpp
vector<string> svec;
svec.reserve(1024);
string word;
while (cin >> word)
    svec.push_back(word);
svec.resize(svec.size() + svec.size()/2);
```

【解答】
首先，`reserve`为`svec`分配了`1024`个元素（字符串）的空间。

随后，循环会不断读入字符串，添加到`svec`末尾，直至遇到文件结束符。这个过程中，如果读入的字符串数量不多于`1024`，则`svec`的容量(`capacity`)保持不变，不会分配新的内存空间。
否则，会按一定规则分配更大的内存空间，并进行字符串的移动。

接下来，`resize`将向`svec`末尾添加当前字符串数量一半那么多的新字符串， 它们的值都是空串。若空间不够，会分配足够容纳这些新字符串的内存空间。

**练习9.35：解释一个`vector`的`capacity`和`size`有何区别。**

【解答】

理解`capacity`和`size`的区别非常重要。

容器的`size`是指它己经保存的元素的数目；而`capacity`则是在不分配新的内存空间的前提下它最多可以保存多少元素。

**练习9.37：为什么`list`或`array`没有`capacity`成员函数？**

【出题思路】
理解`list`和`array`与`vector`在数据结构上的差异导致内存分配方式的不同。

【解答】
`list`是链表，当有新元素加入时，会从内存空间中分配一个新节点保存它；当从链表中删除元素时，该节点占用的内存空间会被立刻释放。
因此，一个链表占用的内存空间总是与它当前保存的元素所需空间相等(换句话说，`capacity`总是等于`size`)。

而`array`是固定大小数组，内存一次性分配，大小不变，不会变化。

因此它们均不需要`capacity`。

## 9.5 额外的string操作

- `string`类和C风格字符数组之间的相互转换
- 用下标代替迭代器的版本

### 9.5.1 构造string的其他方法

| 表 9.11：                        | 构造 `string` 的其他方法                                     |
| -------------------------------- | ------------------------------------------------------------ |
| `n`, `len` 和 `pos2`都是无符号值 |                                                              |
| `string s(cp, n)`                | `s` 是 `cp` 指向的数组中前 `n` 个字符的拷贝。此数组至少应该包含 `n` 个字符 |
| `string s(s2, pos2)`             | `s` 是 `string s2` 从下标 `pos2` 开始的字符的拷贝。若 `pos2 > s2.size()`，构造函数的行为未定义 |
| `string s(s2, pos2, len2)`       | `s` 是 `string s2` 从下标 `pos2` 开始 `len2` 个字符的拷贝。若 `pos2 > s2.size()`，构造函数的行为未定义。不管 `len2`的值是多少，构造函数至多拷贝 `s2.size() - pos2` 个字符 |

```cpp
const char* cp = "Hello World!!!"; // 以空字符结束的数组
char noNull[] = {'H', 'i'}; // 不是以空字符结束
string s1(cp);          //拷贝 cp 中的字符直到遇到空字符；s1 == "Hello Wolrd!!!"
string s2(noNull, 2);   //从 noNull 拷贝两个字符；s2 == "Hi"
string s3(noNull);      // 未定义：noNUll 不是以空字符结束
string s4(cp + 6, 5);   // 从 cp[6] 开始拷贝 5 个字符；s4 == "Wolrd"
string s5(s1, 6, 5);    // 从 s1[6] 开始拷贝 5 个字符；s5 == "World"
string s6(s1, 6);       // 从 s1[6] 开始拷贝，直至 s1 末尾；s6 == "World!!!"
string s7(s1, 6, 20);   // 正确，只拷贝到 s1 末尾；s7 == "World!!!"
string s8(s1, 16);      // 抛出一个 out_of_range 异常
```

总结：

1. 通常我们从一个 `const char*` 创建 `string` 时，指针指向的数组必须以**空字符**结尾，拷贝操作遇到空字符时停止。(s7的情况)
2. 如果我们还传递给构造函数一个**计数值**，数组就不必以空字符结尾。(s2的情况)
3. 如果我们未传递**计数值**也未以**空字符**结尾，或者给定**计数值大于数组大小**，则构造函数的行为是未定义的
4. 当从一个 `string` 拷贝字符时，我们可以提供一个可选的开始位置和一个计数值。开始位置必须小于或等于给定的 `string` 的大小。如果位置大于 `size`，则构造函数抛出一个 `out_of_range` 异常。(s8的情况)
5. 当从一个 `string` 拷贝字符时，如果我们传递了一个计数值，则从给定位置开始拷贝这么多个字符。不管我们要求考呗多少个字符，标准库最多拷贝到 `string` 结尾，不会更多。(s7的情况)

#### `substr`操作

- 可以传递给 `substr` 一个可选的开始位置和计数值。
- `s.substr(pos, count)` 返回一个 `string`，包含 `s` 中从 `pos` 开始的 `count` 个字符的拷贝。
- `pos` 默认值为 `0`；`count` 的默认值为 `s.size() - pos`，即拷贝从 `pos` 开始的所有字符。
- 返回含子串 `[pos, pos+count)` 的 string。

```cpp
string s("hello world");
string s2 = s.substr(0, 5); // s2 = hello
string s3 = s.substr(6);    // s3 = world
string s4 = s.substr(6, 11);// s3 = world
string s5 = s.substr(12);   // 抛出一个 out_of_range 异常
```

**练习9.41：编写程序，从一个 `vector<char>` 初始化一个 `string`。**

解答：`vector` 提供了 `data` 成员函数，返回其内存空间的首地址。将此返回值作为 `string` 的构造函数的第一个参数，将 `vector` 的 `size` 返回值作为第二个参数，即可获取 `vector<char>` 中的数据，将其看做一个字符数组来初始化 `string`。

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

int main()
{
    vector<char> vc = {'H', 'e', 'l', 'l', 'o'};
    string s(vc.data(), vc.size());
    cout << s << endl;

    return 0;
}
```

**练习 9.42：假定你希望每次读取一个字符存入一个 `string` 中而且知道最少需要读取 100 个字符，你应该如何提高程序的性能？**

解答：考察高效地处理动态增长的 `string`。由于知道至少读取 $100$ 个字符，因此可以用 `reserve` 先为 `string` 分配 $100$ 个字符的空间，然后逐个读取字符，用 `push_back` 添加到 `string` 末尾。

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

void input_string(string &s)
{
    s.reserve(100);
    char c;
    while (cin >> c)
        s.push_back(c);
}

int main()
{
    string s;
    input_string(s);
    cout << s << endl;

    return 0;
}
```

### 9.5.2 改变string的其他方法

`string` 还支持 `assign`、`insert` 和 `erase`操作。

- 除了接受迭代器的 `insert` 和 `erase` 版本外，`string` 还提供了接受下标的版本。下标指出了开始删除的位置，或是 `insert` 到给定值之前的位置：

```cpp
s.insert(s.size(), 5, '!'); //在 s 末尾插入 5 个感叹号
s.erase(s.sizes() - 5, 5);  //从 s 删除最后 5 个字符
```

- 标准库 `string` 类型还提供了接受 C风格字符数组的 `insert` 和 `assign` 版本。我们可以将以空字符结尾的字符数组 `insert` 到或 `assign`给一个 `string`：

```cpp
const char* cp = "Stately, plump Buck";
s.assign(cp, 7);            // s == "Stately"
s.insert(s.size(), cp + 7); // s == "Stately, plump Buck"
```

我们通过调用 `assign` 替换 `s` 的内容。我们赋予 `s` 的是从 `cp` 指向的地址开始的 `7` 个字符。要求赋值的字符数必须小于或等于 `cp` 指向的数组中的字符数（不包括结尾的空字符）。

接下来在 `s` 上调用 `insert`，意图是将字符插入到 `s[size()]` 处（不存在的）元素之前的位置。在此例中，我们将 `cp` 开始的 `7` 个字符（至多到结尾空字符之前）拷贝到 `s` 中。

- 我们也可以指定将来自其他 `string` 或子字符串的字符插入到当前 `string` 中或赋予当前 `string`：

```cpp
string s = "some string", s2 = "some other string";
s.insert(0, s2);    //在 s 中位置 0 之前插入 s2 的拷贝
s.insert(0, s2, 0, s2.size());  //在 s[0] 之前插入 s2 中 s2[0] 开始的 s2.size() 个字符
```

#### `append`和`replace`函数

- `append` 是在 `string` 末尾进行插入操作的一种简写形式，总是替换 `string` 中的所有内容：

```cpp
string s("C++ Primer"), s2 = s; //将 s 和 s2 初始化为 "C++ Primer"
s.insert(s.size(), " 4th Ed."); // s == "C++ Primer 4th Ed."
s2.append(" 4th Ed.");  //等价方法：将" 4th Ed."追加到 s2；s == s2
```

- `replace` 操作是调用 `erase` 和 `insert` 的一种简写形式：

```cpp
// 将 "4th" 替换为 "5th" 的等价方法
s.erase(11, 3);     // s == "C++ Primer Ed."
s.insert(11, "5th");// s == "C++ Primer 5th Ed."
// 从位置 11 开始，删除 3 个字符并插入 "5th"
s2.replace(11, 3, "5th");   //等价方法： s == s2
// 可以插入一个更长或更短的string
s.replace(11, 3, "Fifth");  // s == "C++ Primer Fifth Ed."
```

#### 改变`string`的多种重载函数

**练习9.43：编写函数，接受三个 string 参数 `s`、`oldVal` 和 `newVal`。使用迭代器及 `insert` 和 `erase` 函数将 `s` 中所有 `oldVal` 替换为 `newVal`。测试你的成废墟，用它替换通用的简写形式，如，将 "tho" 替换为 "though"，将 "thru" 替换为 "through"。**

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

void replace_string(string& s, const string& oldVal, const string& newVal)
{
    int len = oldVal.size();
    if (!len) return;   // 要查找的字符串为空
    auto iter = s.begin();
    while (iter <= s.end()-1)
    {
        auto iter1 = iter;
        auto iter2 = oldVal.begin();
        // s 中 iter 开始的子串必须每个字符都与 oldVal 相同
        while (iter2 != oldVal.end() && *iter1 == *iter2) {
            iter1++;
            iter2++;
        }
        if (iter2 == oldVal.end()) {    // oldVal耗尽——字符串相等
            iter = s.erase(iter, iter1);// 删除 s 中与 oldVal 相等的部分
            if (newVal.size()) {        // newVal不为空时
                iter2 = newVal.end();   // 由后至前逐个顺次将newVal中的字符插入到s中
                do {
                    iter2--;
                    iter = s.insert(iter, *iter2);
                } while (iter2 > newVal.begin());
            }
            iter += newVal.size();      // 迭代器移动到新插入内容之后
        } 
        iter++;
    }    
}

int main()
{
    string s = "tho thru tho!";

    replace_string(s, "thru", "through");
    cout << s << endl; // "tho through tho!"

    replace_string(s, "tho", "though");
    cout << s << endl; // "though through though!"

    replace_string(s, "through", "");
    cout << s << endl; // "though  though!"

    return 0;
}
```

**练习9.44：重写上一题的函数，这次使用一个下标和 `replace`。**

由于可以使用下标和 `replace`，因此可以更为简单地实现上一题的目标。
通过 `find` 成员函数（只支持下标参数）即可找到 `s` 中与 `oldVal` 相同的子串，接着用 `replace` 即可将找到的子串替换为新内容。

可以看到，使用下标而不是迭代器，通常可以更简单地实现字符串操作。

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

void replace_string(string& s, const string& oldVal, const string& newVal)
{
    int p = 0;
    while ((p = s.find(oldVal, p)) != string::npos) // string::npos返回字符串尾指示器
    {
        s.replace(p, oldVal.size(), newVal); // 将找到的子串替换为 newVal 的内容
        p += newVal.size(); // 下标调整到新插入内容之后
    }
}

int main()
{
    string s = "tho thru tho!";

    replace_string(s, "thru", "through");
    cout << s << endl; // "tho through tho!"

    replace_string(s, "tho", "though");
    cout << s << endl; // "though through though!"

    replace_string(s, "through", "");
    cout << s << endl; // "though  though!"

    return 0;
}
```

**练习9.45：编写函数，接受一个表示名字的 `string` 参数和两个分别表示前缀（如 "Mr." 或 "Ms."）和后缀（如 "Jr." 或 "III"）的字符串。使用迭代器及 `insert` 和 `append` 函数将前缀和后缀添加到给定的名字中，将生成的新 `string` 返回。**

解答：通过 `insert` 插入到首位置之前，即可实现前缀插入。通过 `append` 即可实现将后缀追加到字符串末尾。

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

void name_string(string& name, const string& prefix, const string& suffix)
{
    name.insert(name.begin(), 1, ' '); // 加空格
    name.insert(name.begin(), prefix.begin(), prefix.end()); // 插入前缀
    name.append(" ");
    name.append(suffix.begin(), suffix.end());
}

int main()
{
    string name = "James Bond";
    name_string(name, "Mr.", "II");
    cout << name << endl; // Mr. James Bond II

    name = "M";
    name_string(name, "Mrs.", "III");
    cout << name << endl; // Mrs. M III

    return 0;
}
```

**练习9.46：重写上一题的函数，这次使用位置和长度来管理 `string`，并只使用 `insert`。**

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

void name_string(string& name, const string& prefix, const string& suffix)
{
    /*  使用 isnert，0 等价于 begin()，都是在当前首字符之前插入新字符串；
        size() 等价于 end()，都是在末尾追加新字符串。    */
    name.insert(0, " ");
    name.insert(0, prefix);             // 插入前缀
    name.insert(name.size(), " ");
    name.insert(name.size(), suffix);   // 插入后缀
}

int main()
{
    string name = "James Bond";
    name_string(name, "Mr.", "II");
    cout << name << endl; // Mr. James Bond II

    name = "M";
    name_string(name, "Mrs.", "III");
    cout << name << endl; // Mrs. M III

    return 0;
}
```

### 9.5.3 `string` 搜索操作

`string` 类提供了 $6$ 个不同的搜索函数。每个搜索操作都返回一个 `string::size_type` 值，表示匹配发生位置的下标。

如果搜索失败，则返回一个名为 `string::npos` 的 `static` 成员。标准库将 `npos` 定义为一个 `const string::size_type` 类型，并初始化为值 `-1`。

由于 `npos` 是一个 `unsigned` 类型，此初值意味着 `npos` 等于任何 `string` 最大的可能大小。用一个 `int` 或其他带符号类型来保存这些函数的返回值不妥。

- `find` 函数查找参数指定的字符串，若找到，则返回第一个匹配位置的下标，否则返回 `npos`：

```cpp
string name("AnnaBelle");
auto pos1 = name.find("Anna"); // pos1 == 0
```

- 查找与给定字符串中任何一个字符匹配的位置。例如，下面代码定位 `name` 中的第一个数字：

```cpp
string numbers("0123456789"), name("r2d2");
// 返回 1，即，name 中第一个数字的下标
auto pos = name.find_first_of(numbers);
```

- 如果要搜索第一个不在参数中的字符，应该调用 `find_first_not_of`。例如，为了搜索一个 `string` 中第一个非数字字符，可以这样做：

```cpp
string dept("03714p3");
// 返回 5 —— 字符 'p' 的下标
auto pos = dept.find_first_not_of(numbers);
```


| 表9.14：`string`搜索操作                                  |                                                              |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| 搜索操作返回指定字符出现的下标，如果未找到则返回 `npos`。 |                                                              |
| `s.find(args)`                                            | 查找 `s` 中 `args` 第一次出现的位置                          |
| `s.rfind(args)`                                           | 查找 `s` 中 `args` 最后一次出现的位置                        |
| `s.find_first_of(args)`                                   | 在 `s` 中查找 `args` 中任何一个字符第一次出现的位置。        |
| `s.find_last_of(args)`                                    | 在 `s` 中查找 `args` 中任何一个字符最后一次出现的位置        |
| `s.find_first_not_of(args)`                               | 在 `s` 中查找第一个不在 `args` 中的字符                      |
| `s.find_last_not_of(args)`                                | 在 `s` 中查找最后一个不在 `args` 中的字符                    |
| **args 必须是以下形式之一**                               |                                                              |
| `c, pos`                                                  | 从 `s` 中位置 `pos` 开始查找字符 `c`。`pos` 默认为 `0`       |
| `s2, pos`                                                 | 从 `s` 中位置 `pos` 开始查找字符串 `s2`。`pos` 默认为 `0`    |
| `cp, pos`                                                 | 从 `s` 中位置 `pos` 开始查找指针 `cp` 指向的以空字符结尾的 C风格字符串。`pos` 默认为 `0` |
| `cp, pos, n`                                              | 从 `s` 中位置 `pos` 开始查找指针 `cp` 指向的数组的前 `n` 个字符。`pos` 和 `n` 无默认值 |

#### 指定在哪里开始搜索

我们可以传递给 `find` 操作一个可选的开始位置。这个可选的参数指出从哪个位置开始进行搜索。默认情况下，此位置被置为 `0`。一种常见的程序设计模式是用这个可选参数在子字符串中循环地搜索子字符串出现的所有位置：

```cpp
string::size_type pos = 0;
// 每步循环查找 name 中下一个数
while ((pos = name.find_first_of(numbers, pos)) != string::npos) {
    cout << "found number at index: " << pos << " element is " << name[pos] << endl;
    ++pos; // 移动到下一个字符
}
```

#### 逆向搜素 `rfind`

`rfind` 成员函数搜索最后一个匹配，即字符串中最靠右的出现位置：

```cpp
string river("Mississippi");
auto first_pos = river.find("is"); // 返回 1
auto last_pos = river.rfind("is"); // 返回 4
```

- `find_last_of` 搜索与给定 `string` 中任何一个字符匹配的最后一个字符。
- `find_last_not_of` 搜索最后一个不出现在给定 `string` 中的字符。

**练习9.47：编写程序，首先查找 `string` "ab2c3d7R4E6" 中的每个数字字符，然后查找其中每个字母字符。编写两个版本的程序，第一个要使用 `find_first_of`，第二个要使用 `find_first_not_of`。**

```cpp
#include <cstdio>
#include <iostream>
#include <string>

using namespace std;

void find_char(string& s, const string& chars)
{
    printf("In string s: %s found element: %s\n", s.c_str(), chars.c_str());

    string::size_type pos = 0;
    while ((pos = s.find_first_of(chars, pos)) != string::npos)
    {
        cout << "pos: " << pos << ", char: " << s[pos] << endl;
        pos++;
    }
}

int main()
{
    string s = "ab2c3d7R4E6";

    cout << "Found all the digits" << endl;
    find_char(s, "0123456789");
    
    cout << endl << "Found all the letters" << endl;
    find_char(s, "abcdefghijklmnopqrstuvwxyz"\
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ");

    return 0;
}
/*
Found all the digits
In string s: ab2c3d7R4E6 found element: 0123456789
pos: 2, char: 2
pos: 4, char: 3
pos: 6, char: 7
pos: 8, char: 4
pos: 10, char: 6

Found all the letters
In string s: ab2c3d7R4E6 found element: abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
pos: 0, char: a
pos: 1, char: b
pos: 3, char: c
pos: 5, char: d
pos: 7, char: R
pos: 9, char: E
*/
```

```cpp
#include <cstdio>
#include <iostream>
#include <string>

using namespace std;

void find_not_char(string& s, const string& chars)
{
    printf("In string s: %s not found element: %s\n", s.c_str(), chars.c_str());

    string::size_type pos = 0;
    while ((pos = s.find_first_not_of(chars, pos)) != string::npos)
    {
        cout << "pos: " << pos << ", char: " << s[pos] << endl;
        pos++;
    }
}

int main()
{
    string s = "ab2c3d7R4E6";

    cout << "Found all the digits" << endl;
    find_not_char(s, "abcdefghijklmnopqrstuvwxyz"\
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
    
    cout << endl << "Found all the letters" << endl;
    find_not_char(s, "0123456789");


    return 0;
}
/*
Found all the digits
In string s: ab2c3d7R4E6 not found element: abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
pos: 2, char: 2
pos: 4, char: 3
pos: 6, char: 7
pos: 8, char: 4
pos: 10, char: 6

Found all the letters
In string s: ab2c3d7R4E6 not found element: 0123456789
pos: 0, char: a
pos: 1, char: b
pos: 3, char: c
pos: 5, char: d
pos: 7, char: R
pos: 9, char: E
*/
```

**练习9.48：假定 `name` 和 `numbers` 的定义如 325 页所示，`numbers.find(name)` 返回什么？**

P325：查找与给定字符串中任何一个字符匹配的位置。例如：下面代码定位 `name` 中的第一个数字：

```cpp
string numbers("0123456789"), name("r2d2");
// 返回 1，即，name 中第一个数字的下标
auto pos = name.find_first_of(numbers);
```

```cpp
#include <cstdio>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string name = "r2d2", numbers = "0123456789";
    
    printf("In string s: \"%s\" to find elment: \"%s\"\n", name.c_str(), numbers.c_str());

    string::size_type pos = 0;
    while ((pos = name.find_first_of(numbers, pos)) != string::npos)
    {
        cout << "pos: " << pos << ", numbers: " << name[pos] << endl;
        pos++;
    }

    return 0;
}

/*
In string s: "r2d2" to find elment: "0123456789"
pos: 1, numbers: 2
pos: 3, numbers: 2
*/
```

**练习9.49：如果一个字母延伸到中线之上，如 `d` 或 `f`，则称其有上出头部分 (ascender)。如果一个字母延伸到中线之下，如 `p` 或 `g`，则称其有下出头部分 (descender)。编写程序，读入一个单词文件，输出最长的既不包含上出头部分，也不包含下出头部分的单词。**

解答：查找既不包含上出头字母，也不包含下出头字母的单词，等价于“排除包含上出头字母或下出头字母的单词”。因此，用 `find_first_of` 在单词中查找上出头字母或下出头字母是否出现。

- 若出现（返回一个合法位置，而非 `npos`），则丢弃此单词，继续检查下一个单词。
- 否则，表明单词符合要求，检查它是否比之前的最长合法单词更长，若是，记录其长度和内容。
- 文件读取完毕后，输出最长的合乎要求的单词。

```cpp
#include <iostream>
#include <fstream>
#include <string>

using namespace std;

void find_longest_word(ifstream &in)
{
    string s, longest_word;
    int max_length = 0;

    while (in >> s) {
        if (s.find_first_of("bdfghjklpqty") != string::npos)  continue; // 重要
        cout << s << " ";
        if (max_length < s.size()) { // 新单词更长
            max_length = s.size(); // 记录长度和单词
            longest_word = s;
        }
    }
    cout << endl << "Longest string is: " << longest_word << endl;
}


int main(int argc, char *argv[])
{
    ifstream in(argv[1]);
    if (!in) {
        cerr << "Can't open the input file" << endl;
        return -1;
    }

    find_longest_word(in);

    return 0;
}
```

### 9.5.4 compare函数

标准库 string 类型提供了一组 `compare` 函数，这些函数与 C标准库的 `strcmp` 函数很相似，类似 `strcmp`，根据 `s` 是等于、大于还是小于参数指定的字符串，`s.compare` 返回 `0`、正数或负数。

| 表9.15：                            | `s.compare()`的几种参数形式                                  |
| ----------------------------------- | ------------------------------------------------------------ |
| `s.compare(s2)`                     | 比较 `s` 和 `s2`                                             |
| `s.compare(pos1, n1, s2)`           | 将 `s` 中从 `pos1` 开始的 `n1` 个字符与 `s2` 进行比较        |
| `s.compare(pos1, n1, s2, pos2, n2)` | 将 `s` 中从 `pos1` 开始的 `n1` 个字符与 `s2` 中从 `pos2` 开始的 `n2` 个字符进行比较 |
| `s.compare(cp)`                     | 比较 `s` 与 `cp` 指向的以空字符结尾的字符数组                |
| `s.compare(pos1, n1, cp)`           | 将 `s` 中从 `pos1` 开始的 `n1` 个字符与 `cp` 指向的以空字符结尾的字符数组进行比较 |
| `s.compare(pos1, n1, cp, n2)`       | 将 `s` 中从 `pos1` 开始的 `n1` 个字符与 `cp` 指向的地址开始的 `n2` 个字符进行比较 |

### 9.5.5 数值转换

- `string s = to_string(i)` // 将整数 `i` 转换为字符表示形式
- `double d = stod(s)` // 将字符串 `s` 转换为浮点数

**表9.16：`string`和数值之间的转换**

```cpp
to_string(val)
// 一组重载函数，返回值 val 的 string 表示。val 可以是任何算术类型。
// 对每个浮点类型和 int 或更大的整型，都有相应版本的 to_string。
// 与往常一样，小整型会被提升。

stoi(s, p, b)
stol(s, p, b)
stoul(s, p, b)
stoll(s, p, b)
stoull(s, p, b)
// 返回 s 的起始子串（表示整数内容）的数值，
// 返回值类型分别是 int、long、unsigned long、long long、unsigned long long。
// b 表示转换所用的基数，默认值为 10.
// p 是 size_t 指针，用来保存 s 中第一个非数值字符的下标，p 默认为 0，即，函数不保存下标

stof(s, p)
stod(s, p)
stold(s, p)
// 返回 s 的起始子串（表示浮点数内容）的数值，返回值类型分别是 float、double 或 long double。
// 参数 p 的作用与整数转换函数中一样。
```

- `string` 参数中第一个非空白符必须是符号（`+`或`-`）或数字。
- 它可以以 `0x` 或 `0X` 开头来表示十六进制数。
- 对那些将字符串转换为浮点值的函数，`string` 函数参数也可以以小数点 `.` 开头，并可以包含 `e` 或 `E` 来表示指数部分。
- 对于那些将字符串转换为整型值的函数，根据基数不同，`string` 参数可以包含字母字符，对应大于数字 `9` 的数。
- 当给定的字符串不能转换为数值时（不是所需类型数值的合法表示），这些转换函数会抛出 `invalid_argument` 异常；
- 如果表示的值超出类型所能表达的范围，则抛出一个 `out_of_range` 异常。

**练习9.50：编写程序处理一个 `vector<string>`，其元素都表示整型值。计算 `vector` 中所有元素之和。修改程序，使之计算表示浮点值的 `string` 之和。**

**整型值：**

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    vector<string> vs = {"123", "+456", "-789"};
    int sum = 0;

    for (auto iter = vs.begin(); iter != vs.end(); iter++)
        sum += stoi(*iter);

    cout << "The sum is: " << sum << endl;
    return 0;

    // The sum is: -210
}
```

**浮点值：**

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    vector<string> vs = {"12.3", "-4.56", "+7.8e-2"};
    float sum = 0;

    for (auto iter = vs.begin(); iter != vs.end(); iter++)
        sum += stof(*iter);
    
    cout << "The sum is: " << sum << endl;
    return 0;
    
    // The sum is: 7.818
}
```

**练习9.51：设计一个类，它有三个 `unsigned` 成员，分别表示年、月和日。为其编写构造函数，接受一个表示日期的 `string` 参数。你的构造函数应该能处理不同数据格式，如 `January 1, 1900`、`1/1/1990`、`Jan 1 1900` 等。**

（未完待续）巨复杂 书 P328 练习册P227

## 9.6 容器适配器 (adapter)

除了顺序容器外，标准库还定义了三个顺序容器适配器：
`stack`、`queue`和`priority_queue`

本质上，一个适配器是种机制，能使某种事物的行为看起来像另外种事物一样。一个容器适配器接受一种己有的容器类型，使其行为看起来像一种不同的类型。

例如：`stack`适配器接受一个顺序容器（除`array`或`forward_list`外），并使其操作起来像一个`stack`一样。

| 表9.17：         | 所有容器适配器都支持的操作和类型                             |
| ---------------- | ------------------------------------------------------------ |
| `size_type`      | 一种类型，足以保存当前类型的最大对象的大小                   |
| `value_type`     | 元素类型                                                     |
| `container_type` | 实现适配器的底层容器类型                                     |
| `A a;`           | 创建一个名为`a`的空适配器                                    |
| `A a(c);`        | 创建一个名为`a`的适配器，带有容器`c`的一个拷贝               |
| 关系运算符       | 每个适配器都支持所有关系运算符：`==`、`!=`、`<`、`<=`、`>`和`>=`，这些运算符返回底层容器的比较结果 |
| `a.empty()`      | 若`a`包含任何元素，返回`false`，否则返回`true`               |
| `a.size()`       | 返回`a`中的元素数目                                          |
| `swap(a,b)`      | 交换`a`和`b`的内容，`a`和`b`必须有相同类型，包括底层容器类型也必须相同。 |
| `a.swap(b)`      |                                                              |

### 定义一个适配器

每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构 造的数拷贝该容器来初始化适配器。

例如，假定`deq`是一个`deque<int>`，我们可以用`deq`来初始化一个新的`stack`,如下所示：

```cpp
stack<int> stk(deq);    // 从 deq 拷贝元素到 stk
```

默认情况下，`stack`和`queue`是基于`deque`实现的，
`priority_queue`是在`vector`之上实现的。

我们可以再创建一个适配器时，讲一个命名的顺序容器作为第二类型参数，来重载默认容器类型。

```cpp
// 在 vector 上实现的空栈
stack<string, vector<string>> str_stk;
// str_stk2 在 vector 上实现，初始化时保存 svec 的拷贝
stack<string, vector<string>> str_stk2(svec);
```

所有适配器都要求容器其有添加和删除元素的能力。因此，适配器不能构造在`array`之上。类似的，我们也不能用`forward_list`来构造适配器，因为所有适配器都要求容器具有添加、删除以及访问尾元素的能力。

- `stack`只要求`push_back`、`pop_back`和`back`操作，因此可以使用除`array`和`forward_list`之外的任何容器类型来构造`stack`

- `queue`适配器要求`back`、`push_back`、`front`和`push_front`，因此，它可以构造于`list`或`deque`之上，但不能基于`vector`构造。

- `priority_queue`除了`front`, `push_back`和`pop_back`操作之外还要求随机访问能力，因此它可以构造于`vector`或`deque`之上，但不能基于`list`构造。

### 栈适配器

```cpp
stack<int> intStack;    // 空栈
// 填满栈
for (size_t ix = 0; ix != 10; ++ix)
    intStack.push(ix);  // intStack 保存 0 到 9 十个数
while (!intStack.empty())   // intStack 中有值就继续循环
    int value = intStack.top()  // 使用栈顶值的代码
    intStack.pop();     // 弹出栈顶元素，继续循环
```

| 表9.18：          | 表9.17 未列出的栈操作                                   |
| ----------------- | ------------------------------------------------------- |
|                   | 栈默认基于`deque`实现，也可以在`list`或`vector`之上实现 |
| `s.pop()`         | 删除栈顶元素，但不返回该元素值                          |
| `s.push(item)`    | 创建一个新元素压入栈顶，该元素通过拷贝或移动`item`而来  |
| `s.emplace(args)` | 或者由`args`构造                                        |
| `s.top()`         | 返回栈顶元素，但不能将元素弹出栈                        |

每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。
我们只可以使用适配器操作，而不能使用底层容器类型的操作。例如，

```cpp
intStack.push(ix);  // intStack 保存 0 到 9 十个数
```

此语句试图在`intStack`的底层`deque`对象上调用`push_back`。
虽然`stack`是基于`deque`实现的．但我们不能直接使用`deque`操作。
不能在一个`stack`上调用`push_back`, 而必须使用`stack`自己的操作——`push`。

### 队列适配器

| 表9.19：          | 表9.17未列出的`queue`和`priority_queue`操作                  |
| ----------------- | ------------------------------------------------------------ |
|                   | `queue`默认基于`deque`实现，`priority_queue`默认基于`vector`实现 |
|                   | `queue`也可以用`list`或`vector`实现，`priority_queue`也可以用`deque`实现 |
| `q.pop()`         | 返回`queue`的首元素或`priority_queue`的最高优先级的元素，但不删除此元素 |
| `q.front()`       | 返回首元素或尾元素，但不删除此元素                           |
| `q.back()`        | 只适用于**queue**                                            |
| `q.top()`         | 返回最高优先级元素，但不删除该元素（只适用于`priority_queue`） |
| `q.push(item)`    | 在`queue`末尾或`priority_queue`中恰当的位置创建一个元素，其值为`item`， |
| `q.emplace(args)` | 或者由`args`构造                                             |

(注：在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出(first in, largest out)的行为特征。)

标准库`queue`使用一种先进先出(first-in, first-out, FIFO)的存储和访问策略。

`priority_queue`允许我们为队列中的元素建立优先级。新加入的元素会排在所有优先级比它低的已有元素之前。
饭店按照客人预定时间而不是到来时间的早晚来为他们安排座位，就是一个优先队列的例子。默认清况下，标准库在元素类型上使用`<`运算符来确定相对优先级。

**练习9.52：使用 `stack`处理括号化的表达式。当你看到一个左括号，将其记录下来。当你在一个左括号之后看到一个右括号，从 `stack` 中 `pop` 对象，直至遇到括号，将左括号也一起弹出栈。然后将一个值（括号内的运算结果） `push` 到栈中， 表示一个括号化的（子）表达式已经处理完毕，被其运算结果所替代。**

未完待续，书P331，练习册P230，巨复杂
