<!-- TOC -->

- [第9章 顺序容器 (sequential container)](#第9章-顺序容器-sequential-container)
  - [9.1 顺序容器概述](#91-顺序容器概述)
    - [确定使用哪种顺序容器](#确定使用哪种顺序容器)
  - [9.2 容器库概览](#92-容器库概览)
    - [对容器可以保存的元素类型的限制](#对容器可以保存的元素类型的限制)
      - [表9.2：容器操作](#表92容器操作)
    - [9.2.1 迭代器](#921-迭代器)
      - [迭代器范围](#迭代器范围)
      - [使用左闭合范围蕴含的变成假定](#使用左闭合范围蕴含的变成假定)
    - [9.2.2 容器类型成员](#922-容器类型成员)
    - [9.2.3 begin和end成员](#923-begin和end成员)
    - [9.2.4 容器定义和初始化](#924-容器定义和初始化)
    - [9.2.5 赋值和swap](#925-赋值和swap)
    - [9.2.6 容器大小操作](#926-容器大小操作)
    - [9.2.7 关系运算符](#927-关系运算符)
  - [9.3 顺序容器操作](#93-顺序容器操作)
    - [9.3.1 向顺序容器添加元素](#931-向顺序容器添加元素)
    - [9.3.2 访问元素](#932-访问元素)
    - [9.3.3 删除元素](#933-删除元素)
    - [9.3.4 特殊的forward_list操作](#934-特殊的forward_list操作)
    - [9.3.5 改变容器大小](#935-改变容器大小)
    - [9.3.6 容器操作可能使迭代器失效](#936-容器操作可能使迭代器失效)
  - [9.4 vector对象是如何增长的](#94-vector对象是如何增长的)
  - [9.5 额外的string操作](#95-额外的string操作)
    - [9.5.1 构造string的其他方法](#951-构造string的其他方法)
    - [9.5.2 改变string的其他方法](#952-改变string的其他方法)
    - [9.5.3 string搜索操作](#953-string搜索操作)
    - [9.5.4 compare函数](#954-compare函数)
    - [9.5.5 数值转换](#955-数值转换)
  - [9.6 容器适配器](#96-容器适配器)

<!-- /TOC -->

# 第9章 顺序容器 (sequential container)

**顺序容器**为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。
关联容器中元素的位置由元素相关联的关键字值决定。

## 9.1 顺序容器概述

| 表9.1：        | 顺序容器类型                                                 |
| -------------- | ------------------------------------------------------------ |
| `vector`       | 可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢 |
| `deque`        | 双端队列，支持快速随机访问，在头尾位置插入 / 删除速度很快    |
| `list`         | 双向链表，只支持双向顺序访问，在`list`中任何位置进行插入 / 删除操作速度都很快 |
| `forward_list` | 单向链表，只支持单向顺序访问，在链表任何位置进行插入 / 删除操作速度都很快 |
| `array`        | 固定大小数组，支持快速随机访问，不能添加或删除元素           |
| `string`       | 与`vector`相似的容器，但专门用于保存字符，随机访问快，在尾部插入 / 删除速度快 |

`string` 和 `vector`将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。

但是，在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入或删除操作后，需要移动插入 / 删除位置之后的所有元素，来保持连续存储。而且添加一个元素有时还需要分配额外的存储空间。在这种情况下，每个元素都必须移动到新的存储空间中。

`list` 和 `forward_list` 两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。

作为代价，这两个容器不支持元素的随机访问：为了访问一个元素，我们只能遍历整个容器。而且，与`vector`、`deque`和`array`相比，这两个容器的额外内存开销也很大。

`deque` 是一个更为复杂的数据结构，与`string`和`vector`类似，`deque`支持快速的随机访问。与`string`和`vector`一样，在`deque`的中间位置添加或删除元素的代价（可能）很高。但是，在`deque`的两段添加或删除元素都是很快的，与`list`或`forward_list`添加删除元素的速度相当。

`array`对象的大小是固定的，因此，`array`不支持添加和删除元素以及改变容器大小的操作。

`forward_list`的设计目标是达到与最好的手写的单向链表数据结构相当的性能，因此`forward_list`没有`size`操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，`size`保证是一个快速的常量时间的操作。

### 确定使用哪种顺序容器

Tip: 通常，使用`vector`是最好的选择，除非你有很好的理由选择其他容器。

- 除非你有很好的理由选择其他容器，否则应使用`vector`。
- 如果你的程序又很多小的元素，且空间的额外开销很重要，则不要使用`list`或`forward_list`。
- 如果程序要求随机访问元素，应使用`vector`或`deque`。
- 如果程序要求在容器的中间插入或删除元素，应使用`list`或`forward_list`。
- 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用`deque`。
- 如果程序只有在读取输入时才需要在容器中检位置插入元素，随后需要随机访问元素，则
  - 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向`vector`追加数据，然后再调用标准库的`sort`函数来重排容器中的元素，从而避免在中间位置添加元素。
  - 如果必须在中间位置插入元素，考虑在输入阶段使用`list`，一旦输入完成，将`list`中的内容拷贝到一个`vector`中。

注意：如果不确定应该使用哪种容器，那么可以再程序中只使用`vector`和`list`公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用`vector`或`list`都很方便。

**练习9.1：对于下面的程序任务，`vector`、 `deque`和`list`哪种容器最为适合？解释你的选择的理由。如果没有哪一种容器优于其他容器，也请解释理山。**

(a)读取固定数量的单词，将它们按字典序插入到容器中。我们将在下一章中看到， 关联容器更适合这个问题。

(a)“按字典序插入到容器中”意味着进行插入排序操作，从而需要在容器内部频繁进行插入操作，`vector`在尾部之外的位置插入和删除元素很慢，`deque`在头尾之外的位置插入和删除元素很慢，而`list`在任何位置插入、删除速度都很决。
因此，这个任务选择`list`更为适合。
当然，如果不是必须边读取单词边插入到容器中， 可以使用`vector`，将读入的单词依次追加到尾部，读取完毕后，调用标准库到排序算法将单词重排为字典序。

(b)读取未知数量的单词，总是将新单词插入到末尾。删除操作在头部进行。

(b)由于需要在头、尾分别进行插入、删除操作，因此将 `vector` 排除在外，`deque` 和 `list` 都可以达到很好的性能。如果还需要频繁进行随机访问。则 `deque` 更好。

(c)从一个文件读取未知数量的整数。将这些数排序，然后将它们打印到标准输出。

(c) 由于整数占用空间很小，且快速的排序算法需频繁随机访问元素，将`list`排除在外。由于无须在头部进行插入、删除操作，因此使用`vector`即可，无须使用`deque`。

## 9.2 容器库概览

每个容器都定义在一个头文件中，文件名与类型名相同。
即，`deque`定义在头文件`deque`中，`list`定义在头文件`list`中。
容器均定义为模板类。
例如对`vector`，我们必须提供额外信息来生成特定的容器类型。
对大多数，但不是所有容器，我们还需要额外提供元素类型信息：

```cpp
list<Sales_data>    // 保存 Sales_data 对象的 list
deque<double>       // 保存 double 的 deque
```

### 对容器可以保存的元素类型的限制

顺序容器几乎可以保存任意类型的元素。

```cpp
vector<vector<string>> lines;   // vector 的 vector
// 此处 lines 是一个 vector，其元素类型是 string 的 vector
```

顺序容器构造函数的一个版本，接受容器大小参数，它使用了元素类型的默认构造函数。

但某些类没有默认构造函数，我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数：

```cpp
// 假定 noDefault 是一个没有默认构造函数的类型
vector<noDefault> v1(10, init); // 正确：提供了元素初始化器
vector<noDefault> v2(10);       // 错误：必须提供一个元素初始化器
```

#### 表9.2：容器操作

| 类型别名          |                                                        |
| ----------------- | ------------------------------------------------------ |
| `iterator`        | 此容器类型的迭代器类型                                 |
| `const_iterator`  | 可以读取元素，但不能修改元素的迭代器类型               |
| `size_type`       | 无符号整数类型，足够保存此种容器类型最大可能容器的大小 |
| `difference_type` | 带符号整数类型，足够保存两个迭代器之间的距离           |
| `value_type`      | 元素类型                                               |
| `reference`       | 元素的左值类型：与`value_type&`含义相同                |
| `const_reference` | 元素的`const`左值类型（即，`const value_type&`）       |

| 构造函数           |                                                              |
| ------------------ | ------------------------------------------------------------ |
| `C c`              | 默认构造函数，构造空容器                                     |
| `C c1(c2);`        | 构造 `c2` 的拷贝 `c1`                                        |
| `C c(b, e);`       | 构造 `c`，将迭代器 `b` 和 `e` 指定的范围内的元素拷贝到 `c`（`array`不支持） |
| `C c{a, b, c...};` | 列表初始化 `c`                                               |

| 赋值与`swap`        |                                                     |
| ------------------- | --------------------------------------------------- |
| `c1 = c2`           | 将 `c1` 中的元素替换为 `c2` 中元素                  |
| `c1 = {a, b, c...}` | 将 `c1` 中的元素替换为列表中元素（不适用于`array`） |
| `a.swap(b)`         | 交换 `a` 和 `b` 的元素                              |
| `swap(a, b)`        | 与 `a.swap(b)`等价                                  |

| 大小           |                                                    |
| -------------- | -------------------------------------------------- |
| `c.size()`     | `c` 中元素的数目（不支持 `forward_list`）          |
| `c.max_size()` | `c` 可保存的最大元素数目                           |
| `c.empty()`    | 若 `c` 中存储了元素，返回 `false`，否则返回 `true` |

| 添加 / 删除元素（不适用于 `array`） |                                    |
| ----------------------------------- | ---------------------------------- |
| `c.insert(args)`                    | 将`args`中的元素拷贝进 `c`         |
| `c.emplace(inits)`                  | 使用 `inits` 构造 `c` 中的一个元素 |
| `c.erase(args)`                     | 删除 `args`指定的元素              |
| `c.clear()`                         | 删除 `c` 中的所有元素，返回 `void` |
| 关系运算符                          |                                    |
| `==`，`!=`                          | 所有容器都支持相等（不等）运算符   |
| `<`，`<=`，`>`，`>=`                | 关系运算符（无序关联容器不支持）   |

| 获取迭代器               |                                               |
| ------------------------ | --------------------------------------------- |
| `c.begin()`, `c.end()`   | 返回指向 `c` 的首元素和尾元素之后位置的迭代器 |
| `c.cbegin()`, `c.cend()` | 返回 `const_iterator`                         |

| 反向容器的额外成员（不支持`forward_list`） |                                               |
| ------------------------------------------ | --------------------------------------------- |
| `reverse_iterator`                         | 按逆序寻址元素的迭代器                        |
| `const_reverse_iterator`                   | 不能修改元素的逆序迭代器                      |
| `c.rbegin()`, `c.rend()`                   | 返回指向 `c` 的尾元素和首元素之前位置的迭代器 |
| `c.crbegin()`, `c.crend()`                 | 返回 `const_reverse_iterator`                 |

**练习9.2：定义一个`list`对象，其元素类型是 `int` 的 `deque`。**

list<deque<int>> a;

### 9.2.1 迭代器

#### 迭代器范围

迭代器范围(iterator range)：`begin` 到 `end`(one past the last element)，它们标记了容器中元素的一个范围。

这种元素范围被称为**左闭合区间**(left-inclusive interval)，其标准数学描述为 `[begin, end)`，`end`可以与`begin`指向相同的位置。

#### 使用左闭合范围蕴含的变成假定

假定`begin`和`end`构成一个合法的迭代器范围，则

- 如果`begin`与`end`相等，则范围为空
- 如果`begin`与`end`不等，则范围至少包含一个元素，且`begin`指向该范围中的第一个元素
- 我们可以对`begin`递增若干次，使得`begin==end`

```cpp
while (begin != end)
    *begin = val;   // 正确：范围非空，因此 begin 指向一个元素
    ++begin;        // 移动迭代器，获取下一个元素
```

**练习9.3：构成迭代器范围的迭代器有何限制？**

两个迭代器`begin`和`end`必须指向同一个容器中的元素，或者是容器最后一个元素之后的位置；
而且，对`begin`反复进行递增操作，可保证到达`end`，即`end`不在`begin`之前。

**练习9.4：编写函数，接受一对指向 `vector<int>` 的迭代器和一个 `int` 值。在两个迭代器指定的范围中查找给定的值，返回一个布尔值来指出是否找到。**

```cpp
/* 练习9.4：编写函数，接受一对指向 vector<int> 的迭代器和一个 int 值。
在两个迭代器指定的范围中查找给定的值，返回一个布尔值来指出是否找到。 */

#include <iostream>
#include <vector>

using namespace std;

bool search_vec(vector<int>::iterator beg, vector<int>::iterator end, int val)
{
    for (; beg != end; beg++)   // 遍历范围
        if (*beg == val)        // 检查是否与给定值相等
            return true;
    return false;
}

int main()
{
    vector<int> ilist = {1, 2, 3, 4, 5, 6, 7};

    cout << search_vec(ilist.begin(), ilist.end(), 3) << endl;
    cout << search_vec(ilist.begin(), ilist.end(), 8) << endl;

    return 0;
}
```



### 9.2.2 容器类型成员

### 9.2.3 begin和end成员

### 9.2.4 容器定义和初始化

### 9.2.5 赋值和swap

### 9.2.6 容器大小操作

### 9.2.7 关系运算符

## 9.3 顺序容器操作

### 9.3.1 向顺序容器添加元素

### 9.3.2 访问元素

### 9.3.3 删除元素

### 9.3.4 特殊的forward_list操作

### 9.3.5 改变容器大小

### 9.3.6 容器操作可能使迭代器失效

## 9.4 vector对象是如何增长的

## 9.5 额外的string操作

### 9.5.1 构造string的其他方法

### 9.5.2 改变string的其他方法

### 9.5.3 string搜索操作

### 9.5.4 compare函数

### 9.5.5 数值转换

## 9.6 容器适配器
